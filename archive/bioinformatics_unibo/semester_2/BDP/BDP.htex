<h1 id="part-1---prof.-daniele-cesini">Part 1 - Prof. Daniele Cesini</h1>
<hr />
<h1 id="introduction">Introduction</h1>
<ul>
<li>Prof. Cesini and Prof. Salomoni are both from the INFN-CNAF center in Bologna</li>
<li>The CNAF is the computational center of the INFN, located in Bologna
<ul>
<li>It started as a facility for the analysis of data from bubble chambers</li>
<li>CNAF developped an managed the Italian research network, now managed by GARR</li>
<li>In 1990 CNAF realized the LHC Tier-1 datacenter in Bologna</li>
<li>One of the main actors in GRID worldwide computing</li>
<li>It offers CPU and storage resources to many INFN initiatives</li>
</ul></li>
<li>This course is about infrastructures, not about Big Data</li>
</ul>
<h1 id="big-data">Big data</h1>
<ul>
<li>Cell phone data were used in Pakistan to track and predict the spread of Dengue</li>
<li>Google traffic suggests an optimal route to users according to current conditions</li>
<li>Both of these applications process data from many sources, that come in a non-regular schedule</li>
<li>They both need to quickly process huge amounts of data in real time</li>
<li>The need to be able to quickly verify the validity of data</li>
<li>We are currently producing around 40 Zb per year, and this number is in exponential increase</li>
<li>Big data are characterized by Vs
<ul>
<li>Volume: typically several Tb (<eq env="math">10^{12}</eq>) to Zb (<eq env="math">10^{21}</eq>)</li>
<li>Velocity: data coming at high speed, with short time to react
<ul>
<li>We are in a real-time streaming more than in a batch processing scenario</li>
</ul></li>
<li>Variety: data from different sources, in different formats
<ul>
<li>Data can be structured, semistructured or unstructured</li>
<li>A database table is structured</li>
<li>An xlm file is semi-structured</li>
<li>Text, images, audio files, video streams are unstructured</li>
<li>Big data tend to be mostly unstructured</li>
</ul></li>
<li>Veracity: the degree to which data is trustworthy
<ul>
<li>Big data tend to involve datasets, problem spaces and environments that are difficult to trust</li>
</ul></li>
<li>People are starting to add more Vs, but let’s keep it simple and stick to these 4 Vs</li>
<li>Value: big data is about transforming a lot of data in something valuable</li>
</ul></li>
<li>The Gartner definition of Big Data: Big data is high-volume, high-velocity and/or high-varietyinformation assets that demand cost-effective, innovative forms of information processing that enable enhanced insight, decision making, and process automation</li>
<li>Big data is not just about volume, but it definitely has a big volume</li>
<li>Big Data is a lot of data, coming really fast, in many different formats and from many different sources</li>
<li>The definition of Big data is not static, but it is relative to processing capabilities</li>
<li>The Gartner hype cycle of emerging technologies: new technologies go through an innovation trigger, a peak of inflated expectations, a trough of disillusionment, and then finally enter the slope of enlightment and the plateau of productivity</li>
<li>Big data is not reported in the last Gartner hype cycle, since it is NOT consider an emerging technology, but a prevalent aspect of many modern technologies</li>
<li>Big data come from a variety of sources
<ul>
<li>Web data: the web browsing behaviour of customers, used for showing targeted ads</li>
<li>Text data: emails, documents uploaded, web forms
<ul>
<li>Typically key meanings are extracted and then used downstream for predictions and targeting</li>
</ul></li>
<li>Time and geolocation data: deriving from GPS and WiFi data at the individual or aggregated level
<ul>
<li>Individual level: targeted advertising</li>
<li>Aggregated level: dimensioning and placing infrastrucutres</li>
<li>This type of data raises many privacy concerns</li>
</ul></li>
<li>Smart grids and sensors data: data from cars, windmills, planes, turbines, oil pipes, and other apparati
<ul>
<li>They allow to improve performances and to diagnose problems early</li>
<li>A plane can produce 640 Tb of data per day</li>
</ul></li>
<li>Social network data: analysis of the connections of a given user
<ul>
<li>These data can be used for targeting ads also on the basis of the social circle of the customer</li>
</ul></li>
</ul></li>
<li>The value of data is not in the data themselves but in the value that arises from the combination of different pieces of information</li>
<li>Big data can be an entirely unconventional source of data, like browsing behaviour in online shopping</li>
<li>The speed of data feeds can transform old data in new data, by allowing a more in-depth analysis</li>
<li>Most traditional data sources are structured, while Big Data tend to be unstructured
<ul>
<li>In traditional data every piece of information included is known ahead of time, comes in a specified format and occurs in a specified order</li>
<li>In Big Data there is no control over the source and the format of the data</li>
<li>Web logs are an example of semi-structured data: thelenght of the log is variable but it does follow an underlying logic</li>
</ul></li>
<li>The power of Big Data is in the analysis and the actions that you can take as a result of the analysis
<ul>
<li>The data themselves do not have any intrinsic value, they become valuable only when I am able to extract useful information from them</li>
</ul></li>
<li>The analysis of data can be descriptive, predictive, or prescriptive
<ul>
<li>A descriptive analysis looks at the past and tryes to extrapolate trends</li>
<li>A predictive analysis tryes to use past data to predict future behaviours
<ul>
<li>This is typically harder than a descriptive analysis!</li>
</ul></li>
<li>A prescriptive analysis outputs recommendations according to past data
<ul>
<li>I can get a hint that a machine part is about to break</li>
<li>I can suggest news articles to a customer according to past browsing behaviour</li>
</ul></li>
</ul></li>
<li>All these analysis approaches existed before Big Data, but Big Data improves the ability for precise future insight</li>
<li>Segmentation: specific actors collect focused data
<ul>
<li>Banks can aggregate data on loans, mortgages, credit cards to calculate a credit score</li>
<li>Insurance companies can aggregate health data to predict the likelyhood of of health outcomes</li>
</ul></li>
<li>Churn prediction: a churn is the probability of a current customer to swtich to a competitor
<ul>
<li>A company may flag customers at the risk of churning using web data analytics and social media data</li>
<li>The company may propose targeted offers to avoid churning of those flagged customers</li>
</ul></li>
<li>Recommendation systems: they can be user-scpecific or general
<ul>
<li>User-specific recommendation: Amazon proposes recommended articles to buy, Spotify recommends the next song, and Netflix recommends the next movie</li>
<li>General trends: many platforms suggest products that have been generally sucsessfull</li>
</ul></li>
<li>Sentiment analysis: looking at the general public opinion on a topic or company
<ul>
<li>It typically uses data from social media</li>
<li>It can use aggregate data or individual data</li>
<li>It can use pattern recognition to detect the mood of a calling customer and direct it to the appropriate specialist</li>
</ul></li>
<li>Operational analytics: automate decisions
<ul>
<li>An airline reroutes coustomers automatically upon flight cancellation</li>
</ul></li>
<li>Social good, research, and personalized medicine: remote diagnosis and healt prevention with wearable devices</li>
<li>Big Data is not only related to the commercial applications shown, but also to large-scale scientific experiments
<ul>
<li>The Square Kilometer Assay (SKA) is an international effort to build the word’s largest radio telescope</li>
<li>The LHC produces 60 Pb of data per year</li>
<li>Climate and weather simulations require extensive data</li>
<li>Avionic simulations</li>
<li>Genome sequencing</li>
</ul></li>
</ul>
<h1 id="computational-challenge">Computational challenge</h1>
<ul>
<li>The challenge involves find a substring in a string</li>
<li>Doing it brute force is really slow</li>
<li>I can create an index once and then I can search every time much faster
<ul>
<li>Blast uses this approach</li>
<li>The BWA algorithm is another possibility
<ul>
<li>It is used for more similar sequences</li>
<li>It is faster when I have many reads to be aligned</li>
</ul></li>
</ul></li>
<li>Using the right approach is much more effective than increasing computational power</li>
<li>Read the literature: if you created your own tool, probably it is the wrong one</li>
<li>If possible use open source code</li>
<li>Avoid vendor lockin</li>
<li>Use standards or de facto standards</li>
<li>Think in advance about scalability</li>
<li>A checksum is essential when we are moving data
<ul>
<li>It is a small string used to detect error in data transmission or storage</li>
<li>They are used to verify data integrity, not autenticity</li>
<li>It is possible to set an extended file attribute with the checksum (if the file system allows it)</li>
</ul></li>
<li>Files are moved compressed, moving uncompressed files is a crime</li>
</ul>
<h1 id="from-pc-to-datacenter">From PC to datacenter</h1>
<ul>
<li>1 byte is composed of 8 bits (but we can also use 10 to make it easier)</li>
</ul>
<h2 id="processor">Processor</h2>
<ul>
<li>A Central Processing Unit (CPU) is the electronic circuitry that execute the instructions that make up a computer program</li>
<li>A CPU performs basic arithmeitc, logic, controlling and I/O operations specified by the instructions in a program</li>
<li>A CPU is composed of an Arithmetic Logic Unit (ALU), processor registers and a control unit
<ul>
<li>The ALU performs arithmetic and logic operations</li>
<li>The registers supply operands to the ALU and store the result of ALU operations</li>
<li>The control unit controls the fetching of data from memory and coordinates the operations of ALU, registers and other components</li>
</ul></li>
<li>A multicore processor is an integrated circuit that has at least 2 processing units, called cores
<ul>
<li>Each core appears to the processor as a different CPU</li>
<li>A multicore processor executes ordinary CPU instructions, but multiple instructions can be run at the same time</li>
<li>It increases the overall speed compared to a single core for programs that support parallel computing</li>
<li>A socket is the physical matherboard processor, and it can have many physical and logical cores</li>
</ul></li>
<li>Hyper-threading is a propietary technology from Intel that represents each physical core as 2 logical cores at the software level
<ul>
<li>The OS sees a double number of cores with respect to the physical number actually present</li>
<li>It maximises the exploitation of the processor by running at the same time operations that are independent
<ul>
<li>An example can be doing an ALU operation and a logical operation at the same time</li>
<li>When a process is waiting for something the processor can run another process</li>
</ul></li>
<li>It can improve performances but this depends on the application</li>
<li>It uses more die area (space on the silicon chip)</li>
<li>It can also degrade performance by trashing the cache
<ul>
<li>Memory is virtual in modern systems, in the sense that the address space used by applications does not refer to the physical memory adress</li>
<li>The MMU (memory management unit) translates the virtual adresses to physical adresses on the fly</li>
<li>Virtual memory is the virtual adress space, which can map to physical memory but also to disk</li>
<li>Memory is managed in chunks called pages by the OS</li>
<li>When a page is requested by an application, if its real location is not in memory it raise a page fault error</li>
<li>The OS then swaps the requested page in memory from the swap area of the disk</li>
<li>If there is no space in memory another page is swapped out to disk</li>
<li>If the memory is constantly full this swapping results in a lot of time spent moving data back and forth, degrading performances</li>
</ul></li>
</ul></li>
<li>The <code>top</code> command on a Linux system shows the status of all the logical cores in the system
<ul>
<li><code>wa</code> shows the time spent waiting for I/O</li>
<li><code>load</code> average shows the number of processes waiting for enetering in CPU
<ul>
<li>It should be at most equal to the number of cores, otherwise we are in an overloading</li>
</ul></li>
</ul></li>
<li>A good source of info for the system is <code>cat /proc/cpuinfo</code>
<ul>
<li><code>flags</code> shows the capabilities of the processor (instructions)</li>
</ul></li>
</ul>
<h2 id="memory">Memory</h2>
<ul>
<li>Random Access Memory (RAM) is a device used for storing information for immediate use</li>
<li>When talking about memory, in general we are referring to RAM</li>
<li>RAM typicaly stores working data and machine code</li>
<li>We typically have a memory hierarchy on a PC
<ul>
<li>The first-tier memory is the CPU register</li>
<li>L1, L2 and L3 cache in the processor
<ul>
<li>L1 is subdivided in L1i (instructions) and L1d (data)</li>
<li>L3 is shared among cores (in some cases), while L1 and L2 are core-specific</li>
<li>I have 128 KiB of L1i and 128 KiB of L1d cache, 1 MiB L2 and 8 MiB L3</li>
</ul></li>
<li>Main system memory (RAM)</li>
<li>Swap as a last resort</li>
</ul></li>
<li>Different pieaces of memory have different latencies
<ul>
<li>L1 has a 4 cycles latency, 0.5 ns</li>
<li>L2 11 cycles, 7 ns</li>
<li>L3 39 cycles</li>
<li>RAM 107 cycles, 100 ns</li>
</ul></li>
<li>Because of this latency differences, an <eq env="math">O(n)</eq> algorithm can perform better that a <eq env="math">O(1)</eq> if it cause less memory access event</li>
<li>The memory bandwidth is the rate at which data can be read or stored in a semiconductor memory by a processor
<ul>
<li>It is usually expressed in bytes per second</li>
<li>The total bandwidth is the product of clock frequency, number of transfers per cycle, memory bus width, and number of memory interfaces</li>
<li>Double Data Rate (DDR) RAM pieces can perform 2 transfers per clock cycle</li>
<li>The memory bus has typically a width of 64 bits (also called a line)</li>
<li>Modern PCs have 2 memory interfaces, so they effectively have a 128 bits line width</li>
</ul></li>
<li>Data is transferred between pieces of memory in cache lines
<ul>
<li>A cache line is a data chunk, typically of 64 bits</li>
<li>We can write code that optimizes the use of cache lines by keeping physically close in memory data which is frequently accessed together</li>
</ul></li>
<li>Cache lines operate on 84 GB/s between register and L1, 60 GB/s between L1 and L2, 30 GB/s between L2 and L3 and 10 GB/s between L3 and RAM</li>
<li>A RAM disk is a portion of RAM used as a storage device
<ul>
<li>It is much faster than a conventional disk, but it is not persistent if the RAM is not arranged so to have a standby battery source</li>
</ul></li>
<li>Modern PCs extend RAM capacity by using virtual memory
<ul>
<li>A virtual memory space is a part of an hard disk that it is used as an extension of the physical RAM</li>
<li>It is also called swap space</li>
<li>The data is typically stored in a dynamic paging file on the hard disk</li>
<li>Overuse of swap space can trash performances, since an hard disk is much slower than real RAM</li>
</ul></li>
<li>Registers typically use SRAM, while other caches use SRAM or DRAM and memory use DRAM
<ul>
<li>SRAM is static RAM, it does not need refreshing but it is still volatile
<ul>
<li>It is made with a bistable circuitry called flip-flop</li>
<li>It is more expensive than DRAM since it uses 6 transistors per bit (a flip-flop circuit!)</li>
<li>1 Gb can cost 5000$</li>
</ul></li>
<li>DRAM needs refreshing and it is made with capacitors
<ul>
<li>Each bit is managed by one transistor and one capacitor</li>
<li>The transistor manages read and write operations on its capacitor</li>
<li>1 Gb can cost 50$</li>
<li>SDRAM is a DRAM which operates in sync with the clock</li>
<li>DDR is a type of SDRAM</li>
</ul></li>
</ul></li>
<li>The memory status of a Linux system can be seen with the <code>free</code> command</li>
</ul>
<h2 id="network">Network</h2>
<ul>
<li>A computer network is an infrastructure that shares resources between nodes</li>
<li>Data transmission between nodes is supported over data links consisting of a physical medium</li>
<li>A network node is a network computer device that originates, routes or terminates data communication</li>
<li>Nodes are generally identified by network addresses</li>
<li>Network topology can affect reliability and throughput of a network
<ul>
<li>The more connected a network is, the more reliable, but also the more expensive to build and maintain it is</li>
<li>Bus: everithing connected to the backbone</li>
<li>Star: everithing connected to a centrul node</li>
<li>Ring: each node connected to the ones at its sides</li>
<li>Mesh: each node is connected to an arbitrary number of nodes but guaranteeing that all nodes can be reached</li>
<li>Tree: hyerarchical organization</li>
<li>Fully connected network</li>
</ul></li>
<li>The OSI (open system interconnection) model: a conceptual model that characterizes and standardizes communication in computer systems without regard to its internal structure or technology
<ul>
<li>Layer 1, physiscal layer: concerns the raw bit transmission
<ul>
<li>It codes and decodes bits into the physical transmission protocol (voltage levels, frequencies, …)</li>
<li>The data transmitted is unstructured: it is just bits</li>
</ul></li>
<li>Layer 2, data link: node to node data transfer
<ul>
<li>It catches and corrects errors in layer 1 transmission</li>
<li>It initiates, mantains, and terminates node to node connections</li>
<li>The Medium Access Control (MAC) layes is part of this level
<ul>
<li>It is responsble for controlling how network devices gain access to a medium and to the permission for transmitting data</li>
</ul></li>
<li>The Logical Link Control (LLC) layer catches and corrects errors in layer 1</li>
</ul></li>
<li>Layer 3, network layer: packets of data and transmission across networks
<ul>
<li>It splits the data in packets</li>
<li>It manages the route to an address in the network for data packets to follow</li>
<li>It can provide reliable data transfer, but not necessarily</li>
<li>It may (or not) report on delivery errors</li>
</ul></li>
<li>Layer 4, transport layer: control data reliability
<ul>
<li>It re-transmits damaged packets and ackowledges successfull data transmission</li>
<li>It segments the message from the application layer and de-segments it for the application layer on the receiving end</li>
<li>There are 4 classes of transport protocols from class 0 (fewest features) to class 4 (for unreliable network such as the Internet)</li>
<li>Class 4 transport protocols are close to TCP</li>
</ul></li>
<li>Layer 5, session layer: manages ports and sessions, and maintains connections</li>
<li>Layer 6, presentation layer: it ensures that the data is in a usable format
<ul>
<li>If needed, it performs encryption and decryption</li>
</ul></li>
<li>Layer 7, application layer: human-computer interaction layer, it interacts with applications and with the presentation layer
<ul>
<li>It is the interface that an application uses for interacting with the network</li>
</ul></li>
</ul></li>
<li>OSI is a general networking model and reference framework</li>
<li>The Internet does not strictly follow the OSI model, but it uses the internet protocol suite (TCP/IP)</li>
<li>The TCP/IP model (not the TCP protocol!) is an alternative to OSI
<ul>
<li>It is called TCP/IP because it is based on the TCP protocol and on the IP protocol</li>
<li>It collapses OSI 7 to 5 in the application level and OSI 1 and 2 in the netwrok interface level</li>
</ul></li>
<li>LANs (Local Area Networks) are small and localised networks
<ul>
<li>They are present in houses (made by a router), universities, businesses</li>
<li>They are controlled and managed in-house by the organization that deploys them</li>
<li>They are typically fast and trusted</li>
</ul></li>
<li>WANs (Wide Area Networks) cover cities, nations, and the whole world
<ul>
<li>They are made up of connected LANs</li>
<li>Routing a packet in a WAN means finding to which LAN it should go</li>
<li>The Advanced Research Projects Agency Network (ARPANET, US defense) was the first WAN and the first network to implement TCP/IP</li>
</ul></li>
<li>The LHCone network is the WAN of the LHC, that connects LHC tier 1, 2, and 3 sites</li>
<li>Computer communication links that do not support data packets work by transmitting bit streams</li>
<li>The wast majority of computer networks transfers data in packets
<ul>
<li>A packet is a formatted unit of data</li>
<li>It is a list of bits, a few 10 byets to some kylobytes long, carried by a packed switched network</li>
<li>A message that does not fit in a packet is divided in multiple packets and then re-assembled at the destination</li>
</ul></li>
<li>A packet is composed of a payload and control information
<ul>
<li>The payload is the actual data that needs to be transmitted trough the network</li>
<li>The control information provides the data that the network needs for correct shipment of the packet: source, destination, error detection code, sequencing information</li>
<li>Increasing the payload proportion in a packet increases the transmission speed at the cost of accuracy</li>
</ul></li>
<li>The MTU (maximum transmission unit) is the size of the largest protocol data unit (PDU) that can be transmitted in a single network layer transaction
<ul>
<li>It is related (but not equal, there is control information!) to the maximum frame size that can be transported by the data link layer</li>
<li>A larger MTU is related to a reduced overhead while a smaller MTU can reduce network delay</li>
<li>It should be set so to respect the properties of the physical network and not exceed its capabilities</li>
</ul></li>
<li>The MAC (Media Access Control) address is a unique ID assigned to a NIC (Network Interface Controller) for use as a network address in a given network segment
<ul>
<li>It is used in most of the IEEE802 technologies such as Ethernet, WiFi, Bluetooth</li>
<li>It is at the medium access control protocol sublayer of the data link layer (OSI layer 2)</li>
<li>A MAC address is composed of 6 groups of 2 hexadecimal digits separated by hyphens, colons, or without a separator</li>
<li>It is assigned primarily by the device manufacturer and physically stored in a read-only memory or in the firmware of the device (burned-in address)</li>
</ul></li>
<li>The IP (internet protocol) address is a numerical label assigned to each device connected to a computer network that uses the Internet Protocol for communication
<ul>
<li>It serves as an identifier of an host on a network and for the routing of packets</li>
<li>IPv4 defines an IP address as a 32 bit number</li>
<li>To make the IP address more human-readable, each byte is usually represented with a decimal number from 0 to 255 (<eq env="math">2^8 = 256</eq> possible states of a byte)</li>
</ul></li>
<li>The IP is subdivided into a network prefix (subnet) and a rest field (host identifier)
<ul>
<li>The network prefix is represented by a variable number of higer-order bits</li>
<li>How many bits belong to the network prefix can be specified using the CIDR notation or a subnet mask</li>
<li>The CIDR notation is represented with a slash after the IP address that specifies the number of bits to be used for the subnet
<ul>
<li><code>192.168.1.1/24</code> means that the first 24 bits of the 32 total (the first 3 of 4 bytes, <code>192.168.1</code>) are the subnet, while <code>1</code> is the rest field</li>
</ul></li>
<li>A subnet mask is used in a logic AND operation against the IP address for obtaining the subnet, and in a NAND operation for obtaining the rest field
<ul>
<li>A subnet mask of <code>255.255.255.0</code> means that the first 3 bytes belong to the subnet while the last byte forms the rest field</li>
</ul></li>
</ul></li>
<li>The early design of the IP envisioned global end-to-end connectivity among all the Internet hosts
<ul>
<li>This required all the addresses to be globally unique</li>
</ul></li>
<li>Subsequently, with the development of private networks, it was realised that private addresses for each device needed to be unique only inside the LAN, while maintaining a gloablly unique public address for the LAN router
<ul>
<li>Computer that are not directly connected to the Internet use a NAT (Network Address Translation) service that translates their private IP to/from the public IP of the router</li>
</ul></li>
<li>There are 3 non-overlapping address ranges reserved for private use
<ul>
<li>24 bit block: CIDR 10.0.0.0/8
<ul>
<li>The first byte (10) is the subnet, while the 3 following bytes compose the host identifier</li>
</ul></li>
<li>20 bit block: CIDR 172.16.0.0/12
<ul>
<li>The first byte and part of the second form the subnet (172.16 to 172.31)</li>
</ul></li>
<li>16 bit block: CIDR 192.168.0.0/16
<ul>
<li>The first 2 bytes (192.168) form the subnet, while the 2 following bytes compose the host identifier</li>
</ul></li>
<li>8 bit block: CIDR 192.168.0.0/24</li>
</ul></li>
<li>In the version 6 of the Internet protocol (IPv6) the address space was increased to 128 bits
<ul>
<li>The address space is not the only difference between IPv4 and IPv6, they are much different in terms of routing</li>
<li>The magnitude of the IPv6 address space is deemed sufficient for the foreseeable future</li>
<li>Its size allows to reserve large address blocks for specific use and to aggregate addresses for more efficient routing</li>
<li>A unique local address (ULA) in IPv6 is reserved for local use and corresponds to fc00::/7
<ul>
<li>It is the equivalent of a private IPv4 address</li>
<li>An address in this range can be used without registration in the scope of a private network</li>
</ul></li>
</ul></li>
<li><code>ifconfig</code> can be used to configure and inspect the network interface on a Linux system</li>
<li>The loopback network device: a connection to the same machine
<ul>
<li>It is entirely managed via software by the OS and does not send any packet to network devices</li>
<li>It is assigned to the block 127.0.0.0/8 in IPv4</li>
<li>In practice it is used almost always only the address 127.0.0.1</li>
<li><code>localhost</code> is mapped to 127.0.0.1 in most computers</li>
<li>It is used for diagnostic and by applications to reach resources on the same machine (e.g. by Jupyter to show its interface)</li>
</ul></li>
<li>DNS is a hierarchical and decentralised mapping system between IP addresses and mnemonic names</li>
<li>A communication protocol is a set of rules for exchanging data over a network
<ul>
<li>In a protocol stack each protocol uses services from the one below it</li>
<li>A protocol stack is HTTP running over TCP which runs over IP, which uses a IEEE802 protocol (Ethernet, WiFi)</li>
</ul></li>
<li>IEEE802 is a family of IEEE (Institute of Electrical and Electronic Engeneers) standards dealing with LANs and metropolitan area networks
<ul>
<li>Ethernet (also called LAN) is a family of protocols used in wired LANs, described by a set of standards called IEEE 802.3</li>
<li>Wireless LAN (also called WLAN or WiFi) is another protocol standardized by IEEE 802.11 that shares many properties with the wired Ethernet protocol</li>
</ul></li>
<li>Network bandwidth can refer to different concepts
<ul>
<li>The channel bandwith refers to the gross transfer rate of the payload and also of the overhead control information</li>
<li>The goodput is the actual rate of payload transfer</li>
</ul></li>
<li>Latency is measured as end-to-end delay (OWD) or round-trip-time (RTT)
<ul>
<li>The OWD is the time that a packet takes to travel from source to destination</li>
<li>The RTT is the time that a packet takes to travel from the source to the destination and back to the source</li>
<li>The RTT is usually twice the OWD, but not necessarily (upload and download latencies can difffer)</li>
<li>The RTT can be assessed with the <code>ping</code> command on a Linux system</li>
<li>Latency can never be smaller than what the speed of light requires!</li>
</ul></li>
<li>Network adapters are physical devices that connect a computer to a network
<ul>
<li>They can be part of the motherboard or can be plugged in as expansion cards</li>
<li>They implement the OSI layers 1 and 2</li>
<li>Netwrok adapters are Ethernet adapters, WiFi adapters, Fiber Channel adapters
<ul>
<li>Typical latencies are around 50-125 <eq env="math">\mu</eq>s</li>
<li>Ethernet can reach a bandwidth of 10 Gbit/s</li>
</ul></li>
<li>There are also high-performace adapters used for high-performance computing like Omnipath (Melanox) and Infiniband (Intel)
<ul>
<li>They provide high bandwidth and really low latency network interfaces</li>
<li>Typical latencies are less than 5 <eq env="math">\mu</eq>s</li>
<li>They can reach a bandwidth of 100 Gbit/s</li>
</ul></li>
</ul></li>
<li>A hub is a network device that broadcast the same packet to all the devices connected to it
<ul>
<li>It is used for connecting segments of LAN</li>
</ul></li>
<li>A switch is a network device that statically delivers a packet to a specific machine
<ul>
<li>It knows the MAC of all the devices attached to it and can identify which machine sits at which of its ports</li>
<li>It works at OSI layer 2 (and in some cases also at OSI layer 3)</li>
<li>It does not increase significantly network response times since it knows to which port each packet should be sent to</li>
</ul></li>
<li>A router is a network device that delivers a packet to an IP address
<ul>
<li>It works at OSI layer 3</li>
<li>It can sit between 2 LANs, between a LAN and a WAN, or between a LAN and the network of an ISP</li>
</ul></li>
<li>Top-of-the-rack switching: a switch that delievers packets to a rack of servers and sits on the top of a server rack
<ul>
<li>Usually there are also aggregation switches that deliver packets to the right top-of-the-rack switch</li>
</ul></li>
<li>Some useful network commands (from the <code>bind-utils</code> package)
<ul>
<li><code>ping</code>: test connectivity and latency</li>
<li><code>traceroute</code> or <code>tracepath</code>: check the path to a server and the segment latencies</li>
<li><code>ifconfig</code> or <code>ip addr show</code>: inspect the configuration of the network devices</li>
<li><code>ethtool</code>: for the configuration and diagnosis of network interface controllers</li>
<li><code>netstat</code>: statistics on the connections available</li>
<li><code>host</code>: get information on a host (form its IP or name)</li>
<li><code>dig</code>: lookup a name</li>
<li><code>whois</code>: pulls information on an address from IANA (Internet Assigned Numbers Authority)</li>
</ul></li>
</ul>
<h2 id="computing-infrastructures">Computing Infrastructures</h2>
<ul>
<li>A computing farm is a collection of servers and it can have millions of cores
<ul>
<li>Network devices manage communication among servers and the interactions with users</li>
<li>The Intel Xeon CPU is often used in datacenters since it is reliable and can work continuously</li>
<li>The link between sockets in the same motherboard is called qlink</li>
<li>Servers are organised in hot islands which are separated by a cooling system</li>
</ul></li>
<li>In a datacenter typically multiple users share the same resources
<ul>
<li>It is important to organize resource usage so to avoid wasting computing power</li>
<li>Different users could have paid for different a Quality of Service (QoS)</li>
<li>Different users can have different priorities</li>
</ul></li>
<li>A batch system (or scheduler) manages the concurrent access to resources, respecting priorities and usage shares as much as possible
<ul>
<li>It is an application that controls the inattended (batch) execution of jobs (task to be executed)</li>
<li>There are many batch schedulers: HTCondor, OpenLava, LSF, …</li>
<li>A batch system takes care of scheduling non-interactive jobs and manages resource access</li>
<li>It provides a single point of control for jobs submitted to the CPU farm</li>
<li>It dynamically allocates jobs so to maximise cluster use, minimise latency and respect fairshare on a time window
<ul>
<li>A computing farm is usually shared among paying customers</li>
</ul></li>
<li>Jobs are often organised in queues</li>
</ul></li>
<li>A single job is batch instruction that occupies a single slot and it is executed in a single core</li>
<li>A DAG workfolow is a series of jobs dependent from each other described by a directed acyclic graph
<ul>
<li>It is essentially a pipeline</li>
<li>The output of a job is the input of another</li>
</ul></li>
<li>A collection is a group of jobs that can be run in parallel
<ul>
<li>They typically act on different input data</li>
</ul></li>
<li>A parallel job is a job that needs to run in more than 1 core</li>
<li>A parametric job is a collection that can be easily defined by a parameter</li>
<li>Fair share scheduling: each user should obtain its fair share of resources, depending on the QoS he paid for
<ul>
<li>Normally jobs are dispatched with a FIFO behaviour (first come first served, FCFS)</li>
<li>With fair share scheduling, the load is redistributed across queues so that no queue becomes starved and no user can monopolise resources</li>
<li>Fair share does not mean necessarily equal share, customers could have paid for different QoS levels!</li>
</ul></li>
<li>Reservation: the batch scheduler can reserve cores for 1 job that is waiting for something to be executed
<ul>
<li>This is typical of parallel jobs that are waiting for enough cores to be available</li>
</ul></li>
<li>Backfill: while the reserved cores are idle they can be used by other jobs whose duration does not exceed the starting time of the job that reserved the cores
<ul>
<li>Only jobs that will finish before the job that reserved the cores will start are permitted</li>
<li>For backfill to be possible, the user must declare the duration of his jobs!</li>
<li>After the pre-determined time expires, the job is killed by the scheduler</li>
</ul></li>
<li>Main messagges
<ul>
<li>Concurrency in a datacenter is handled by a batch system</li>
<li>Jobs are typically unattended</li>
<li>Fairshare uses a dynamic priority to ensure the respect of the agreed usage quotas</li>
<li>Dynamic priorities depend on a large number of factors</li>
<li>The batch scheduler minimizes the waiting time for customers and maximizes cluster utilization</li>
</ul></li>
<li>Jobs are composed of
<ul>
<li>Job type</li>
<li>Prologue: initial checks to be performed</li>
<li>Input sandbox: the list of needed files for the job</li>
<li>Requirements: the hardware required for the job</li>
<li>Executable: the actual application to run</li>
<li>Where the stdout and stderr of the application should be directed</li>
<li>Output sandbox: the files that will be produced by the application</li>
<li>Epilogue: final cleanup, file uploads, updates, …</li>
<li>Error recovery: what to do if the job fails</li>
</ul></li>
</ul>
<h2 id="storage">Storage</h2>
<ul>
<li>Storage devices are Hard Disks (HDDs), Solide State Disks (SSDs), tape, Non-Volatile Memory (NVM)</li>
<li>The performance of a storage device is described in terms of storage capacity, bandwith and Input/Output Operations Per Second (IOPS)
<ul>
<li>The bandwith is the read and write speed for sequential data on the drive</li>
<li>The IOPS is the number of I/O operations per second that can be requested
<ul>
<li>It is important when operating on small files</li>
</ul></li>
</ul></li>
<li>An SSDs use NAND technology, it is much slower than RAM but non-volatile
<ul>
<li>It can withstand a limited number of write cycles</li>
<li>NAND SSDs use NAND logical gates</li>
<li>The NAND used in USB drives tend to be less performant, cheaper and less durable than the one used in SSDs</li>
<li>Bandwidth is of 400/500 MB/s, 100k/400k IOPS, capacity of 500 Gb</li>
<li>The biggest advantage of an SSD is in terms of IOP</li>
</ul></li>
<li>Hard disks are slow since they have mechanical moving parts
<ul>
<li>They have spinning disks and a moving head</li>
<li>Speed is 100/150 Mb, 100/200 IOPS, capacity 8 Tb</li>
</ul></li>
<li>Tape storage is expensive since it requires a special infrastructure (a tape library) but it is really scalable
<ul>
<li>Speed is 250 MB/s, sequential access (no IOPS definable), capacity 8.5 Tb</li>
</ul></li>
<li>Data maintainance is a huge responsibility, since it could be impossible to re-obtain lost data</li>
<li>RAID (Redundant Array of Independent Disks) systems allow to virtualize data storage devices
<ul>
<li>The purpose of a RAID system is to increase data redundancy, imporve performances, or both</li>
<li>The RAID level can be considered as a type of QoS</li>
</ul></li>
<li>RAID0: file stripping at the block level
<ul>
<li>A single file is stripped into several drives</li>
<li>I aggregate <eq env="math">n</eq> physical disks into 1 virtual disk</li>
<li>I get higher performances but no redundancy</li>
<li>Losing only 1 disk means losing all the data: there is no redundancy</li>
<li>The transfer rate is up to <eq env="math">n</eq> times higher than whoat it would be on a single disk
<ul>
<li>The transfer rate is maximal when the file to read or write is equally divided among the disks</li>
</ul></li>
<li>The total virtual storage size is <eq env="math">n</eq> times the size of the smallest disk</li>
</ul></li>
<li>RAID1: file mirroring
<ul>
<li>Performances can imporove for reading operations, while they remain at the level of single disks for writing
<ul>
<li>I can access different locations of the same file at the same time from different disks</li>
</ul></li>
<li>An example is 2 disk that operate as 1, mirroring their contents</li>
<li>The redundancy level is always <eq env="math">n-1</eq></li>
<li>The storage space is equal to the capacity of the smallest disk</li>
</ul></li>
<li>RAID2 is rarely used and involves stripping at the bit level
<ul>
<li>It uses an Hamming code for error correction</li>
</ul></li>
<li>RAID3 is rarely used and involces stripping at the byte level with a parity disk
<ul>
<li>A parity disk contains parity bits for each block, that are used in error correction</li>
<li>It requires the rotation of all the disks to be in sync!</li>
</ul></li>
<li>RAID4: block-level stripping with parity disk
<ul>
<li>It is similar to RAID0 but it also has a parity disk</li>
</ul></li>
<li>RAID5: block-level stripping with distributed parity
<ul>
<li>It is similar to RAID0 but it uses parity blocks, distributed among all the disks</li>
<li>It requires at least 3 disks, since a full disk capacity is used for the parity blocks (but distributed across all the disks!)</li>
<li>It is more reliable of RAID0 because of parity, but also less performant</li>
<li>It is tolerant to the loss of an entire disk from the array
<ul>
<li>Its data can be reconstructed from the parity blocks</li>
</ul></li>
</ul></li>
<li>RAID6: block-level stripping with double distributed parity
<ul>
<li>It is similar to RAID5 but it uses 2 parity blocks instead of 1</li>
<li>It requires a minimum of 4 disks</li>
<li>It can tolarete the concomitant failure of 2 disks</li>
</ul></li>
<li>A file system controls how data is stored and retrieved
<ul>
<li>It manages the space on the drive, keeping track of which physical locations contain which files</li>
<li>It uses filenames as a reference to specific physical locations</li>
<li>It uses directories to group files into separate collections</li>
<li>The allocation of space on a drive can be implemented with an index table, or with an inode (index node, typical of Unix-like systems)</li>
<li>It can or not suppor file metadata like owner, permissions, access times, dimension of the file, creation time, edit time</li>
</ul></li>
<li>The POSIX (Portable Operating System Interface) is a family of standards defined by IEEE for maintaining compatibility between operating systems
<ul>
<li>POSIX defines the API, as well as command line shells and utility interfaces</li>
<li>POSIX is defined in the standard IEEE 1003 and in ISO/IEC 9945</li>
<li>It also define the characteristics of a POSIX file system</li>
<li>Most Linux file systems are POSIX-compliant (ext3, ext4, zfs, xfs)</li>
<li>A POSIX filesystem basically is a file system that supports file-open operations</li>
</ul></li>
<li>A Direct Access Storage (DAS) system is a digital storage device directly attached to the computer accessing it
<ul>
<li>It does not incorporate any network capability, but it can be exposed to a network by the computer accessing it</li>
<li>A DAS is connected to an host trough a Host Bus Adapter (HBA)</li>
<li>Cables are important, especially for DAS systems
<ul>
<li>The main protocols used are ATA, SATA, NVMe, SCSI, SAS, USB, and fiber channel</li>
</ul></li>
</ul></li>
<li>A JBOD (Just a Bunch Of Disks) is a container containing disks that can be plugged into a server</li>
<li>A NAS (Network Access Storage) is a file-level storage server exposed to a network
<ul>
<li>It provides file level access for external clients</li>
<li>It is usually represented by a purpose-built computer that hosts a collection of storage devices, often in a redundat or RAID arrangement</li>
<li>It uses file sharing protocols like NFS and SAMBA</li>
<li>A NAS removes the file-sharing responsibility from other computers on the network</li>
</ul></li>
<li>A storage area network (SAN) is a dedicated network that provides storage access at the block level
<ul>
<li>With a SAN I am not exposing the file system, but the disk itself</li>
<li>The connections are made by Fibre Channel, iSCSI, or Infiniband</li>
<li>A SAN is composed of a series of storage and network devices, that can be dedicated or not</li>
<li>A file system can be created on top of a SAN to provide file-level access</li>
</ul></li>
<li>A SAN is composed of an host layer, a fabric layer and a storage layer
<ul>
<li>The host layer is composed of servers that allow access to the SAN and storage devices
<ul>
<li>The communication between the host layer and the storage devices happens trough HBAs (usually cables)
<ul>
<li>A GigaBit Interface Converter (GBIC) is used to convert ligth to digital signals</li>
</ul></li>
</ul></li>
<li>The fabric layer is composed of the SAN networking devices
<ul>
<li>It includes cables, routers, gateways, switches</li>
<li>Network devices move data within the SAN and between an initiator (HBA port of a server) and a target (the port of a storage device)</li>
<li>SAN networks are typically redundant, so SAN switches tend to be connected by redundant links</li>
</ul></li>
<li>The storage layer is composed of the storage devices
<ul>
<li>HDDs are usually connected in JBODs and organised in RAID systems</li>
<li>Tape devices are arranged in libraries</li>
<li>Every partition of every storage device is identified by a logic unit number (LUN) in the SAN</li>
<li>The LUN allows to restrict access to data in the SAN and to segment the storage space</li>
</ul></li>
</ul></li>
<li>Important data need to be backed up frequently and possibly moved to a different geographical location</li>
<li>A parallel filesystem is a single filesystem across multiple networked servers
<ul>
<li>It facilitates high-performance access thanks to the use of coordinated I/O operations between clients and storage nodes</li>
<li>It usually supports a high mutliplicity of clients (thousands of them!)</li>
<li>It is built on a SAN, with block level access</li>
<li>Files are striped across multiple local and remote storage devices</li>
<li>The user of a parallel file system is not required to know the block location of files to access them</li>
<li>The system uses a global namespace</li>
<li>It maintains metadata servers with information about the location of the blocks for each file and their metadata</li>
<li>Metadata in a parallel file system are essential and cannot be lost: metadata servers have a lot of redundancy</li>
<li>Capacity and bandwidth can be scaled depending on the requirements</li>
<li>Parallel file systems are typical of high performance computing environments</li>
<li>They are designed for performance and highly concurrent access</li>
<li>Examples of parallel file systems are LUSTRE and IBM Spectrum Scale (General Parallel File System, GPFS)</li>
</ul></li>
<li>A distibuted file system is built on a system with file-level access
<ul>
<li>It does not provide block-level access to clients</li>
<li>It creates a unique global namespace for distributed file</li>
<li>Files on a distributed file system can be accessed with the same semantics used for local files</li>
<li>A distributed file system is built on top of the file systems of the disks on the various servers!</li>
<li>They are typically slower than parallel file systems</li>
<li>Examples of distributed file systems are HDFS, BeeGFS, GFS, …</li>
</ul></li>
<li>Note: the distinction among parallel and distributed file systems is not binary, and some file systems present characteristics of both</li>
<li>The tape area network (TAN) is a subsection of a SAN dedicated to tape devices
<ul>
<li>It is composed of the interconnections among servers, libraries and tape devices</li>
<li>Tapes are organized in libraries containing tape drives and robotic arms that move the tape cartridges into the drives</li>
<li>A tape library can have a 85 Pb capacity and frequently has a disk buffer for performing read and write operations on tapes</li>
<li>At CNAF 80 Pb of tape storage are used for RAW scientific data and for backing up server configurations, logs, and repositories</li>
</ul></li>
<li>Tiered storage is a data storage environment organised in tiers according to the QoS of its different storage devices
<ul>
<li>Tiers differ for storage price, performance, capacity, and/or function</li>
<li>Tier 1 storage is used for hot data (frequently used data)
<ul>
<li>It is composed of large RAID systems and SSDs</li>
</ul></li>
<li>Tier 2 is used for warm data
<ul>
<li>It is mainly old disks and small RAIDs</li>
</ul></li>
<li>Tier 3 is used for cold data like backups and rarely accessed data
<ul>
<li>It is mainly tape storage</li>
</ul></li>
</ul></li>
<li>Moving a file to an higher QoS tier is called a recall, while moving it to a lower tier is called a migration</li>
<li>A storage device that declares a certain QoS ensures that a particular application always can benefit of a certain minimum performance level
<ul>
<li>For storage devices, QoS is often expressed in terms of IOPS</li>
<li>Nowadays many storage systems claim to offer some form of QoS</li>
</ul></li>
<li>IBM Spectrum Protect (formerly TSM, Tivoli Storage Manager) is proprietary software from IBM which is leader in data protection solutions
<ul>
<li>It is used mostly for backup and archive purposes</li>
<li>It offers a Hierarchical Storage Management (HSM) extension to manage migrations and recalls between disk and tape storage of data hosted on a Spectrum Scale file system</li>
<li>The mean daily transfer rate for each server is of 600-650 Mb/s</li>
</ul></li>
<li>Tape is becoming popular again since the amount of data to be stored increases exponentially while HDD capacity has stagnated
<ul>
<li>80% of the newly created data is cold data, which is not accessed in at least 3 months: it is ideal for tape storage</li>
<li>Tape storage is energy efficient: no power needed when not in use</li>
<li>Tape storage is extremely safe: I can put the cartridge in a safe box and it is inaccesible for everyone</li>
<li>Tape devices are expected to last for more than 30 years and are very reliable
<ul>
<li>Data can often be recovered also in case of drive failure</li>
<li>The data is verified by a read-while-write system</li>
</ul></li>
<li>Tape storage is extremely safe: I can put the cartridge in a safe box and it is inaccesible for everyone</li>
<li>The main advantage: tape is really cheap</li>
</ul></li>
<li>A Storage Remote Access Service is a service that grants remote access to file system
<ul>
<li>It implements operations like list, copy, delete, migrate, recall</li>
<li>It should be possibly based on a standard or de-facto standard</li>
<li>It provides various types of auth/authZ mechanisms such as username and password, tokens, and digital certificates</li>
</ul></li>
<li>Data transfer applications can implement asynchronous data movement or data streaming
<ul>
<li>Asynchronous data movement applications are <code>scp</code>, <code>rsync</code>, <code>ftp</code></li>
<li>Streaming applications are Flume and Kafka</li>
</ul></li>
<li>GridFTP is an extension of the File Transfer Protocol (FTP) used for distrubuted computing
<ul>
<li>Provides a reliable and high-performance transfer of large files</li>
<li>It is extensively used at LHC</li>
<li>It can use multiple concurrent TCP streams</li>
<li>It allows the transmission of partial files</li>
</ul></li>
<li>Main messages
<ul>
<li>DAS is a devicde directly connected to a server</li>
<li>NAS provides file level access to storage devices through a network</li>
<li>SAN is a dedicated network infrastructure that provides access at the block level</li>
<li>Parallel and distributed file system manage highly concurrent access to data over multiple servers</li>
<li>A datacenter can provide storage resources with different QoS</li>
</ul></li>
</ul>
<h2 id="data-center-management-for-big-data">Data center management for Big Data</h2>
<ul>
<li>HyperConverged architecture: use of general-purpose low-cost hardware instead of dedicated systems
<ul>
<li>It is becoming increasingly popular</li>
<li>Storage and computing happen on the same consumer-level machines, not on separate and dedicated areas of a server farm</li>
<li>It is suitable for Big Data and MapReduce applications</li>
<li>It is easily scalable</li>
</ul></li>
<li>Provisioning: the deployment of thousands of servers in a datacenter can be facilitated by automated tools for installation and configuration
<ul>
<li>Foreman is an application that manages the lifecycle of servers (physical or virtual)
<ul>
<li>It is open source, accessible from a web interface, an API, or the command line</li>
<li>It allows to define the OS to be installed, the installation medium, files to be executed</li>
<li>If integrated with Puppet it acts as an external node classifier</li>
</ul></li>
<li>Puppet is an application for the automatic deployment and configuration of servers
<ul>
<li>It is open source and works through modules written in a declarative language (many contributed modules are available)</li>
<li>It is composed of a Puppet master and a Puppet agent</li>
<li>The Puppet master knows how the nodes should be configured and compares their actual configuration with the desired one</li>
<li>The Puppet agent sends to the master the actual configuration of nodes and executes the proper actions to apply the desired configuration</li>
</ul></li>
</ul></li>
<li>Monitoring and alarming: monitor the operations of the datacenter and report anomalies
<ul>
<li>Monitoring data is typically accessed from a web interface or with a reporting tool</li>
<li>An alarming system notifies administrators in case of anomalies
<ul>
<li>An anomaly can be a server crash, or the passing of a threshold (disk usage, memory, CPU)</li>
<li>It can hanlde specific events, for instance restart a service in case of a crash</li>
</ul></li>
</ul></li>
<li>The fast-performing interconnections of a motherboard form the northbridge, which connects CPU, memory, and PCIe devices</li>
<li>The slow-performing interconnections of a motherboard form the southbridge, which connects the northbridge with PCI, USB, SATA, IDE, BIOS, and legacy devices</li>
</ul>
<h2 id="power-and-cooling">Power and cooling</h2>
<ul>
<li>The power infrastructure of a datacenter provides electricity to all the components of the farm</li>
<li>It can emply Uninterruptable Power Supplyes (UPSs), a system that prevents failure in case of electrical cuts
<ul>
<li>It can be based on batteries, inertial systems, engines, or some combination of these elements</li>
</ul></li>
<li>The cooling system of a datacenter can include free cooling, forced air flow, liquid submersion, liquid cooling, heat pipes, and many other systems
<ul>
<li>Liquid submersion uses non-electrically conductive liquids such as oils</li>
</ul></li>
<li>The Power Usage Effectiveness (PUE) of a datacenter is the ratio among the energy used for computing and the energy used for overheads like cooling
<ul>
<li>Its ideal value is 1.0: all the energy is used for IT systems and not for overheads</li>
<li>The PUE is the inverse of the DataCenter Infrastructure Efficiency (DCIE)</li>
<li>In 2008 Google had a PUE of 1.21 across 6 of its centers</li>
</ul></li>
</ul>
<h1 id="hadoop-and-mapreduce">Hadoop and MapReduce</h1>
<ul>
<li>To work with Big Data, you need an infrastructure which is capable of working with a huge volume of unstructured or semistructured data in real time
<ul>
<li>Typically this infrastructure is the cloud</li>
</ul></li>
<li>There are 2 main ways of dealing with Big Data
<ul>
<li>Storing data on non-relational databases like MongoDB (a NoSQL database): this requires little coding skills</li>
<li>Storing data on massively parallel database systems and using MapReduce applications: typically requires a specialised data scientist</li>
</ul></li>
<li>The Big Data software ecosystem is too damn big</li>
<li>MapReduce is an algorithm developped by Google for parallel and decentralized processing and generation of big data
<ul>
<li>It does not rely on a centralised database and it usually uses a distributed filesystem like HDFS</li>
<li>It is based on the Map and Reduce actions
<ul>
<li>Map: convert a set of data into another, described by key/value tuples
<ul>
<li>I can take a document and form a dictionary with single words as keys and their count in the document as value</li>
</ul></li>
<li>Reduce: aggregate the data from a set of tuples
<ul>
<li>I take several dictionaries from different documents and count the total word occurrence</li>
</ul></li>
</ul></li>
</ul></li>
<li>Apache Hadoop is an open-source software ecosystem for big data analysis and storage
<ul>
<li>It is designed to scale well from a single server to thousands of servers</li>
<li>It is highly fault tolerant</li>
<li>It is typically run on low-grade hardware, but it is highly reliable because of the software-level failure handling routines</li>
<li>New nodes can be added quickly without changing configurations</li>
<li>It does not require any schema, it can accept any kind of data</li>
<li>When a node fails the system just redirects the load on the remaining nodes, without halting</li>
</ul></li>
<li>Hadoop is composed of
<ul>
<li>Hadoop Common: a series of common utilities that support the other modules</li>
<li>Hadoop Distributed File System (HDFS)</li>
<li>Hadoop YARN: framework for job scheduling and resource management</li>
<li>Hadoop MapReduce: a YARN-based system for parallel processing based on the MapReduce approach</li>
<li>Hadoop Ozone: an object storage service</li>
<li>Hadoop Submarine: a machine learning engine</li>
</ul></li>
<li>The Hadoop Distributed File System (HDFS) is the core component of the Hadoop ecosystem
<ul>
<li>It creates a level of abstraction above the resources</li>
<li>It allows to see the whole HDFS as a single unit</li>
<li>It stores data in the various nodes and mantains a log of the stored data</li>
<li>It is composed of 2 core components: NameNode and DataNode</li>
<li>The NameNode is the metadata server
<ul>
<li>It does not store the actual data</li>
<li>It has high computational requirements but low storage requirements</li>
</ul></li>
<li>The DataNodes actually store the data
<ul>
<li>They can be represented by commodity hardware</li>
<li>They tend to be storage-specialised systems</li>
</ul></li>
<li>There is typically only 1 NameNode and many DataNode in an Hadoop cluster</li>
</ul></li>
<li>Writing in an Hadoop cluster requires 2 essential pieces of information to be submitted with the data: block size and replication (number of copies of the block that I want to be stored in the Hadoop cluster)
<ul>
<li>Typically a block size of 64 or 128 Mb and a replication of 3 are used</li>
<li>The client sends the request to the NameNode, which returns a sorted list of DataNodes in order of distance from the client</li>
<li>The client sends the data only to the first DataNode</li>
<li>The first DataNode sends to the second and so on for the desired replication level</li>
<li>All the DataNode send a confirmation for finished writing to the NameNode</li>
<li>When all the blocks have been written the NameNode stores the file metadata</li>
<li>The NameNode returns a success message to the client</li>
</ul></li>
<li>Reading data from an Hadoop cluster
<ul>
<li>The client request a file to the NameNode</li>
<li>The NameNode returns a list of blocks and of DataNodes having them</li>
<li>The client retrieves the blocks from the respective DataNodes</li>
</ul></li>
<li>Node failure in Hadoop is handled by the NameNode
<ul>
<li>The DataNodes every 3 seconds send a HEARTBEAT message to the NameNode, signaling their presence</li>
<li>If the NameNode does not receive the HEARTBEAT from a DataNode in 10 minutes (because it is dead or there is a network failure) it considers it dead</li>
</ul></li>
<li>Network failure handling in Hadoop
<ul>
<li>Whenever data is sent the receiver returns an ACK (acknowledge) message</li>
<li>If the ACK message is not received after several trials the sender assumes the receiver to be dead</li>
</ul></li>
<li>Corrupted data in Hadoop
<ul>
<li>Data always include a checksum when it is sent and when it is stored</li>
<li>DataNodes periodically send a BLOCKREPORT to the NameNode, a list of all the blocks in the node
<ul>
<li>Before sending the BLOCKREPORT a DataNode checks all the block checksums</li>
<li>If a block is corrupted it is not sent to the NameNode</li>
<li>The blocks that the NameNode knows to be stored in a specific DataNode but that are not included in the BLOCKREPORT of that DataNode are assumed to be corrupted</li>
</ul></li>
</ul></li>
<li>The NameNode always mantains 2 essential tables: a list of blocks and a list of DataNodes</li>
<li>When a DataNode is dead or assumed dead, it is skept for all transactions both by client and NameNode
<ul>
<li>If it is so the data will not reach the desired replication, but the NameNode will subsequently instruct the DataNodes to copy data from each other accordingly</li>
</ul></li>
<li>In order to be as resilient as possible, block replicas are kept at most as 1 per server and 2 per server rack, if possible
<ul>
<li>It is also possible to specify a custom placemnt algorithm</li>
</ul></li>
<li>YARN allocates resources and schedules jobs in the Hadoop cluster
<ul>
<li>It is composed of 2 major components: ResourceManager and NodeManager</li>
<li>The ResourceManager is the central node of the cluster
<ul>
<li>It receives requests and dispatches them to the relevant NodeManagers</li>
</ul></li>
<li>The NodeManagers are installed onto each DataNode and manages task execution of that node</li>
<li>ApplicationManagers accept job submission and forwards them to the respective ApplicationMaster on the DataNode</li>
</ul></li>
<li>Hadoop MapReduce is the core processing component of the ecosystem
<ul>
<li>It is a software framework for writing applications that process large datasets using distributed and parallel algorithms in an Hadoop environment</li>
</ul></li>
<li>SQL is a relational DBMS based on tables
<ul>
<li>It works with a specific schema</li>
<li>It uses the powerfull SQL query language</li>
<li>Implementations are MySQL, Oracle, Sqlite, Postgres</li>
<li>It is typically commercially supported</li>
<li>It focuses mostly on consistency: typical application is the database of a bank
<ul>
<li>We can say that it focuses on the ACID properties: atomicity, consistency, isolation, durability</li>
</ul></li>
<li>Scalability is vertical</li>
</ul></li>
<li>NoSQL is a non-relational and document-based DBMS
<ul>
<li>It can consist in key-value pairs, graphs, wide-columns</li>
<li>The schema is flexible and it can also host unstructured data</li>
<li>Scalability is horizontal: I can just increase the number of servers in the pool</li>
<li>It uses the non-standard UnQL query language (unstructured query)</li>
<li>Implementations are MongoDB, Cassandra</li>
<li>It is typically supported by the community</li>
<li>It focuses on availability: it does everything possible to remain operational also in case of errors</li>
<li>Consistency is eventual: it is not guaranteed at the end of each transaction but eventually it is restored when there is time available for the operation</li>
<li>Apache Cassandra is open-source and distributed
<ul>
<li>There is no central node, so no single point of failure</li>
<li>It works with wide-columns</li>
<li>It was initially developped at Facebook</li>
<li>It supports the Hadoop integration and MapReduce</li>
<li>It uses the novel query language CQL</li>
</ul></li>
<li>Apache Kafka is a distributed streaming platform</li>
</ul></li>
</ul>
<h1 id="virtualization">Virtualization</h1>
<ul>
<li>Virtualizing means creating a virtual version of a physical resource through an abstraction layer that hides the underlying implementation</li>
<li>Virtual machine are hardware-independent and their resource usage can be dynamically adapted</li>
<li>Virtualization advantages
<ul>
<li>Thanks to virtualization I can consolidate the services provided by many servers into a single machine</li>
<li>Applications are sandboxed in a virtual environment
<ul>
<li>I can test code and applications without risking to crash the whole physical server</li>
<li>I can create a dedicated envronment for legacy applications</li>
</ul></li>
<li>Virtual applications can be provisioned on demand</li>
<li>Hardware and software are decoupled: I can move VMs betwenn different hosts and I can suspend a VM when not needed</li>
<li>I can emulate hardware which is not present on the physical host</li>
<li>I can run applications that are not compatible with the OS of the physical machine</li>
</ul></li>
<li>Virtualization disadvantages
<ul>
<li>Virtualization is vulberable to bugs and hacking, since many different hosts and OSs are co-existing on the same hardware
<ul>
<li>VM-to-VM attack: a VM can have unauthorized acces to data of another VM</li>
<li>VM-to-HV attack: some hypervisors (KVM or XEN) work directly at the level of the hardware: everything can be compromised</li>
</ul></li>
<li>Performances in a virtual environment can be worse due to the overhead for the physical host
<ul>
<li>This is true particularly for I/O operations</li>
</ul></li>
</ul></li>
<li>Provisioning of VMs is NOT cloud computing if it does not respect the self-service, on-demand, network-based, elastic offer and pay-per-use paradigms (see next section)</li>
<li>KVM is a Linux kernel module for virtualization</li>
</ul>
<h1 id="cloud-computing">Cloud Computing</h1>
<ul>
<li>Cloud computing deals with supplying information and communication technologies as a service</li>
<li>The cloud model is focused on the concept of offering a service, without the need of thinking about the underlying physical infrastructure</li>
<li>It enables uniquitous access to shared pools of configurable system resources and higer level services that can be rapidly provisioned with minimal management effort, often over the internet (definition from the US National Insttitute of standards and technologies, NINST)</li>
<li>It is similar to a public utility in that achieves economy of scale and coherence: the cloud is a utility service</li>
<li>Cloud essential characteristics
<ul>
<li>Self-service, on-demand: computing capabilities can be provisioned unilaterally from the client, without the need for human intervention</li>
<li>Netwrok-based access: capabilities are available over the network and accessed trough clients</li>
<li>Resource pooling: physical resources are pooled by the cloud provider and the user has no control or knowledge of them</li>
<li>Elasticity: resources can be easily scaled up or down in response to demand, with minimal delay and apparent infinite capacity</li>
<li>Pay-per-use: the customer doen not incur in any upfront cost</li>
</ul></li>
<li>Cloud computing is not the same as virtualization but it can employ virtualization to pool physical resources</li>
<li>A cloud infrastructure has a teorethical infinite capacity, but you need infinite money to use it!</li>
<li>Infrastructure as a service (IaaS): the customer receives a machine with an OS
<ul>
<li>It can provide storage, computational and network services and it is often virtualized</li>
</ul></li>
<li>Platform as a service (PaaS): the customer manages data and software, but no direct access to the OS
<ul>
<li>I can ask for a HTC-Condor cluster already functional, a parallel file system, an SQL database</li>
</ul></li>
<li>Software as a service (SaaS): pre-formed environment entirely managed by the vendor
<ul>
<li>Gmail infrastrucutre for managing the email of a company</li>
</ul></li>
<li>At the end, what matters for the user is the application: don’t focus so much on the implementation!</li>
<li>The cloud paradigm has 3 main dimensions: service model (Iaas, PaaS, SaaS), deployment and isolation</li>
<li>The service model is what said before: IaaS, PaaS, SaaS</li>
<li>Deployment refers to where the services are distributed and it can be public, hybrid or private
<ul>
<li>A private cloud is accessible only to insiders and it rarely has infinite resources</li>
<li>A community cloud is available to a community of organizations sharing a common goal</li>
<li>A public cloud is AWS or Google Cloud, which can be assumed as infinite</li>
<li>An hybrid system is a combination of the above
<ul>
<li>I can use a private cloud system that redirects peak requests to a public system</li>
<li>I could also decide to use a private system for sensitive data and a public cloud for non-sensitive data</li>
</ul></li>
</ul></li>
<li>Isolation concerns how I isolate the servies offered to different customers
<ul>
<li>A dedicated cloud is dedicated to a scope (es. Bioinformatics)</li>
<li>A multi-tenant cloud is multi-purpose and is used by customers with different goals</li>
<li>I can also consider a tenant as a group of customers (es. research group), that payed for a specifc QoS</li>
<li>The isolation type is essential for determining how to deal with resource segmentation, data protection, application security, auditing, and disaster recovery</li>
</ul></li>
<li>The main clud use-cases are
<ul>
<li>End-user that interacts directly with the cloud
<ul>
<li>It should be easy to access without any specific technology (it should be an open client)</li>
<li>If need by the application, it should provide means for secure authentication</li>
<li>It should focus on privacy and security</li>
<li>The Service Level Agreement (SLA) tend to be simple</li>
</ul></li>
<li>Enterprise that uses the cloud to provide services to a end user
<ul>
<li>SLA tend to be detailed</li>
<li>It should provide, if needed, means of authentication for customers of the enterprise</li>
<li>It should be location-aware for legal purposes</li>
<li>It should proved monitoring services for the enterprise</li>
<li>It should provide standard APIs for different vendors</li>
</ul></li>
<li>Enterprise that internally uses cloud services
<ul>
<li>It may function as a suppletive storage</li>
<li>It may provide peak resources</li>
<li>It should use standards to avoid vendor lock-in (from the perspective of the enterprise)</li>
</ul></li>
<li>Different enterprises that use the same cloud
<ul>
<li>It must handle correctly concurrent access</li>
<li>If some resources (es. storage) are shared, they must be reliably modified by both enterprises</li>
</ul></li>
<li>The implementation of a private cloud
<ul>
<li>It does not require standard APIs, concurrency management, and other issues typical of a public cloud</li>
</ul></li>
<li>The process of changing cloud provider
<ul>
<li>Here standardization is essential</li>
</ul></li>
<li>The creation of an hybrid cloud
<ul>
<li>For the end user the shift from the private to the public cloud should be transparent</li>
</ul></li>
</ul></li>
<li>Migrating an application to the cloud can be motivated by reduction of costs, business agility and savings on management
<ul>
<li>Public clouds can be adapted much quicker to the demand!</li>
</ul></li>
<li>The choice of a public or private cloud can be influenced by the cost of WAN traffic, security concerns and integration with pre-existing applications</li>
<li>Migrating to a SaaS is not actually a migration but a change of application</li>
<li>Web hosting is one of the most common cloud use cases</li>
<li>Cloud computing services can be provised with or without virtualization
<ul>
<li>Cloud virtualization often allows to reduce operational costs</li>
<li>In many cases containers can be provided instead of full-blown virtual machines</li>
<li>A VM is only a building block: real life apps need databases, autoscaling features, ecc.</li>
<li>The Cloud is much more than provisioning VMs</li>
</ul></li>
<li>Multi-tiered application are organized into a data management tier, a business logic tier and a presentation tier
<ul>
<li>The data management tier concerns with the databases</li>
<li>If well designed it is possible to migrate the tiers independently to the cloud
<ul>
<li>This is not always possible, for example in cases with high network traffic between tiers</li>
</ul></li>
</ul></li>
<li>A stateless service does not store the state (a non-interactive web server is stateless)</li>
<li>A stateful service stores information about user interactions (a shopping cart is a stateful application)
<ul>
<li>It cannot be replicated easily!</li>
</ul></li>
<li>A cloud-aware application is stateless and distributed
<ul>
<li>Disaster recovery and scaling should be built-in in the app, not rely on system features</li>
<li>If there is a rise in requests I can just duplicate the system and create a new instance</li>
<li>Cloud-friendly applications are like cattle: I can easily replace them when needed</li>
</ul></li>
<li>Legacy applications are stateful and monolitic
<ul>
<li>Fail-over is managed by the infrastructure</li>
<li>Scaling is managed by the infrastructure</li>
<li>Legacy applications are like pets: I cannot replicate them and I need to take care of them</li>
</ul></li>
<li>The reduction of costs in the cloud is due to economy of scale and less requirements for management
<ul>
<li>Cooling systems are cheaper if used for huge datacenters</li>
<li>Lower hardware and power costs due to more contractual power</li>
<li>Management costs are shared for a higher number of paying customers</li>
<li>Resource aggregation allows for more efficient utilization</li>
</ul></li>
<li>The cloud democratizes resource access to small actors, since it make the resources more finely subdivideable</li>
<li>Thanks to its practically infinite capacity, the cloud moves problems from batch mode to real-time mode</li>
<li>SaaS applications provide ubiquitous access to resources from any device without specific software needed
<ul>
<li>An example is Google Docs, Dropbox</li>
</ul></li>
<li>The rise of cloud computing generates new business opportunities
<ul>
<li>Training and support the use of cloud services</li>
<li>Possibility for companies to develop open-source software for the cloud</li>
</ul></li>
<li>Cloud risks: security, privacy, vendor lock-in, data loss, isolation failure, incomplete data deletion
<ul>
<li>In the terms of service for standard accounts there is no guarantee of continuity, reliability, ecc</li>
<li>In many case cloud services are not completely mature</li>
</ul></li>
<li>AWS was launched in 2006 and it had a revenue of 17.5 billion dollars in 2017
<ul>
<li>It provides services to governments, companies, and individuals on a paid subscription basis</li>
<li>Most of its revenue is from IaaS</li>
</ul></li>
<li>Cloud provisioning Terms of Contract (ToC) explicitally decline any responsibility for unavailability or loss of data
<ul>
<li>There is no guarantee that the service will be uninterrupted, error-free, or free from harmful components</li>
<li>There is no guarantee that the data are stored safely and without any risk of data loss</li>
<li>The service is provisioned “as is”</li>
<li>The user is responsible for keeping its data safe, secure, and for making backups</li>
</ul></li>
<li>The set of cloud technologies is sometimes not completely stable
<ul>
<li>Tuning and experts are often needed</li>
<li>Sometimes non production-ready solutions are offered in order to avoid complex configs</li>
</ul></li>
<li>The cloud raises serious privacy and security concerns
<ul>
<li>How do I know that when I terminate a contract with a provider my data is actually deleted?</li>
<li>How can I avoid vendor lock-in</li>
</ul></li>
<li>Is my data on tyhe cloud safe from governments?
<ul>
<li>The CLarifying the Overseas Use of Data (CLOUD) Act, signed in the US in 2018, allows US officials to turn over user data regardless of the physical location of the servers</li>
<li>UK law requires ISPs to store the browsing history of clients for one year</li>
</ul></li>
<li>It is really hard to delete someone’s own account from certain websites
<ul>
<li><code>justdelete.me</code> provides a list of website categorized on how hard is it to delete an account hosted on them
<ul>
<li>It also provides instructions for how to do it</li>
</ul></li>
<li>For some websites, it is actually impossible to delete an account: Wikipedia, Steam, Starbucks, Netflix, Evernote, Wordpress, Udacity, Pastebin</li>
</ul></li>
<li>The EU and the US have a very different privacy approach
<ul>
<li>Regulations in the EU are more stable across legislations</li>
<li>In EU individuals have more control over their data</li>
<li>The same authority enforces privacy laws in the EU, while several governmental organization do so in the US</li>
<li>There are fewer organizations that support privacy in EU</li>
<li>EU citizens, but not US citizens, have the right to be forgotten</li>
</ul></li>
<li>The General Data Protection Regulation (GDPR, 2018) is a EU regulation that enforces privacy of personal data
<ul>
<li>The fines for breaching GDPR are of 20 million € (or 4% of global turnover, whicherver is greater)</li>
<li>Personal data is any information related to a natural person or Data Subject that can be used to identify (directly or indirectly) the person
<ul>
<li>It can be anything, from an IP address to a picture to an email address</li>
</ul></li>
<li>For non-personal data (e.g scientific data non related to Data Subjects) it is required
<ul>
<li>Free movent of data within the EU (no strict data localization)</li>
<li>Data availability for the authorities of the EU</li>
<li>Free porting of data (no vendor lock-in)</li>
</ul></li>
</ul></li>
<li>Some common cloud misunderstandings
<ul>
<li>Capacity is theoretically infinite, but it is not infinite in practice (as well as credit card limits are not infinite)
<ul>
<li>We may not be able to obtain the QoS that we need, when we need it</li>
<li>We may be asked a hefty price for what we need</li>
</ul></li>
<li>It is not easy to decide if a public or private cloud is best for our needs
<ul>
<li>I should evaluate the risk for data loss and leakeage, and the terms of the ToC</li>
</ul></li>
</ul></li>
<li>In 2021 28% of total market revenue for infrastructures, middleware and applications is expected to shift to the cloud</li>
<li>In 2021 70% of public cloud service revenue is dominated by the top 10 providers</li>
<li>There is no cloud, it’s just someone else’s computer</li>
</ul>
<h1 id="computing-models">Computing models</h1>
<ul>
<li>Workload management is the process of determining the proper workload distribution so to provide optimal performances
<ul>
<li>It controls where each job is run in order to maximise workload throughput andn ensure that each node is not over/underused</li>
<li>It handles job status, monitoring, information retrieving, and eventual input/output sandboxes</li>
</ul></li>
<li>Job scheduling in distributed infrastructures is challenging
<ul>
<li>Eager scheduling (push model) binds a job to an available resource as soon as possible, and executes it on that resource</li>
<li>Lazy scheduling (pull model) helds the job until a resource becomes available: jobs are extracted from a queue as soon as resources are available</li>
</ul></li>
<li>A Workload Managament System (WMS) can be developped in house for simple workloads, but it is almost always better to use community developped applications</li>
<li>In a push submission model, jobs can be submitted trough the WMS or directly to computing resources
<ul>
<li>The WMS has a clear picture of the state of the resources, and so it can distribute load efficiently</li>
<li>In a direct submission model the user has to take care of balancing the load across resources</li>
<li>It is possible to build a simple WMS on top of a direct submission system</li>
</ul></li>
<li>A pilot job submission model is a way to implement a pull submission system
<ul>
<li>A special job called Pilot is submitted a priori to all the available resources</li>
<li>The Pilot does not execute any payload, but it checks the hardware and software environment</li>
<li>Real jobs are pulled by the Pilot from a central task queue</li>
<li>If no tasks are available in the queue, the Pilot is terminated</li>
<li>A pilot submission mode has several advantages
<ul>
<li>The resources are tested by the pilot, and so there is less risk that they are faulty</li>
<li>It is easy with it to optimize the usage of resources</li>
<li>It can, to an extent, allow to bypass the priorities set by the sysadmin</li>
</ul></li>
<li>However, it has also disadvantages
<ul>
<li>It destroys any system of a-priori data distribution and pre-placement</li>
<li>The central queue is a single point of failure if not implemented correctly</li>
<li>The Pilot job introduces some overhead</li>
</ul></li>
</ul></li>
<li>Input and Output Sandboxes indicate the set of files that travel with the job when submitted
<ul>
<li>It is IMPORTANT to use SMALL sandboxes to avoid overloading the server handling them</li>
<li>Big files should be transferred using the tools provided by the infrastructure</li>
<li>A reasonable size for a sandbox is less than 5 Mb</li>
<li>If I use data management command instead of sandboxes, the load for the transfer is on the node and not on the server</li>
</ul></li>
<li>A job contains a prologue that prepares the environment for executing the job
<ul>
<li>It can install libraries, transfer data and executables, check software and hardware</li>
</ul></li>
<li>A job also contains an epilogue that runs post-execution scripts
<ul>
<li>It can transfer output data, update databases, compute checksums and perform final checks</li>
</ul></li>
<li>In some infrastructures the job itself cannot be modified by the user, but only prologue and epilogue can be modified</li>
<li>Different data distribution strategies can be implemented
<ul>
<li>A-priori push: I know already the resources to be used and I distribute the data before launching the jobs</li>
<li>Job pull: the job itself pull the needed data</li>
<li>No data distribution possible: the data is already distributed by someone else because of a policy</li>
<li>Output data can be left where it was produced, or moved somewhere else (in the job itself or in the prologue)</li>
</ul></li>
<li>When distributing data it is important to consider
<ul>
<li>A backup strategy: using different QoS for redundancy (i.e. tape and HDDs)</li>
<li>A failover strategy: use more than one phyisical site</li>
<li>Access policies: restrict write access to raw, irreplacable data</li>
<li>Dostributing equally the load on the nodes</li>
</ul></li>
<li>Remember: everithing that could go wrong will</li>
<li>It can be interesting to include input data in the infrastructure itself (VM images or snapshots)</li>
<li>Also the data management can be delegated to third party services</li>
<li>Data-driven computing model: I can decide to run my job in the nodes that happen to have the relevant data available
<ul>
<li>Not always I can afford to move data because of policies, privacy, network bandwidth</li>
<li>The matchmaking process between jobs and nodes in these cases needs to take into consideration data availability</li>
</ul></li>
<li>CPU-driven computing model: I can decide to send jobs wherever computing power is available, and transfer the data accordingly
<ul>
<li>Data distribution is done a priori or by the job itself</li>
</ul></li>
<li>A real-life complex workflow can be a linear combination of CPU-driven and Data-driven models
<ul>
<li>This is usually the case when different jobs of the workflow need very different hardware architectures (HTC vs HPC)</li>
</ul></li>
<li>The distributed infrastructures we saw until now are localised in the same WAN</li>
</ul>
<h1 id="high-performance-computing-hpc">High Performance Computing (HPC)</h1>
<ul>
<li>High performance computing (HPC): I want to speed up the execution time of single jobs</li>
<li>GFLOPs: billions of floating point operations per second
<ul>
<li>The max GFLOP of a system can be calculated from the number of sockets, cores per socket, clock frequency and FLOPs per cycle</li>
</ul></li>
<li>TDP: thermal design power, it is the maximum amount of heat that the cooling system must be able to dissipate in typical operations</li>
<li>The first machines for HPC were vector machines
<ul>
<li>They are contrapposed to the currently used scalar machines for the fact that they could operate directly on vectors with their instruction set</li>
<li>They were using single powerfull processors (small for now!)</li>
</ul></li>
<li>CRAY-1 (1976) was one of the first vector machines
<ul>
<li>It was able of 80 MFLOPs in scalar operations and 160/250 MFLOPs in vecotr operations</li>
<li>It was consuming 115 kW for operation + 330 kW for refrigeration!</li>
<li>It costed 8.8 million dollars</li>
</ul></li>
<li>CRAY-XMP (1982 and 1984) had first 2 and then 4 processors and was capable of 2*200 MFLOPs (800 MFLOPs with 4 processors)</li>
<li>CRAY-2 (1985) had 4 processor and was able of 1.9 GFLOPs</li>
<li>Subsequently in the 80s there was a shift for vector machines to massively parallel processors (MPP)
<ul>
<li>They used many standard processors connected in the same machine</li>
<li>This shift was made possible by the rise of microprocessors</li>
</ul></li>
<li>The Caltech Cosmic Cube used 64 Intel 8086 processors forming a 6-dimensional hypercube</li>
<li>A MPP can be a single computer with many networked processors
<ul>
<li>There can be thousands of processors</li>
</ul></li>
<li>In MPP processors need to communicate, since they are operating together on a single job
<ul>
<li>Low-latency connections between single cores and specialized networks are needed</li>
</ul></li>
<li>In time many dedicated MPP supercomputers were produced</li>
<li>In 1985 Thinking Machines produced the CM-1, and then the CM-200 and CM-5
<ul>
<li>CM-200 had 65536 1-bit CPUs and was capable of 40 GFLOPs</li>
</ul></li>
<li>Intel Paragon was lauched in 1993 and had 4000 Intel i860 RISC microprocessors
<ul>
<li>It was capable of 184 GFLOPs</li>
</ul></li>
<li>ASCI Red MPP (1997) was capable of 1.4 TFLOPs and it was the first supercomputer above 1 TFLOP</li>
<li>IBM BlueGene was designed as multiple SoCs (System on a Chips) and was able of 20 PFLOPs
<ul>
<li>It was focused on low power consumption</li>
</ul></li>
<li>A cluster is a parallel computer system made of an integrated collection of independent nodes (each of them capable of autonomous operation) and DERIVED FROM PRODUCTS DEVELOPPED FOR OTHER STAND-ALONE PURPOSES</li>
<li>It is possible to use a cluster of commercial-grade servers for HPC
<ul>
<li>In this case I need a really low-latency network to make them cooperate effectively</li>
</ul></li>
<li>The top supercomputers in the world
<ul>
<li>The Summit OLCF-4 supercomputer is in the USand it is used for civilian scientific applications</li>
<li>Its twin Sierra is also in the US and it is used for nulcear weapons simulations</li>
<li>Sunway TaihuLight is a chinese supercomputer used for oil research, weather forecast and drug discovery</li>
</ul></li>
<li>Some trends for HPC
<ul>
<li>Most supercomputers now are built as clusters, followed by a MPP architecture</li>
<li>Most supercomputers use Intel technology for their chips</li>
<li>Most HPC systems are built for the industry, not for research</li>
<li>Nvidia is the main provider of accelerators for HPC systems</li>
<li>Lenovo is the main HPC manufacturer</li>
<li>China has the biggest share of current HPC systems</li>
<li>Main applications of HPCs are astronomy, molecular dynamics, earth simulations, fluid dynamics, brain simulations, general relativity calculations</li>
</ul></li>
<li>The speedup of an application when it runs in parallel on P processors is the ratio among the running time of the same application on a sequential system and that on the parallel system
<ul>
<li>If the speedup is equal to the number of processors it means that there is no overhead for the parallelism: we are in a perfect linear speedup</li>
</ul></li>
<li>The efficiency of a parallel system is the ratio among the speedup and the number of processors
<ul>
<li>It is 1 in case of perfect linear speedup</li>
</ul></li>
<li>In rare cases the speedup can be superlinear, usually because of memory caching</li>
<li>Amdahl’s law predicts the speedup of a computation by assuming linear speedup
<ul>
<li>It leaves the serial processing part of the job untouched while it divides the parallel computation by the number of nodes</li>
<li>The maximum possible speedup is <eq env="math">S= 1/\alpha</eq> where <eq env="math">\alpha</eq> is the serial fraction of the computation
<ul>
<li><eq env="math">S=1 / \alpha</eq> is the actual statement of Amdahl’s law</li>
<li>The maximum possible speedup is the time without parallelization divided by the time needed for only the serial part</li>
<li>This is because the limit of time needed for the parallel part approaches 0 when the number of cores approaches infinity</li>
</ul></li>
</ul></li>
<li>HPC systems can use shared memory (RAM) in order to share information among threads and processes
<ul>
<li>Processes can run in the same or different processors when using shared memory</li>
<li>This is an efficient mean for sharing information among processes</li>
<li>A shared memory can be accessed simultaneously by different processors</li>
<li>Also memory sharing among different threads of the same process is referred to as shared memory</li>
<li>In uniform memory access (UMA) all the processors share uniformly the same RAM</li>
<li>In non-uniform memory access (NUMA) the memory access time depends on the location of the memory relatively to the processor</li>
<li>It is relatively easy to implement a shared memory system</li>
<li>Communication between processes is as fast as a concurrent memory access to the same location</li>
<li>Typical problems of a shared memory implementation are cache coherence and race conditions</li>
<li>When I am using shared memory I need to ensure that also the CPU caches are syncronised!</li>
<li>A Race condition is when the output of a parallel program changes by changing the order of execution of its threads, and it is generally a bad thing</li>
</ul></li>
<li>The NUMA API is used for setting shared memory allocation policies
<ul>
<li><code>libnuma</code> can be used for setting up a NUMA environment</li>
</ul></li>
<li>OpenMP is another API used for writing multithreaded applications
<ul>
<li>It shares variables among threads and greatly simplifies parallel programming in C/C++/Fortran</li>
<li>Communication happens through the sharing of variables among threads</li>
<li>It can cause a Race condition when common variables are unintentianally introduced in the threads</li>
<li>I can use synchronization to protect data conflicts, but it is computationally expensive</li>
</ul></li>
<li>Distributed memory refers to a multiprocessor system where each CPU has its own private memory
<ul>
<li>Each CPU can only operate on local data</li>
<li>A program in distributed memory implementations is a collection of named processes</li>
<li>Each process has a local address space without sharing</li>
<li>Communication among threads in mediated by explicit send/receive calls</li>
</ul></li>
<li>MPI is an API used for creating distributed HPC systems
<ul>
<li>Its core is representedby the functions <code>MPI_Send</code> and <code>MPI_Recv</code></li>
<li>The data to be sent or received is blocked, meaning that the function returns only when the data can be safely used</li>
<li>The reduction operation can be used for summarising a set of numbers ot a smaller set of numbers
<ul>
<li>It takes the input from the distributed processes and then places the result only in the root process</li>
</ul></li>
</ul></li>
<li>Hardware coprocessors can be used for accelerating the FLOPSof a HPC system
<ul>
<li>Coprocessors are not a new idea: in 1980 the Intel 8087 was one of the first floating point coprocessors
<ul>
<li>The 8087 was the first coprocessor to use the x87 instruction set</li>
<li>The x87 adopted the important IEEE754 standard for floating point operations</li>
</ul></li>
<li>Vector coprocessors in time were absorbed into CPUs and now are a main part of every CPU</li>
<li>The GPU is one of the most used coprocessors
<ul>
<li>In the 2006 CUDA was born: it is a parallel computing platform for performing general computation on a Nvidia GPU</li>
<li>A GPU is driven by a CPU that manages the code to be executed on GPUs, the memory of the GPU and the movements between CPU and GPU</li>
<li>Optimized HPC applications can be bounded by computing or by bandwidth</li>
<li>When comparing performances of CPU and GPU, be sure that the applications used for the comparison are optimized for both CPU and GPU and that the algorithm is state of the art!</li>
<li>When you see claims of 100x speedup due to GPU, be suspicious!</li>
<li>A GPU has a penalty compared to a CPU since it needs to move data across the PCI bus from the CPU to the GPU: this must be considered when making comparisons</li>
</ul></li>
<li>A modern silicon chip contains integrated components: in the same chip I can have CPU, GPU, chaches, and other devices</li>
</ul></li>
</ul>
<h1 id="htc">HTC</h1>
<ul>
<li>High throughput computing (HTC) I want to maximise the number of jobs executed, not speed up the single job
<ul>
<li>Many copies of the same job are run in parallel</li>
<li>There is no speedup for the single job</li>
<li>It maximises the throughput of the system</li>
</ul></li>
<li>HTC infrastructures deliver high computational power in a long time, while HPC infratructures deliver huge computational power in short bursts</li>
<li>HTC infrastructures are PC clusters, server clusters, distributed systems and grids</li>
<li>A Grid is an hardware and software infrastructure that provides dependable, consistent, and inexpensive access to high-end computational capabilities
<ul>
<li>A Grid coordinates resources that are NOT subject to centralised control</li>
<li>Uses standard, open and general-purpose interfaces and protocols</li>
<li>Delivers non-trivial QoS</li>
</ul></li>
<li>The users of a Grid are virtual organizations
<ul>
<li>A cirtual organization is a set of individuals that share resources under certain rules</li>
<li>Sharing of resources is highly controlled and well-defined</li>
<li>The owner of the individual resources decides who can access them</li>
</ul></li>
<li>First law of the Grid: 95% of the Grid is agreement on protocols between participating institutions
<ul>
<li>Standards, protocols, and interfaces aim at providing common abstractions of different implementations of similar services</li>
</ul></li>
<li>There is no Grid owner and the network is distributed: I do not know which machine is processing my data
<ul>
<li>My job gets processed somewhere, somehow, after some time</li>
</ul></li>
<li>The Grid is similar to the power grid: “We will probably see the spread of computer utilities, which, like present electric and telephone utilities, will</li>
<li>The Grid paradigm: a Grid middelware makes supercomputers, PC clusters, scientific equipment, storage devices, sensors, networks and the internet available to users in forms such as mobile access, desktop workstations, and visualization tools service individual homes and offices across the country” (Len Kleinrock, 1969)</li>
<li>Grids can be of different types
<ul>
<li>Grid services based on supercomputers</li>
<li>Grids based on conventional clusters</li>
<li>Grids based on clusters of desktop PC voluntarily contributed by users, that share part of their computational power</li>
</ul></li>
<li>The LHC computing Grid is a computer Grid established by CERN for dealing with the large amount of data produced by the Large Hadron Collider (LHC)
<ul>
<li>It has a tiered architecture with Tier 0 being the LHC itself, Tier 1 being formed by 11 national datacenters (INFN-CNAF for Italy), and Tier 2 being formed by about 130 other centers</li>
<li>It includes 400k logical CPUs, 122 Pb of disk storage, and 128 Pb of tape storage</li>
</ul></li>
<li>The European Grid Infrastructure (EGI) supports scientific research in different disciplines</li>
<li>Second law of the Grid: anything that can go wrong, will
<ul>
<li>Grids are really complex, and they often fail</li>
<li>“A distributed system is one in which the failure of a computer you didn’t even know existed can render your computer unusable” (Leslie Lamport)</li>
<li>Expect the unexpected (2008 J. Phys.: Conf. Ser. 119 052030)
<ul>
<li>Services don’t respond or return an invalid message</li>
<li>Air conditioning or power fails again and again</li>
<li>A disk fail and you need to recover from a tape backup, but the tapes have been overwritten</li>
<li>A service engineer puts a Coke into a machine</li>
<li>Oracle returns you not your data but those of someone else</li>
<li>A fishing crawler cuts a trans-Atlantic netwrok cable</li>
<li>A tsunami does the same in Asia Pacific</li>
</ul></li>
<li>Bologna, November 9 2017: a major water pipe breaks near the INFN-CNAF datacenter in the early morining
<ul>
<li>The CNAF center was flooded with 50 cm of water on the outside</li>
<li>The water inside the center was only 10 cm thanks to water-tight doors</li>
</ul></li>
</ul></li>
<li>Grid security
<ul>
<li>The resources on a Grid are accessible to members of virtual organizations</li>
<li>The resource owner decides which virtual organizations are allowed to use the resources</li>
<li>The Grid implements a single sign on policy: one access system grants all the resources available</li>
<li>The Grid should allow for delegation: it should be possible for a user to endow a program with the ability to access on the user’s behalf the resources that the user is authorized to use</li>
<li>The X.509 certificate is used for signing into a Grid
<ul>
<li>It contains the Public key of the certificate owner, its identity, information on the Certification Authority (CA), time of validity, serial number, digital signature of the CA</li>
<li>A X.509 certificate is basically a public key of the certificate owner signed by a CA, with additional metadata</li>
</ul></li>
<li>A proxy X.509 certificate is a certificate with limited lifetime that is signed with the private key of the root entity certificate, or with another proxy certificate
<ul>
<li>A proxy certificate allows for delegation of authentication to remote processes</li>
</ul></li>
<li>The X.509 workflow: a CA signs the root certificate of an entity, which is in turn used to sign proxy certificates
<ul>
<li>The proxy certificates are then used to sign daily by the user</li>
</ul></li>
</ul></li>
<li>A Grid job is similar to a job in a cluster: it contains input and output sandboxes, the executable, prologue and epilogue, and other information</li>
<li>Each job on the Grid is identified by an URL containing the address of the server who accepted it and a job ID
<ul>
<li>The job ID is unique and virtually non-recyclable</li>
<li>The ID is a random string, since no serial numbering is possible in a decentralised system</li>
</ul></li>
<li>The HTC paradigm is suited to many applications
<ul>
<li>Embarassing parallel jobs</li>
<li>Opportunistic usage</li>
</ul></li>
<li>The crunching factor or speedup in a distributed system is the ratio between the time needed to execute a task on a single machine and on a distributed infrastructure
<ul>
<li>It depends on the number of available resources, the priority of the user, the congestion of the infrastructure</li>
<li>It is highly influenced by data transfer times and by errors/resubmissions</li>
<li>The speedup is very unstable over time</li>
</ul></li>
</ul>
<h1 id="containers">Containers</h1>
<ul>
<li>Virtual machines carry quite a bit of overhead due to the duplication of many OS components</li>
<li>A container is a virtualization framework that includes only an application and its dependency
<ul>
<li>It enjoys the isolation and resource allocation benefits of a virtual machine without much of the associated overhead</li>
<li>Containers share the OS and, where possible, libraries, with the host</li>
</ul></li>
<li>Containers require less resources than virtual machines
<ul>
<li>They start faster and run faster than virtual machines</li>
<li>Many more containers than VMs can fit in the same host</li>
</ul></li>
<li>Very important: containers simplify enormously software development and deployment because they allow to encapsulate applications in a controlled and extensible way</li>
<li>They can be compared to shipping containers for goods</li>
<li>Docker is one of the most popular container engines
<ul>
<li>It is open source</li>
<li>Their website <code>hub.docker.com</code> features a git-like repository</li>
<li>The Docker engine must be present in the host in order to run a Docker container</li>
<li>The Docker engine manages resources for the different containers</li>
<li>The same container can be easily shared and run on different hosts (provided that they have the same kernel)</li>
</ul></li>
<li>A (docker) container does not include an OS, it is based on the host OS
<ul>
<li>It operates at the application level</li>
<li>It has the same pros without many of the cons of VMs</li>
<li>It emulates binaries and libraries needed for the application</li>
<li>It is an extended version of <code>chroot</code></li>
</ul></li>
<li>In order to execute a container I just need the right kernel, without worrying about libraries and binaries
<ul>
<li>I also need the docker engine!</li>
</ul></li>
<li>There are many container engines, but they are usually compatible
<ul>
<li>You can build a container with an engine and then run it with another</li>
</ul></li>
<li>Containers are ephimeral: every data in them exists only while the container is running
<ul>
<li>I need to commit the modifications of a container in order to make them persistent</li>
<li>Another approach for making data persistent is to bind-mount a host directory to a container, or to create a Docker volume</li>
</ul></li>
<li>Docker can be used for doing development on a local laptop, and then ship it to the production infrastructure</li>
<li>It is possible to create an application stack with Docker Compose
<ul>
<li>An application stack is a set of containers linked together in order to provide a service</li>
<li>Docker Compose is a different software from Docker</li>
<li>An application stack can be described with a <code>.yaml</code> file, which is parsed by Docker Compose</li>
<li>Docker Compose is best suited when autoscaling or a multi-server environment is not needed</li>
<li>For more complex setups, Docker Swarm or Kubernetes is preferrable (see BDP2)</li>
</ul></li>
<li>Best practices with containers
<ul>
<li>A container should contain only ONE application</li>
<li>The entry point in the container should be explicitly defined (<code>CMD</code> field)</li>
<li>Keep containers as small as possible</li>
</ul></li>
<li>Some words on security
<ul>
<li>Docker is required for running containers, and it requires root priviledges in order to be installed</li>
<li>Containers downloaded from the web may contain viruses</li>
<li>Passwords and tokens should NOT be embedded in containers
<ul>
<li>Docker has a purpose-built secret management feature</li>
</ul></li>
<li>If the host is compromised, container isolation is compromised</li>
<li>There can be exploit that allow to breach isolation and interact with the host</li>
<li>Since starting containers is easy, it is possible to have a DoS attack</li>
<li>Containers should be update regularly when new security patches for the included softwares become available</li>
</ul></li>
<li>Even tough Docker is really useful, many HPC systems and traditional cluster do not have it installed
<ul>
<li>You need root priviledges to install it, or you need to contact an administrator</li>
<li>Sometimes administrators do not want to install docker because of security concerns</li>
<li>Udocker (INDIGO, INFN-CNAF) is a user-space tool that can run Docker containers without requiring any support from the kernel
<ul>
<li>It is a single python script</li>
</ul></li>
<li>It is NOT possible to create images from Udocker
<ul>
<li>It does not require root priviledges</li>
</ul></li>
</ul></li>
</ul>
<h1 id="low-power-devices">Low power devices</h1>
<ul>
<li>In the past HPC systems tended to use vector processors, but in time these started to be replaced by cheaper, highly available, and more energy-efficient microprocessors</li>
<li>Microprocessors started to be mass-produced with the rise of the PC: they are said to be commodity hardware</li>
<li>System on Chip (SoC) devices tend to have a multitude of different cores
<ul>
<li>There are cores specialised for power efficency, and cores specialised for peak performances
<ul>
<li>This architecture concept is called heterogeneous multiprocessing (HMP)</li>
</ul></li>
<li>SoCs can be found in mobile devices and embedded systems</li>
</ul></li>
<li>We are now seeing a trend in computing where SoCs are being used more and more, at the expenses of mircroprocessors
<ul>
<li>Is history repeating as for the replacement of vector processors with microprocessors?</li>
<li>It is not easy to say, but SoCs are definitively becoming more and more important</li>
</ul></li>
<li>Europe is leader in the production of SoCs and low-power devices</li>
<li>ARM is the main SoC producer for mobile (CPU and GPU)
<ul>
<li>It was born in the UK, but now it is owned by a japanese firm</li>
</ul></li>
<li>The main producers of SoCs for embedded systems are Siemens, Bosch, Infineon</li>
<li>The MontBlanc Project is a european energy-efficient HPC project
<ul>
<li>It is based on many ARM SoCs mounted on PCI cards</li>
</ul></li>
<li>Exascale computing with traditional means requires a nuclear reactor for power!</li>
<li>Exascale computing poses many challanges beside power consuption
<ul>
<li>The cost of the power required</li>
<li>The possibility to pack enough components in a reasonable space</li>
<li>Resilience to component failure</li>
<li>Availability of adequate software for exploiting the architecture</li>
</ul></li>
<li>The general architecture of a HPC low-power system is NOT an iPhone cluster
<ul>
<li>It implements a standard rack confoguration</li>
<li>It uses Linux</li>
<li>It uses a batch scheduler to handle the execution of scientific jobs</li>
</ul></li>
<li>The ODROID-XU3 board has a maximum power comsumption of 15 W and a cost of 150 euros
<ul>
<li>It uses an ARM big.LITTLE technology with HMP and a Mali-T628 MP6 GPU</li>
<li>It uses Ubuntu 14.4 as an operating system</li>
<li>It has 2 GB of RAM, an HDMI port and 64 GB of flash storage</li>
</ul></li>
<li>The NVIDIA JETSON TK1 board an ARM+CUDA programmable SoC architecture
<ul>
<li>It is also based on linux</li>
</ul></li>
<li>A System on Module (SoM) is a device that integrates a series on component on a single module (es. a PCI slot)</li>
<li>When changing the computing paradigm (CPU, GPU, SoC, …) always ensure the numerical correctness of the results you obtain, do not only look at performances!</li>
</ul>
<h1 id="internet-of-things-iot">Internet of Things (IoT)</h1>
<ul>
<li>The IoT is the network of physical devices connected through their electronic components</li>
<li>Each ‘Thing’ can be identified via its unique MAC address and is able to cooperate with the existing internet infrastructure</li>
<li>The IoT is a network of devices that collect and share huge amounts of data</li>
<li>The collected data are processed in a central Cloud-based service, where it is aggregated with other data and made available to the end-user in a processed form</li>
<li>IoT increases automation in homes, schools, and businesses</li>
</ul>
<h1 id="fog-and-edge-computing">Fog and Edge Computing</h1>
<ul>
<li>Traditionally, the wast amount of data produced by IoT systems has been streamed and processed in a centralised cloud</li>
<li>The access to data through the cloud can be slow because of the time required for streaming data back and forth from the local device</li>
<li>There can be privacy concerns in streaming certain kinds of data to the cloud</li>
<li>Case study: self-driving cars
<ul>
<li>The many sensor in a self-driving car produce 40 TB of data every 8 hours of drive</li>
<li>It is unsafe, unnecessary and unpractical to send this many data to the cloud</li>
</ul></li>
<li>It is needed a decentralised, adaptive computational paradigm
<ul>
<li>Data should be accessed locally, so to reduce the access latency</li>
<li>This can reduce network congestion and improve scalability</li>
<li>Fog and Edge Computing provide faster approaches that enjoy better situational awareness in a way more timely manner</li>
</ul></li>
<li>Edge computing refers to the infrastructure that exists close to the source of data and outside a centralised cloud
<ul>
<li>Its role has been mostly that of ingesting, gather, store, filter and send data to cloud systems</li>
<li>A lot of processing can be done on the source of data itself or next to it, at the edge of the network</li>
<li>Edge computing significantly improves latency and reduces the volume of data movements</li>
<li>It provides new possibilities for IoT applications for those relying on
<ul>
<li>Machine learning for object detection, face recognition, language processing</li>
<li>Intermittent connectivity, for instance applications in remote locations where bandwith is expensive or inconsistent</li>
</ul></li>
<li>It is particularly useful for real-time analytics</li>
<li>It improves privacy and security by keeping sensitive data on the source devices</li>
</ul></li>
<li>Fog Computing is a layered model for ubiquitous access to a shared continuum of scalable computing resources
<ul>
<li>It consists of fog nodes residing between end-devices and cloud services</li>
<li>Fog nodes are context-aware and support a common communication protocol</li>
<li>Fog computing minimises latency</li>
<li>It provides local computing resources to end-devices and, when required, network connectivity to centralised services</li>
</ul></li>
<li>Essential characteristics of Fog Computing
<ul>
<li>Contextual location awareness of the nodes and low latency</li>
<li>Geographical distribution of the nodes</li>
<li>Interoperability and federation of nodes</li>
<li>Real-time interaction instead of batch processing</li>
<li>Predominance of wireless access</li>
</ul></li>
<li>Fog nodes can be deployed under different models
<ul>
<li>Private Fog Nodes: for the exclusive use of an organization comprising multiple customers</li>
<li>Community Fog Nodes: for the use of organizations joined in a community that has shared concerns</li>
<li>Public Fog Node: for open use by the general public</li>
<li>Hybrid Fog Node: a complex node that is composed of 2 nodes of disticint deployment models, that are unique but bound by technologies that grant data and application portability</li>
</ul></li>
<li>A digital twin is a digital replica of a physical entity
<ul>
<li>It integrates IoT, machine learning, and software analytics with spatial network graphs</li>
<li>It creates a living simulation model that is updated and changes as their physical twin changes</li>
<li>It is useful for testing and simulations</li>
<li>The object that is miirored can be a wind turbine, an engine, an entire airplane,…</li>
</ul></li>
</ul>
<h1 id="part-2---prof.-salomoni">Part 2 - Prof. Salomoni</h1>
<hr />
<h1 id="introduction-1">Introduction</h1>
<ul>
<li>This module focuses on topics beyond the IaaS model and it is mostly hands on</li>
<li>The main topics are: cloud storage, Docker containers, authentication and authorization for cloud services, automation for cloud applications</li>
<li>Professor is also a physicist from INFN, graduated from UniBo</li>
</ul>
<h2 id="paas">PaaS</h2>
<ul>
<li>The PaaS type is a way to program a Cloud infrastructure so to allow developpers to build applications and services</li>
<li>A PaaS service can include preconfigured features to which cutsomers can subscribe, so to make the system fit their requirements</li>
<li>The services are updated and maintained by the cloud provider, so the user does not need to worry about these details
<ul>
<li>E.g an Oracle database as a PaaS: no need for the user to update the Oracle software</li>
</ul></li>
<li>PaaS providers can assist developpers in the design of their applications and in the testing an deployment phases</li>
<li>AWS offers Elastic Beanstalk as a PaaS service
<ul>
<li>It is useful for deploying and scaling web applications and services developped with Java, Python, Docker, and other systems on familiar services such as Apache and Nginx</li>
</ul></li>
<li>There are several PaaS frameworks available, some public and some that can be installed on private resources
<ul>
<li>The INDIGO-DataCloud PaaS layer</li>
<li>Cloudify</li>
<li>RedHat OpenShift</li>
</ul></li>
</ul>
<h1 id="cloud-storage">Cloud Storage</h1>
<h2 id="file-systems">File Systems</h2>
<ul>
<li>Data can be stored directly in a block device
<ul>
<li>In this case data is stored sequentially, and no metadata is stored</li>
</ul></li>
<li>Data can be stored in a database as key:value pairs</li>
<li>Data can be stored in a file system
<ul>
<li>Data is organised in a tree-like directory structure</li>
<li>Metadata such as filename, timestamps, size can be stored also by the file system</li>
</ul></li>
<li>There are many types of filesystems
<ul>
<li>For disk storage there is FAT (File Allocation Table) with several variants (FAT16, FAT32, exFAT), NTFS, HFS, ext2 (extended filesystem), ext3, ext4, XFS, BTRFS (B-tree filesystem),…</li>
</ul></li>
<li>Network file systems allow to access files from remote computers</li>
<li>Shared file systems allow files to be shared among a set of machines</li>
<li>The Portable Operating System Interface for Unix (POSIX) standards are a set of standards that define an API and some shell and utility interfaces to maintain compatibility among operating systems
<ul>
<li>It was developped primarly for Unix-like systems, but any OS can use the POSIX standards</li>
<li>POSIX emerged from a project started in 1985</li>
<li>The POSIX standards are collected in IEEE1003, also called ISO/IEC9945</li>
</ul></li>
<li>POSIX I/O (a non-official name) is the portion of POSIX that defines the I/O interface
<ul>
<li>It provides <code>read(), write(), open(), close()</code> and other functions</li>
<li>It prescribes a set of metadata that a file must possess
<ul>
<li>The user and group which own the file</li>
<li>The permissions that are given for read, write, and execute to different users and groups</li>
<li>Attributes such as creation and last modification timestamps</li>
</ul></li>
<li>POSIX calls can show and manipulate POSIX metadata
<ul>
<li><code>chmod</code> and <code>stat</code> are shell commands that provide an interface for the relevant POSIX calls</li>
</ul></li>
<li>POSIX I/O is stateful
<ul>
<li>Reading and writing data is governed by some persistent statethat is maintained by the OS in the form of file descriptors</li>
<li>A file descriptor (or file handle) is a number that uniquely identifies an open file in the kernel global file table
<ul>
<li>The file table contains information such as the inode of the file, the byte offset, and the file permissions</li>
</ul></li>
<li>Applications cannot read or wirte a file before opening it, so that they can get a file descriptor</li>
<li>The position where the next read or write will take place is the position at which the last read, write or seek call ended</li>
<li>Write operations require strong consistency: a write call blocks application execution until the system can guarantee that any read call will see the newly written data</li>
<li>A dirty solution to stateful I/O is requiring strong consistency for write operations only until the file is written to a memory page, not until the file is permanently stored on disk
<ul>
<li>These memory pages that contain data not yet flushed to disk are called dirty pages, and they are tracked by the OS</li>
<li>The use of dirty pages is called page caching</li>
<li>The OS flushes asynchronously dirty pages to disk</li>
<li>This apporach is POSIX-complaint since the OS tracks dirty pages and returns their content to successive read calls, not the content of the file stored on disk</li>
</ul></li>
</ul></li>
</ul></li>
<li>A networked file system like NFS is used for accessing files over a network in a way very similar to how local files are accessed
<ul>
<li>It uses a POSIX-like syntax implementing open, read, and write calls</li>
<li>Page caching is more complicated in a networked file system since different clients that operate in the same file will not share the same memory pages</li>
<li>In general, it is NOT safe to assume that consistency is automatically respected with parallel reads or writes in a networked file system</li>
<li>In order to enforce strong POSIX consistency in a networked file system it is needed to enforce that no node can read data until the dirty pages have been flushed to the remote server storing the data: different approaches are possible to enforce this
<ul>
<li>A file system can avoid page caching at all to solve this problem, at the cost of I/O latency</li>
<li>It can relax POSIX consistency such that it provides consostency in most reasonable I/O workloads, but does NOT guarantee consistency if 2 nodes try to modify the same part of a file at the same time</li>
<li>It can enforce a locking mechanism so that a node cannot modify a file that is open in anothe node</li>
</ul></li>
<li>NFS relaxes POSIX consistency in order to guarantee a reasonable level of consistency in most use cases
<ul>
<li>It guarantees a close-to-open consistency</li>
<li>A file is guaranteed to be consistent from when it is closed to when it is open again</li>
<li>While a file is open there is no consistency guarantee: if 2 nodes open the same file at the same time it is possible for them to hold dirty pages</li>
<li>It is up to client application to manage concurrent access to the same files</li>
</ul></li>
<li>Other distributed file systems like Lustre or GPFS implement a complex locking mechanism to ensure consistency</li>
</ul></li>
</ul>
<h1 id="rest-and-json">REST and JSON</h1>
<ul>
<li>A POSIX interface is not the only possible way to work with files</li>
<li>REST (REpresentational State Transfer) is an architecture style for designing networked applications</li>
<li>For all practical purposes, RESTful applications use HTTP GET requests to make calls between machines (create, update, read, delete data)</li>
<li>Many web services offer REST API</li>
<li>REST can be used in Python via several libraries such as <code>httplib, urllib, requests</code></li>
<li>JSON (JavaScript Object Notation) is a lightweight format for storing and transporting data
<ul>
<li>It is commonly used to transfer data to/from web servers</li>
<li>Data is organised in key:value pairs</li>
<li>Data is separated by commas</li>
<li>Objects are delimited by curly brackets</li>
<li>Arrays are delimited by square brackets</li>
<li>In Python JSON is offered by the <code>json</code> module</li>
</ul></li>
</ul>
<h2 id="object-storage">Object Storage</h2>
<ul>
<li>Especially in the cloud, not all the storage is organised with POSIX interfaces</li>
<li>Object storage organises data into a storage system in self-contained entities called objects</li>
<li>Each object is assigned an unique ID, managed in a flat index
<ul>
<li>This is contrapposed to the tree-like structure of POSIX file systems</li>
</ul></li>
<li>An object can be accessed by an application by providing its unique ID to the object storage system</li>
<li>Objects tend to have rich metadata
<ul>
<li>Some of these metadata are non-editable and they are set at the time of object creation</li>
<li>Editable metadata can have fixed keys or they can be custom fields</li>
</ul></li>
<li>Fixed-key metadata have fixed keys and allow only the editing of the value field
<ul>
<li>Access control metadata: object storage uses IAM (Identity and Access Management) and ACLs (Access Control Lists) to control the access to objects</li>
<li>Content type: also called MIME type, it specifies the kind of data contained in the object</li>
<li>Content disposition: it controls the presentation style of the content (automatic opening, fullscreen mode,…)</li>
<li>Content encoding: it can indicate that an object is compressed, and the compression algorithm used</li>
<li>Content language: the language that the object is intended for</li>
<li>Cache control: it specifies whether the object can be cached and whether the data can be transformed</li>
</ul></li>
<li>Custom metadata allow editing of both the key and the value fields
<ul>
<li>They are specified as a key:value pair and they can be added and removed</li>
<li>They are limited to a maximum of 100 instances and 10 MB</li>
</ul></li>
<li>A key advatage of object storage is its simplicity</li>
<li>Object storage system implement only a few commands
<ul>
<li><code>PUT</code>, similar to a POSIX <code>write</code>, puts the object into the storage system</li>
<li><code>GET</code>, similar to a POSIX <code>read</code>, gets the object from the storage system</li>
<li><code>DELETE</code>, removes the object from the storage system</li>
<li><code>HEAD</code>, returns only the object’s metadata</li>
</ul></li>
<li>Object storage follows a write once, read many approach
<ul>
<li>Data is written once, when an object is created
<ul>
<li>Modifying an object means creating a new object: IDs are unique</li>
<li>It is up to the user to keep track of which ID refers to which file</li>
<li>Since objects are immutable, there is no need to manage concurrent access from different clients
<ul>
<li>Some object storage systems do not allow even to edit the metadata of an object to avoid concurrency problems!</li>
</ul></li>
<li>An object is uniquely referred to by its ID
<ul>
<li>A simple hashing of the ID can be used to determine the physical location of an object</li>
</ul></li>
</ul></li>
<li>The same object can be read many times</li>
</ul></li>
<li>Objects cannot be used for scratch space or hot storage</li>
<li>Object-based application are often focused on data archival</li>
<li>The use of unique IDs allow great scalability, allowing for fast access to a vast number of objects</li>
<li>It is possible to store vast amounts of unstructured data in an object storage system</li>
<li>Object storage is used for storing pictures on Facebook, songs on Spotify, and files in Dropbox</li>
<li>Object storage systems are software-defined scale-out architectures that can take advantage of commodity hardware
<ul>
<li>Scaling out referes to multiplicating the number of equal resources available, instead of scaling up the type of resource</li>
<li>I can just add more storage devices to increase capacity, according to demand</li>
</ul></li>
<li>An object storage cluster typically uses a cluster of nodes based on object storage, which communicate to a gateway layer through REST APIs</li>
<li>Popular cloud storage services based on object storage are AWS S3 (Simple Storage Service), Google CLoud Storage, Rackspace Files</li>
<li>Some distributed file systems use object storage
<ul>
<li>Metadata is stored in metadata servers</li>
<li>Data is stored in object storage servers</li>
<li>An abstraction layer provides to users acces to data in a POSIX-like way</li>
<li>Examples of this are IBM Spectrum Scale (GPFS), Dell EMC Elastic Cloud Storage, Ceph, Lustre</li>
</ul></li>
</ul>
<h2 id="virtual-file-systems">Virtual File Systems</h2>
<ul>
<li>A virtual files system is an abstraction layer on top of one or more concrete storage devices or file systems</li>
<li>Its purpose is to offer a standardised POSIX interface to applications, so that they do not need to worry about technical details</li>
<li>Onedata is a virtual file system that provides unified data access across globally distributed environments
<ul>
<li>It allows users to easily share collaborate on stored data</li>
<li>It is mostly used for scientific applications</li>
<li>Data is organised in distributed virtual volumes called spaces</li>
<li>Entities who support spaces with actual storage resources are called providers</li>
<li>A zone is a federation of providers which enables the creation of closed or interconnected communities</li>
</ul></li>
<li>MinIO is an high-performance, software-defined object storage suite compatible with AWS S3
<ul>
<li>It allows to mount a remote bucket as if it were a local directory</li>
<li>It is the native storage system for Kubernetes</li>
</ul></li>
<li>The fundamental concept is that in a virtual file system I can acces files with POSIX calls, I do not need to prefetch data with HTTP GET requests
<ul>
<li>However, if I want I can use an S3-compatible interface</li>
</ul></li>
</ul>
<h1 id="advanced-docker-containers">Advanced Docker Containers</h1>
<h2 id="networking">Networking</h2>
<ul>
<li>Docker implements versioning (git-like), component re-use, and sharing through a public repository</li>
<li>Networking in Docker containers can be handled in several ways
<ul>
<li>Possible options for networking are no networking, bridge networking, host networking, overlay networking, Macvlan networking</li>
<li>The networking mode can be specified with the <code>--network=&lt;my_net&gt;</code> flag in the <code>docker run</code> command</li>
<li>Bridge networking is the default networking mode in the absence of a spacific flag</li>
</ul></li>
<li>The flag <code>--network=none</code> disables networking for containers
<ul>
<li>It is useful when the containerised application does not need to acces the network</li>
<li>In a container run with this option <code>ip address show</code> will show only the loopback device</li>
</ul></li>
<li>Bridge networking is the default option for Docker
<ul>
<li>A bridge is a network device that allows the transfer of packets in the same network segment</li>
<li>Docker creates a virtual bridge between container and host</li>
<li>If 2 containers are connected to the same bridge they can communicate with each other
<ul>
<li>All the containers connected to the same bridge have an IP address in the same network</li>
</ul></li>
<li>By default, Docker creates a single bridge called “bridge”, to which all the containers are connected</li>
<li>A new bridge can be created with the command <code>docker network create my_bridge</code></li>
<li>The available networks for Docker can be inspected with the command <code>docker network ls</code></li>
<li>Containers connected to different bridges cannot communicate with each other</li>
<li>In order to connect a container to a custom bridge, I can just specify its name in the flag as <code>--network=my_bridge</code></li>
<li>Using different bridges for containers enhances security by making it impossible for containers to communicate with each other</li>
<li>Containers connected to the same bridge see automatically all the ports of the other containers</li>
<li>In the default bridge there is no automatic name resolution</li>
<li>In custom bridges container names are resolved autmatically
<ul>
<li><code>ping container1</code> resolves the actual IP address of container1</li>
</ul></li>
<li>It is possible to connect a container to more than 1 bridge with the command <code>docker network connect &lt;bridge&gt; &lt;container&gt;</code></li>
<li>When connecting to the internet, a container assumes the IP of its host thanks to the NAT service of the Docker engine</li>
</ul></li>
<li>Host networking is specified by the flag <code>--network=host</code>
<ul>
<li>This option connects the container directly to the host network, without using a NAT service</li>
<li>In this case the container uses the IP address of the host</li>
<li>Port mapping is not possiblein host mode, since all the ports of the host correspond to that of the container</li>
<li>It is not possible to have 2 containers in host mode running a service on the same port</li>
<li>Host networking is used only in special cases</li>
</ul></li>
<li>Macvlan networking assigns an idividual MAC address and IP address to each container
<ul>
<li>No NAT service is used, since the container has its own MAC address</li>
<li>With macvlan mode, it is easy to get an IP address exhaustion</li>
<li>Also macvlan is used only in special cases</li>
</ul></li>
<li>The networks covered up to this point are applicable to containers running on the same host</li>
<li>Docker overlay networks instead can connect Docker deamons running on different hosts</li>
</ul>
<h2 id="process-management-and-logging">Process Management and Logging</h2>
<ul>
<li>It is possible to monitor the state of resources from inside a container, but it is more useful to be able to monitor reosources from the host
<ul>
<li>This is especially the case when many containers are running on the same host</li>
</ul></li>
<li><code>docker stats</code> is a live tool that streams container resource usage statistics</li>
<li>By default a container has no resource constraint and so it can use the host resources for as much as it is allowed by the Docker host kernel scheduler
<ul>
<li>This means that if a container is misbehaving, the host may crash</li>
</ul></li>
<li>It is possible to limit the resource usage of a container with the flags <code>--memory="256MB"</code> and <code>--cpus=".5"</code>
<ul>
<li>The cpu flag specifies how many cores the container can use: <code>--cpus=".5"</code> allows the container to use half of a core</li>
</ul></li>
<li>When containers are running in the background, it is not practical to check its activity live</li>
<li>The STDOUT and STDERR of a container can be inspected with the <code>docker logs --follow &lt;container&gt;</code> command</li>
<li>Containers can also be managed graphically using the open source tool Portainer</li>
</ul>
<h2 id="best-practices">Best Practices</h2>
<ul>
<li>In order to increase resiliency and allow for versioning and tracking of changes in software, it is important to use a version-control sistem like git</li>
<li>Git is a distributed version control system for tracking changes in source code during software development</li>
<li>A repository is a collection of all the files belonging to a project, including their history</li>
<li>Development typically takes place in branches
<ul>
<li>A branch is a line of development</li>
<li>In git, there is a main branch with the production code called “master”</li>
<li>Once a new feature is implemented in a branch, the branch can be merged to the master branch</li>
</ul></li>
</ul>
<h1 id="authentication-and-authorization-infrastructure-aai">Authentication and Authorization Infrastructure (AAI)</h1>
<ul>
<li>We typically want to protect our data or applications with some form of authentication (AuthN) and with various degrees of authorization (AuthZ) to access them</li>
<li>The simplest form of authentication to a resource is the use of a local username and password
<ul>
<li>This approach is local: every system stores its own set of credentials</li>
<li>In linux local credentials are stored in <code>/etc/passwd</code> and <code>/etc/shadow</code></li>
<li>This method is definitely NOT scalable</li>
</ul></li>
<li>The resources that we want to protect should have some form of Identity Management System (IdM)</li>
</ul>
<h2 id="x.500-dap-ldap">X.500, DAP, LDAP</h2>
<ul>
<li>In the early days, an IdM consisted of directories storing “objects” that described generic “entities”
<ul>
<li>One of such directories was basically a distributed database</li>
<li>This standard was defined in 1988 and came to be known as the X.500 standard</li>
</ul></li>
<li>The X.500 standard led to the definition of “The Directory”
<ul>
<li>It was a worldwide white page service accessed through a Directory Access Protocol (DAP) through the OSI stack</li>
<li>From a common root it was possible to access countries and organizations, and from those more specific groups until single individuals</li>
</ul></li>
<li>In the early 90’s, there was a long debate about the adoption of the OSI model or the TCP/IP model
<ul>
<li>The TCP/IP model was supported bu the US Department of Defence and won at the end</li>
<li>Now the OSI model is rarely used in practice but is an useful theoretical framework for how applications should work</li>
</ul></li>
<li>With the affirmation of TCP/IP, in order to access the X.500 Directory a simpler protocol than DAP was required
<ul>
<li>DAP was built with the OSI model in mind</li>
</ul></li>
<li>The protocol defined for accessing X.500 from TCP/IP is called LDAP (Lightweight DAP)
<ul>
<li>Despite its original use, it not only allows to lookup information in a directory service, but also for adding and updating it</li>
<li>Today nobody talks about X.500, but LDAP is still used!</li>
<li>Microsoft Active Directory can be accessed with LDAP</li>
<li>In LDAP data is kept in key:value pairs called attributes</li>
<li>Attributes are stored in a tree of entries</li>
<li>Each entry in LDAP has 3 components
<ul>
<li>A Distinguished Name (DN), an unique identifier</li>
<li>A collection of attributes where data is actually stored</li>
<li>A collection of object classes: information about the type of entry (a person, a service,…)</li>
</ul></li>
<li>LDAP is the simplest example of Attribute Authority
<ul>
<li>It is a place where authoritative information about something can be stored</li>
<li>We can use DAP to store all the information about the identity of a person (passwords, roles in the organization)</li>
</ul></li>
<li>LDAP can be used to enforce both authorization and authentication of users</li>
<li>In general, LDAP was born for authorization (i.e. storing which users can do what) and NOT for authentication
<ul>
<li>Authentication was implemented later, and every authentication request generates a load on the LDAP server
<ul>
<li>This can be problematic when there are many users or with some application that do not deal with authentication in a smart way</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="radius">RADIUS</h2>
<ul>
<li>Another commonly used protocol for IdM is RADIUS (Remote Authentication Dial-in User Service)
<ul>
<li>A RADIUS server sits between the user and other services: it is an intermediate service</li>
<li>RADIUS queries LDAP to assess the identity of a person, but then it can query other services for authenticating it (es. an OTP service)</li>
<li>It uses UDP and it is more flexible then LDAP (I can plug-in multiple services to RADIUS), but it is more complex to set up</li>
</ul></li>
</ul>
<h2 id="kerberos">Kerberos</h2>
<ul>
<li>Kerberos is a service that implements strong authentication for client/server applications based on secret-key criptography
<ul>
<li>It was developped at MIT</li>
<li>Usually Kerberos is used in parallel to LDAP to manage only the authentication part (while authorization is up to LDAP)
<ul>
<li>Kerberos manages the credentials for different users</li>
<li>LDAP stores authoritative information about what users are allowed to do</li>
<li>This approach is still widely used in computing and storage resources</li>
</ul></li>
<li>A client can contact a Kerberos server, which provides a signed encrypted ticket that can be used to access resources</li>
<li>The ticket is valid for some time, so this reduces the problem of overloading the authentication server</li>
<li>Kerberos is based on symmetric key criptography: the client and the server have a shared secret</li>
<li>Kerberos implements a Key Distribution Center (KDC)
<ul>
<li>It is a trusted party between client and server</li>
<li>It hosts secrets for all the users of the infrastructure</li>
</ul></li>
<li>Kerberos is used to implement Single Sign On (SSO) environments
<ul>
<li>A single login unlocks a range of different services</li>
<li>In AWS a single login unlocks EC2, S3,…</li>
</ul></li>
<li>Kerberos has a main issue: it relies on a TRUSTED KDC which holds all the secrets
<ul>
<li>If someone is able to compromise the KDC, then everithyng is compromised</li>
<li>This approach is not scalable because it would require mutual trust between different KDC servers: impossible on the internet</li>
</ul></li>
</ul></li>
</ul>
<h2 id="x.509">X.509</h2>
<ul>
<li>From the X.500 standard, a new standard called X.509 was created</li>
<li>It defines the format for public key certificates</li>
<li>An X.509 certificate contains a public key and an identity</li>
<li>Each X.509 certificate is either self-signed (signed by the private key corresponding to the public key included in the certificate) or signed by a Certificate Authority (CA)</li>
<li>Self-signed certificates are not so trustworthy</li>
<li>Certificate Authorities are a limited number of organizations that are well-known and act as a Trusted Party
<ul>
<li>They are used for-profit companies, but a notable exception is the non-profit Let’s Encrypt</li>
</ul></li>
<li>X.509 is widely used by TLS/SSL protocol, which is the basis of https</li>
<li>X.509 is also used for authenticating to GRID resources</li>
<li>X.509 is based on public key criptography (asymmetric cryptography)
<ul>
<li>The public key is known by everyone, while the private key is only known by the key owner</li>
<li>The private key should never be communicated to anyone</li>
<li>Public key criptography enables encryption (with the public key of the intended recipient) and decryption of data (by the recipient with its private key)</li>
<li>It also enables signing of data (nonnrepudiation): I can let others trust that some data came from be by encrypting it with my private key, and showing that it can be decrypted only with my public key</li>
</ul></li>
<li>Http transmission is in clear, and it uses the TCP port 80 (but it can also be configured to use other ports)</li>
<li>Https transmission is encrypted and it uses the TCP port 443 (but can be configured)</li>
</ul>
<h2 id="saml">SAML</h2>
<ul>
<li>Since now we saw LDPA and Kerberos for authenthication, and X.509 for htpps access, but these approaches are not suitable for authenticating to Cloud applications</li>
<li>SAML (Security Assertion Markup Language) is an open standard based on XML
<ul>
<li>It allows to share security credentials that can be used for authentication and authorization</li>
<li>It is a quite mature standard (from 2005)</li>
<li>Its primary use is that of implementing SSO for web applications</li>
<li>SAML is NOT well suited for mobile applications (es. to create an API gateway)</li>
</ul></li>
<li>eduGAIN (Global Academic Interfederation Service) is a SAML2-based federation of service providers
<ul>
<li>It enables transparent SSO for members of the research and education community</li>
<li>In Italy any service that wants to join eduGAIN must connect to the Italian Federation Identity (IDEM)
<ul>
<li>IDEM is managed by GARR</li>
</ul></li>
</ul></li>
<li>In Italy since 2013 SPID (Sistema Pubblico di Identità Digitale) was created as a SSO for citizens towards public institutions
<ul>
<li>SPID uses SAML2</li>
<li>There is a discussion about how SPID and eduGAIN/IDEM should interoperate, also because universities are public institutions and therefore should offfer their services through SPID</li>
</ul></li>
<li>Multi-Factor Authentication (MFA, also called 2FA) access to a resource is granted only after multiple credentials have been presented
<ul>
<li>It is a widespread practice used for increasing security</li>
<li>A best practice is to use MFA whenever using a service connected to the internet (especially for services holding private data)</li>
<li>MFA works by combining something that you know (password) with something that you have (an OTP, fingerprint, email address,…)</li>
</ul></li>
</ul>
<h2 id="oauth-and-openid-connect">OAuth and OpenID Connect</h2>
<ul>
<li>In order to authenticate and authorize services in the cloud, 2 newer protocols are used: OAuth and OpenID-Connect</li>
<li>OAuth is an authorization framework and does not deal with authentication
<ul>
<li>In OAuth an access token states the authorization rights of the client</li>
<li>SAML is typically used for enterprise SSO of web applications, while OAuth is designed for the authorization of generic applications or resources on the Internet</li>
<li>OAuth can be used for web applications but differently from SAML does not assume that the client is a web application</li>
</ul></li>
<li>In OAuth there are several roles
<ul>
<li>Resource owner: a user that own resources hosted at a service</li>
<li>Client: an application that wants to access resources</li>
<li>Authorization server: a service that authenticates user and client and issues access tokens accordingly</li>
<li>Resource server: a service that holds protected resources and grants access based on access tokens</li>
</ul></li>
<li>The first interaction of a client with the OAuth server involves the registration of the client
<ul>
<li>During the registration a client receivs an id and a secret</li>
</ul></li>
<li>OpenID-Connect (OIDC) handles authentication of users in the cloud
<ul>
<li>It is a simple identity layer on top of the OAuth protocol</li>
<li>It allows clients to verify the identity of an end user based on the authentication performed by an authrization server</li>
<li>It allows clients to obtain information about an user in an interopaerable REST-like manner</li>
<li>OIDC returns information on who an user is and how it was authenticated using an ID token
<ul>
<li>The ID token is a JSON Web Token (JWT)</li>
</ul></li>
</ul></li>
<li>OIDC/OAuth is used in most web services like Google, Facebook, Microsoft, GitHub</li>
<li>JSON Web Token is an open standard for securely transmitting information as JSON objects
<ul>
<li>JWT are usually signed and, if required, encrypted</li>
<li>A JWT contains an header, a payload and a signature</li>
<li>The header and payload are converted with base64 encoding</li>
<li>The signature uses an hashing algorithm to combine header, payload and a secret from the signer</li>
<li>If the signature does not match the content, the JWT is rejected</li>
</ul></li>
<li>Why to prefer OAuth, OIDC, and JWT to other solutions?
<ul>
<li>They are widely used, standard, not bound to any specific authentication system</li>
<li>They are scalable since they rely on distributed verification of access and identity tokens</li>
<li>They are driven and developped by industry, not research</li>
</ul></li>
<li>In general, for the Cloud we want an AAI twith certain characteristics
<ul>
<li>Open Source and uses widely adopted standards</li>
<li>Supports for enrollment and registration of users (and optionally self-registration)</li>
<li>It is able to link various credentials to a single identity</li>
<li>It is flexible: it should be possible to grant administration priviledges to users, add users to groups, manage membership requests, and edit user information</li>
<li>It is able to expose user and group information to applications that request them</li>
<li>Supports full auditing: keeps track of security events for legal and logging purposes</li>
</ul></li>
<li>Since OAuth/OIDC was developped by the industry, it does not completely fulfill the checklist of requirements of academic institutions
<ul>
<li>There is a trend in acedemia to develop AAI systems that extend the standard protocols</li>
</ul></li>
</ul>
<h2 id="indigo-iam">INDIGO-IAM</h2>
<ul>
<li>INDIGO-IAM was developped at INFN and implements SAML, X.509 and OIDC
<ul>
<li>Authentication is flexible: SAML, X.509, OIDC, or username and password</li>
<li>Accounts can be linked</li>
<li>It is a concrete implementation of the several protocols seen so far</li>
</ul></li>
<li>The authorization workflow with IAM for a web application
<ul>
<li>A web app integrates with IAM to delegate user authentication
<ul>
<li>OAuth and OIDC provide the authorization code flow for this process</li>
</ul></li>
<li>An user accesses the web app, that redirects back to IAM for authentication</li>
<li>The user does not have a valid session on IAM, so a login page is shown</li>
<li>The user logs in with one of the external providers (Google, eduGAIN) or with username and password</li>
<li>If the user chooses an external Identity Provider (IdP), he is redirected to the relevant login page</li>
<li>The home IdP (for the user) authenticates him and sends back an authentication assertion to IAM</li>
<li>IAM validates the assertion, and shows a consent page for authorizing the web app to obtain information on the user</li>
<li>IAM generates an authorization code and sends it back to the web app using http redirect</li>
<li>The web app shows to IAM its authorization code and receives from it an access token and an id token
<ul>
<li>In IAM these tokens are both JWT tokens</li>
<li>The access token provides mainly authorization information</li>
<li>The id token provides mainly authentication information</li>
</ul></li>
<li>IAM validates the tokens following the OIDC protocol</li>
<li>The application can request additional information by quering the <code>/userinfo</code> endpoint and presenting the acess token</li>
<li>IAM returns a JWT with content that can partially overlap with the id token</li>
</ul></li>
</ul>
<h1 id="cloud-automation">Cloud Automation</h1>
<ul>
<li>Cloud Automation is a set of processes and technologies that allow to automayte several operations related to cloud computing</li>
<li>Automation is tightly linked to reproducibility</li>
</ul>
<h2 id="microservices">Microservices</h2>
<ul>
<li>Microservices are a way to build applications as a collection of many small autonomous services</li>
<li>They are contrapposed to the old monolith architecture</li>
<li>Microservices are like cattle, while a monolith application is like a pet</li>
<li>In an organization, each microservice can be managed and developped by a specific team, which operates in an autonomous way and is responsible for the service</li>
<li>In a microservice architecture multiple independent processes communicate with each other through the network</li>
<li>Differently from monoliths, in a microservice architecture states are external to the application</li>
<li>In a monolith a business is organized as 1 large team per tier (backend, frontend, database)</li>
<li>With microservices there is a tendency to have 2 pizza teams (a team that is small enough to order only 2 pizzas) composed of people from different backgrounds (backend, frontend, database) that work on a specific task (orders, shipping, catalog)
<ul>
<li>Each team is directly responsible to the end user for its service</li>
</ul></li>
<li>Databases tend to not be monolytic but split: I have an account DB, an inventory DB, a shipping DB</li>
<li>Communication between microservices are typically done with REST APIs</li>
<li>Microservices are not perfect and sometimes a monolyt is preferrable
<ul>
<li>Deployment is more complex since each service must be deplyed independently</li>
<li>I need to worry about the orchestration of the services</li>
<li>There are more services to monitor</li>
</ul></li>
<li>However, microservices offer several advantages
<ul>
<li>They are more reliable, since there is no single point of failure</li>
<li>They are more scalable horizontally</li>
<li>Scaling can be granular and involve only the required components, and not necessarily the entire application</li>
</ul></li>
</ul>
<h2 id="devops">DevOps</h2>
<ul>
<li>DevOps (Development Operations) is a pattern developping scalable and applications where development and operation are tightly integrated</li>
<li>Instead of developping a production-ready application and deploying it, I follow a tight release and feedback schedule (release early, release often)</li>
<li>The continuous feedback allows to avoid unnecessary work and create something that the users will like</li>
<li>The main principle is to involve the end users in the project as early as possible</li>
<li>It uses a set of tools and processes to facilitate automation, monitoring, and continuous integration</li>
<li>DevOps is an example of risk reduction in software development</li>
<li>It is typically applicable to distributed microservices-based applications</li>
</ul>
<h2 id="continuous-approach">Continuous Approach</h2>
<ul>
<li>Continuous Integration is a software development practice where developpers frequently merge their code changes to a central repository, after which automated builds and tests are run</li>
<li>This approach produces deployment packages that can be used for deployment to multiple environments</li>
<li>Jenkins is a widely used tools for this scope</li>
<li>Even with interpreted languages that do not need compliation (Pyhton) it is possible to implement continuous development with automatic Quality Assurance tests
<ul>
<li>sloccount is a tool that counts the actual lines of code in a project</li>
<li>pylint is a static code analisys tool that looks for programming errors and helps enforcing a coding standard</li>
<li>pytest and nose2 are tools for writing tests for code coverage</li>
</ul></li>
<li>Continuous Deployment refers to the capability to deploy applications to a pre-production and production enviroment through automation</li>
<li>Continuous Delivery is a development practice where code changes are automatically built, tested, and prepared for release to production
<ul>
<li>The main aspect of Continuous Delivery is the automatic release to production, which extends the framework of Continuous integration</li>
</ul></li>
<li>Continuous learning involves a continuous feedback and improvement
<ul>
<li>Applications should be built with monitoring, auditing, and telemetry in mind</li>
<li>Telemetry is the remote monitoring of something</li>
</ul></li>
<li>Monitoring should start in the development phase, using the same tools adopted in production to spot problems before they hit the users
<ul>
<li>Monitoring refers to application performance monitoring and server monitoring</li>
</ul></li>
<li>A regular baseline for monitoring should be acquired, and metrics over a period of time should be compared to it</li>
<li>When scalable, reliable, and maintainable applications need to be deployed to the cloud, it is important to find a way to instantiate the resources needed by the application</li>
</ul>
<h2 id="docker-swarm">Docker Swarm</h2>
<ul>
<li>Containers are excellent for the creation of a microservice architecture</li>
<li>We saw already <code>docker-compose</code> for creating an application stack on a single host</li>
<li>Container orchestration instead refers to orchestrating many containers across distributed hosts</li>
<li>Docker Swarm is a simple way of orchestrating containers with Docker
<ul>
<li>It is integrated in the Docker engine and does not require additional software</li>
<li>It is decentralised: each node in the swarm can assume any role at runtime</li>
<li>It scales automatically according to load</li>
<li>It supports desired state reconciliation: if something happens to a Swarm cluster, it tries to bring the cluster back to its optimal state (if a container crashes a new one is istantiated)</li>
<li>It supports multi-host networking thanks to the use of an overlay network</li>
<li>It has service discovery thanks to a DNS server embedded in each Swarm
<ul>
<li>The Swarm manager discovers services and assigns to each of them a unique name</li>
</ul></li>
<li>It supports load balancing across nodes</li>
<li>It is secure since all the communication across nodes are encrypted TLS</li>
<li>It supports rolling updates and allows for rollback of tasks</li>
</ul></li>
<li>An overlay network is a way in which Docker can handle networking</li>
<li>A Swarm service is the definition of the tasks to be executed on a Swarm cluster</li>
<li>Defining a Swarm service means describing its optimal state
<ul>
<li>How many replicas I want for the service</li>
<li>Which storage resources should be available to it</li>
<li>How it connects to the network</li>
<li>Which ports should be exposed</li>
</ul></li>
<li>Any node that is part of a Swarm cluster can still run regular containers in addition to Swarm services</li>
<li>Differently from standaone containers, it is possible to modify the configuration of a Swarm cluster without bringing down the service</li>
<li>Docker Swarm services are persistent, while the load balancer is not</li>
</ul>
<h2 id="swarm-secrets-and-configs">Swarm Secrets and Configs</h2>
<ul>
<li>Writing and persisting application data for containers is not so simple</li>
<li>If I need to include a password or other sensitive data, I cannot store it in clear text in my docker-compose file, especially if I want to syncronise this file to a public CLoud like GitHub</li>
<li>Docker provides secretes for storing sensitive data that should not be transmitted over a network</li>
<li>Secrets are only available to Swarm services, not to standalone containers
<ul>
<li>They are encrypted at rest and only made available to running Swarm services that have been granted explicit access to them</li>
<li>They are never stored in clear text and only made available to Swarm services in memory (or in a RAM disk)</li>
</ul></li>
<li>If I want to use secrets in a standalone container, I can just create a Swarm of scale 1</li>
<li>Secrets should be used for usernames, passwords, ssh keys, and other important data</li>
<li>Non-sensitive information such as configuration files do not need to be stored in encrypted form</li>
<li>Docker provides for this scenario Swarm configs</li>
<li>They are like secrets but are not encrypted and they are not stored in RAM, but mounted directly into a container’s filesystem</li>
<li>Like secrets, also configs are only available to Swarm services and not to standalone containers</li>
</ul>
<h2 id="kubernetes">Kubernetes</h2>
<ul>
<li>Kubernetes (K8s) is another popular container orchestrator</li>
<li>It is open source and backed by Google and RedHat</li>
<li>A Kubernetes cluster is composed of a Master that coordinates the cluster and Nodes that run applications</li>
<li>A pod is the basic building block of Kubernetes and it represents a running process on a cluster
<ul>
<li>It encapsulates an application container, storage resources, a network IP and options that govern how the container should run</li>
</ul></li>
<li>The most common Kubernetes use case is that of a pod running a single container
<ul>
<li>In this case the pod can be thought of as a wrapper around the container</li>
</ul></li>
<li>A pod can also run multiple containers that need to cooperate
<ul>
<li>It can encapsulate a multi-container application</li>
<li>The pod in this case wraps the containers and the storage resources in a single manageable entity</li>
</ul></li>
<li>A kubernetes service is an abstraction that defines a logical set of pods and a policy by which to access it
<ul>
<li>Pods have IP adresses but they are not exposed outside of the cluster</li>
<li>Services on the contrary allow applications to receive traffic</li>
</ul></li>
<li>Deploying a Kubernetes cluster is not trivial, and because of this many clouds provide an already-configured Kubernetes cluster on which I can deploy my containers
<ul>
<li>This is known as “Kubernetes as a service”</li>
<li>AWS provides the “Elastic Container Service for Kubernetes” (EKS)</li>
<li>A Kubernetes cluster is composed of a control plane and a data plane</li>
<li>The control plane includes the masters, while the data plane includes the worker nodes</li>
<li>EKS provides a managed control plane that is automatically updated with new releases of the Kubernetes software</li>
</ul></li>
</ul>
<h2 id="docker-swarm-vs-kubernetes">Docker Swarm vs Kubernetes</h2>
<ul>
<li>Docker Swarm should be used for small projects and for prototyping, since it is easy to use for who is already familiar with Docker</li>
<li>Kubernetes is best for enterprise solutions, and it is also the Google way of dealing with microservices, but the learning curve is quite steep</li>
</ul>
<h2 id="infrastructure-as-code">Infrastructure as Code</h2>
<ul>
<li>Infrastructure as Code (IaC) refers to the definition of a computing infrastructure through a structred language
<ul>
<li>This is contrapposed to the manual creation of an infrastructure</li>
<li>IaC is based on the realization that “complexity kills productivity”</li>
<li>It simplifies the realization of complex infrastructures and set-ups</li>
<li>All the specifications for the infrastructure are written in configuration files</li>
</ul></li>
<li>The most popular IaC tools are Puppet, Ansible, Terraform, and Chef
<ul>
<li>Also Docker provides some form of IaC through Dockerfiles</li>
</ul></li>
<li>In general, it is important that whatever is done with code and data be reproducible and manageable
<ul>
<li>It is encouraged to use automated configuration and installation tools</li>
</ul></li>
<li>In IaC the focus is more on what I need than on how to create the infrastructure
<ul>
<li>This is achieved through templating mechanisms</li>
<li>This is linked to the concept of extending and reusing what is available instead of reinventing the wheel</li>
</ul></li>
<li>The Amazon way of doing IaC is the AWS CLoudFormation language
<ul>
<li>It defines the complete topology of an application</li>
<li>It is specific to Amazon and cannot be used with other Cloud providers</li>
</ul></li>
<li>TOSCA (Topology and Orchestration Specification for Cloud Applications) is a public standard
<ul>
<li>It is an OASIS standard language to describe the topology of cloud-based web services, their components, their relationships, and the processes managing them</li>
<li>It standardizes the language to describe the topology model (struvture of the IT service), orchestrate operational behaviour (build, deploy, patch, shutdown), and describes a declarative model that spans applications and infrastructures</li>
</ul></li>
<li>CloudFormation and TOSCA allow us to realize service composition (combine different services to implement complex topologies)
<ul>
<li>The INFN National Cloud is an example of service composition that provides a portfolio of services based on a set of core open source components, visible to the end user via simple configurable buttons
<ul>
<li>Each button underlies a TOSCA template</li>
<li>When a new service is needed, it is built starting from an existing TOSCA template and modifying it as appropriate</li>
</ul></li>
</ul></li>
</ul>
<h2 id="serverless-computing">Serverless Computing</h2>
<ul>
<li>In traditional cloud applications we need to provision and manage the resources, we are charged for the resource uptime even when they are idle, and we are responsible for updated and security patches</li>
<li>In the serverless paradigm, or FaaS (function as a service) the Cloud provider is responsible for executing a piece of code that you write by dynamically allocating the resources needed
<ul>
<li>You are only charged for the resources actually used and only when the code runs</li>
<li>Since code is typically structured in functions, serverless computing is also called FaaS</li>
</ul></li>
<li>The running of serverless functions can be triggered by some conditions (database events, file uploads, schedules, alerts,…)</li>
<li>The application should be structured in a set of stateless functions, consistently with the microservice paradigm</li>
<li>Functions in FaaS tend to have some core characteristics
<ul>
<li>Can be written in multiple languages</li>
<li>Are reusable</li>
<li>Do not implement long-running services (they typically do not expose any port)</li>
<li>Are stateless</li>
<li>May use existing services in variuos Cloud infrastructures</li>
<li>Execute rapidly (in AWS the timeout is 15 minutes)</li>
</ul></li>
<li>Nowadays FaaS is really popular because
<ul>
<li>It is the next step towards offering a service focused on the application</li>
<li>It extends the microservice paradigm</li>
<li>It can save costs by paying only for when my application is running</li>
</ul></li>
<li>However, there are some drawbacks
<ul>
<li>FaaS can be difficult to use and lead to vendor lock-in</li>
<li>It can be difficult to debug since it is distributed and dynamic</li>
<li>It can be difficult ot size and integrate</li>
</ul></li>
<li>AWS Lambda is the Amazon way of doing serverless computing</li>
<li>OpenFaaS is an open source solution to bring FaaS to any cloud infratructure
<ul>
<li>It allows you to write a function in any language and package it in a Docker container</li>
<li>The container can then be run in a Docker Swarm or in a Kubernetes cluster, or in a single host</li>
</ul></li>
<li>Functions can be synchronous or asynchronous
<ul>
<li>In a synchronous function the output is returned only when the execution of the function itself finishes</li>
<li>Asynchronous functions return immediately, and the otput is instead returned when ready</li>
</ul></li>
<li>OpenFaaS supports both synchronous and asynchronous functions</li>
<li>Serverless provides a significant improvement to machine learning
<ul>
<li>Pigo and OpenCV are popular toolkits to implement machine learning methods</li>
<li>From a Google paper “serverless technologies are believed to provide a significant simplification to solving ML problems, exactly because they allow to focus as much as possible on ML code and as little as possible on ‘glue code’ needed to provision the underlying layers (storage, compute, network, etc.)”</li>
</ul></li>
</ul>
