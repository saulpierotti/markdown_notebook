<h1 id="zeynep-kizyltan-module">Zeynep Kizyltan module</h1>
<hr />
<h1 id="math-backgroud">Math backgroud</h1>
<h2 id="sums">Sums</h2>
<ul>
<li>Finite sums  <img class="displaymath" src="eqn000.png" WIDTH=189 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{n}a_k  = a_1+a_2+...+a_n" /></li><li>Infinite sums  <img class="displaymath" src="eqn001.png" WIDTH=152 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{\infty}a_k  = a_1+a_2+..." /></li><li>Sums are linear  <img class="displaymath" src="eqn002.png" WIDTH=232 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{n}(ca_k+b_k)  = c\sum_{k=1}^{n}a_k + \sum_{k=1}^{n}b_k" /></li><li>The arithmetic series  <img class="displaymath" src="eqn003.png" WIDTH=247 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{n}k = 1+2+...+n=\frac{n(n+1)}{2}" /></li><li>The quadratic arithmentic series  <img class="displaymath" src="eqn004.png" WIDTH=318 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{n}k^2 = 1+4+...+n^2=\frac{n(n+1)(2n+1)}{6}" /></li><li>The cubic arithmetic series  <img class="displaymath" src="eqn005.png" WIDTH=273 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{n}k^3 = 1+8+...+n^3=\frac{n^2(n+1)^2}{4}" /></li><li>Arithmetic series of any power  <img class="displaymath" src="eqn006.png" WIDTH=108 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^n k^p \approx \frac{n^{p+1}}{p+1}" /></li><li>The geometric series  <img class="displaymath" src="eqn007.png" WIDTH=279 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{n}x^k = 1+x+x^2...+x^n=\frac{x^{n+1}-1}{x-1}" /></li><li>Infinite geometric series with base lower than 1  <img class="displaymath" src="eqn008.png" WIDTH=110 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{\infty}x^k = \frac{1}{1-x}" />  <img class="displaymath" src="eqn009.png" WIDTH=138 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^{\infty}kx^k = \frac{x}{(1-x)^2}" /></li><li>Logarithmic sum  <img class="displaymath" src="eqn010.png" WIDTH=133 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{k=1}^n \log{k} \approx n \log{n}" /></li></ul>
<h2 id="sets">Sets</h2>
<ul>
<li>Logic operations have specific symbols
<ul>
<li>Logic and:  <img class="inlinemath" src="eqn011.png" WIDTH=13 HEIGHT=13 STYLE="vertical-align: -1px; margin: 0;" alt="\land" /></li><li>Logic or:  <img class="inlinemath" src="eqn012.png" WIDTH=13 HEIGHT=13 STYLE="vertical-align: -1px; margin: 0;" alt="\lor" /></li><li>Logic not:  <img class="inlinemath" src="eqn013.png" WIDTH=13 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\lnot" /></li></ul></li>
<li>A set is a non-ordered and non repetitive collection of elements</li>
<li>A set is described by listing explicitly all of its elements inside curly braces  <img class="displaymath" src="eqn014.png" WIDTH=64 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=\{...\}" /></li><li>A member  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> of the set  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is an element that belongs to  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> ( <img class="inlinemath" src="eqn017.png" WIDTH=43 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x \in S" />)</li><li>A non-member  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> of the set  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is an element that does not belongs to  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> ( <img class="inlinemath" src="eqn019.png" WIDTH=42 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="y \not\in S" />)</li><li>2 sets are equal if they contain the same elements</li>
<li>The cardinality of a set  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, represented as  <img class="inlinemath" src="eqn020.png" WIDTH=21 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|S|" />, is the number of elements that it contains<ul>
<li>If the cardinality of a set is a natural number, the set is finite, otherwise it is infinite</li>
</ul></li>
<li>2 sets  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> and  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> are equal ( <img class="inlinemath" src="eqn023.png" WIDTH=49 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A=B" />) if they contain the same elements</li><li>The empty set  <img class="inlinemath" src="eqn024.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="E" /> is represented as  <img class="inlinemath" src="eqn025.png" WIDTH=84 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="E=\{\}=\emptyset" /> and it respect the condition  <img class="inlinemath" src="eqn026.png" WIDTH=54 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|E|=0" /></li><li>If  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> contains all the elements contained in  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" />, then  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> is a subset of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />  <img class="displaymath" src="eqn027.png" WIDTH=313 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(x \in A \implies x \in B \quad \forall \ x\in A) \iff B \subseteq A" /></li><li>If  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> contains all the elements contained in  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> but  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> and  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> are not equal, then  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> is a proper subset of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /></li><li>The universe  <img class="inlinemath" src="eqn028.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="U" /> is a set including all the possible elements  <img class="displaymath" src="eqn029.png" WIDTH=223 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="B \subseteq A \ \land \ A\not=B \iff B \subset A" /></li></ul>
<h2 id="basic-set-operations">Basic set operations</h2>
<ul>
<li>Set intersection  <img class="displaymath" src="eqn030.png" WIDTH=209 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A \cap B = \{x:x \in A \land x \in B\}" /></li><li>Set union  <img class="displaymath" src="eqn031.png" WIDTH=209 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A \cup B = \{x:x \in A \lor x \in B\}" /></li><li>Set difference  <img class="displaymath" src="eqn032.png" WIDTH=211 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A-B = \{x:x \in A \land x \not\in B\}" /></li><li>Set complement  <img class="displaymath" src="eqn033.png" WIDTH=185 HEIGHT=19 STYLE="vertical-align: -3px; margin: 0;" alt="A' = U-A \text{ where } A \subseteq U" /></li></ul>
<h2 id="set-laws">Set laws</h2>
<ul>
<li>Empty set laws  <img class="displaymath" src="eqn034.png" WIDTH=71 HEIGHT=17 STYLE="vertical-align: -2px; margin: 0;" alt=" A \cap \emptyset = \emptyset" />  <img class="displaymath" src="eqn035.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -2px; margin: 0;" alt=" A \cup \emptyset = A" /></li><li>Idempotency laws  <img class="displaymath" src="eqn036.png" WIDTH=144 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt=" A \cap A = A \cup A = A" /></li><li>Commutative laws  <img class="displaymath" src="eqn037.png" WIDTH=112 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt=" A \cap B = B \cap A" />  <img class="displaymath" src="eqn038.png" WIDTH=112 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt=" A \cup B = B \cup A" /></li><li>Associative laws  <img class="displaymath" src="eqn039.png" WIDTH=199 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" A \cap (B \cap C) = (A \cap B) \cap C" />  <img class="displaymath" src="eqn040.png" WIDTH=199 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" A \cup (B \cup C) = (A \cup B) \cup C" /></li><li>Distributive laws  <img class="displaymath" src="eqn041.png" WIDTH=242 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" A \cap (B \cup C) = (A \cap B) \cup (A \cap C)" />  <img class="displaymath" src="eqn042.png" WIDTH=242 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" A \cup (B \cap C) = (A \cup B) \cap (A \cup C)" /></li><li>De Morgan’s laws  <img class="displaymath" src="eqn043.png" WIDTH=135 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" (A \cap B)'=A' \cup B'" />  <img class="displaymath" src="eqn044.png" WIDTH=135 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" (A \cup B)'=A' \cap B'" /></li><li>Two sets are disjoint if their intersection is the empty set</li>
</ul>
<h2 id="other-set-operations-and-definitions">Other set operations and definitions</h2>
<ul>
<li>A collection of nonempty sets  <img class="inlinemath" src="eqn045.png" WIDTH=88 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_1, S_2, ..., S_n" /> is a partition of the set  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> if<ul>
<li>All the sets  <img class="inlinemath" src="eqn045.png" WIDTH=88 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_1, S_2, ..., S_n" /> are pairwise disjoint  <img class="displaymath" src="eqn046.png" WIDTH=299 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" S_i \cap S_j = \emptyset \qquad \forall \ i,j = 1,2,...,n \qquad i \not= j" /></li><li>Their unioun gives S  <img class="displaymath" src="eqn047.png" WIDTH=102 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" \cup_{S_i \in S} \ S_i = S" /></li></ul></li>
<li>The power set  <img class="inlinemath" src="eqn048.png" WIDTH=38 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="P(S)" /> is the set of all subset of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, including the empty set and  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> itself  <img class="displaymath" src="eqn049.png" WIDTH=91 HEIGHT=23 STYLE="vertical-align: -5px; margin: 0;" alt="|P(S)| = 2^{|S|}" /></li><li>The cartesian product of 2 sets is a set containing all possible pairs of elements  <img class="displaymath" src="eqn050.png" WIDTH=234 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" A \times B = \{(a,b): a \in A \land b \in B\}" />  <img class="displaymath" src="eqn051.png" WIDTH=137 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" |A \times B| = |A|*|B|" /></li><li>The cartesian product of n sets is a set of n-tuples</li>
</ul>
<h2 id="relations">Relations</h2>
<ul>
<li>A binary relation  <img class="inlinemath" src="eqn052.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="R" /> on two sets  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> and  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> is a subset of their cartesian product  <img class="displaymath" src="eqn053.png" WIDTH=82 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="R \subseteq A \times B" /></li><li>The relation  <img class="inlinemath" src="eqn054.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(a,b) \in R" /> can be written as  <img class="inlinemath" src="eqn055.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="a\ R\ b" /> <ul>
<li>If I have a relation  <img class="inlinemath" src="eqn056.png" WIDTH=40 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="a \leq b" /> on natural numbers  <img class="inlinemath" src="eqn057.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="N" />, this means  <img class="inlinemath" src="eqn058.png" WIDTH=181 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\{(a,b): a, b \in N \land a \leq b\}" /></li><li>I can also write  <img class="inlinemath" src="eqn059.png" WIDTH=130 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="a \leq b = (a,b) \in \ \leq" /></li></ul></li>
<li>A relation  <img class="inlinemath" src="eqn052.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="R" /> on  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> sets  <img class="inlinemath" src="eqn061.png" WIDTH=95 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="A_1, A_2, ..., A_n" /> is a subset of  <img class="inlinemath" src="eqn062.png" WIDTH=134 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="A_1 \times A_2 \times ... \times A_n" /></li><li>A relation  <img class="inlinemath" src="eqn063.png" WIDTH=82 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="R \subseteq A \times A" /> is reflexive if each element is in that relation with itself  <img class="displaymath" src="eqn064.png" WIDTH=115 HEIGHT=16 STYLE="vertical-align: -2px; margin: 0;" alt="a\ R\ a \quad  \forall\ a \in A" /> <ul>
<li> <img class="inlinemath" src="eqn065.png" WIDTH=59 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="=, \leq, \geq" /> are reflexive relations in  <img class="inlinemath" src="eqn057.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="N" /> but  <img class="inlinemath" src="eqn066.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -4px; margin: 0;" alt="&lt;, &gt;" /> are not</li></ul></li>
<li>A relation is symmetric if it works both ways  <img class="displaymath" src="eqn067.png" WIDTH=211 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" a\ R\ b \implies b\ R\ a \quad \forall\ a,b \in A" /> <ul>
<li> <img class="inlinemath" src="eqn068.png" WIDTH=19 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="=" /> is a symmetric relation in  <img class="inlinemath" src="eqn057.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="N" /></li></ul></li>
<li>A relation is transitive if  <img class="displaymath" src="eqn069.png" WIDTH=281 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="a\ R\ b \land b\ R\ c \implies a\ R\ c \quad \forall \ a,b,c \in A" /> <ul>
<li> <img class="inlinemath" src="eqn070.png" WIDTH=99 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="=, \leq, \geq, &lt;, &gt;" /> are transitive relations in  <img class="inlinemath" src="eqn057.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="N" /></li></ul></li>
<li>A relation is antisymmetric if symmetry exists only among equal elements  <img class="displaymath" src="eqn071.png" WIDTH=267 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="a\ R\ b \land b\ R\ a \implies a = b \quad \forall \ a,b \in A" /> <ul>
<li> <img class="inlinemath" src="eqn072.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\leq" /> is an antisymmetric relation in  <img class="inlinemath" src="eqn057.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="N" /></li></ul></li>
<li>A relation that is reflexive, antisymmetric and transitive is said partial order</li>
<li>A set in which a partial order is defined is called partially ordered set</li>
<li>A partial order  <img class="inlinemath" src="eqn052.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="R" /> on the set  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is a total order if  <img class="displaymath" src="eqn073.png" WIDTH=201 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" \forall\ a,b \in A\qquad a\ R\ b \lor b\ R\ a" /></li></ul>
<h2 id="functions">Functions</h2>
<ul>
<li>A function  <img class="inlinemath" src="eqn074.png" WIDTH=36 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f\colon A" />, given 2 sets  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> and  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> is defined as a subset of their cartesian product such that there is one and only one element of  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> for each element of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> such that their are related by  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" />  <img class="displaymath" src="eqn076.png" WIDTH=288 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" f \subseteq A \times B\colon\ \forall\ a \in A\ \exists!\ b \in B\colon\ a,b \in f" /> <ul>
<li> <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is the domain of  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" />,  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> its codomain</li><li>We can write  <img class="inlinemath" src="eqn077.png" WIDTH=75 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f\colon A \to B" /> to represent the function</li><li>If  <img class="inlinemath" src="eqn078.png" WIDTH=55 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="a,b \in f" /> we can write  <img class="inlinemath" src="eqn079.png" WIDTH=62 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(a) = b" /> <ul>
<li> <img class="inlinemath" src="eqn080.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="a" /> is called argument of  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> and  <img class="inlinemath" src="eqn081.png" WIDTH=9 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="b" /> is called image of  <img class="inlinemath" src="eqn080.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="a" /> under  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /></li></ul></li>
</ul></li>
<li>2 functions are equal if they have the same domain and codomain and their image is equal for every argument  <img class="displaymath" src="eqn082.png" WIDTH=416 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" f = g \iff f\colon A \to B, g\colon A \to B \land f(a)=g(a)\quad \forall\ a \in A" /></li><li>The range of a function  <img class="inlinemath" src="eqn083.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(A)" /> if a function  <img class="inlinemath" src="eqn077.png" WIDTH=75 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f\colon A \to B" /> is the set of possible values that it can produce as output  <img class="displaymath" src="eqn084.png" WIDTH=246 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(A) = \{b \in B\colon b=f(a) \land a \in A\}" /></li><li>It is different from the codomain since it includes only the values that can actually be taken by the function
<ul>
<li>In  <img class="inlinemath" src="eqn085.png" WIDTH=163 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f\colon N \to N\colon f(n)=2n" />  <img class="inlinemath" src="eqn057.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="N" /> is the codomain but the range is represented by only the even numbers in  <img class="inlinemath" src="eqn057.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="N" /></li></ul></li>
<li>A function is an injection if it maps one-to-one elements in the domain and codomain  <img class="displaymath" src="eqn086.png" WIDTH=338 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f\colon A \to B\colon f(a) = f(b) \implies a = b \quad \forall\ a,b \in A" /></li><li>A function is a surjection if its range is equal to its codomain (if for each element in the codomain there is an argument that can produce it)  <img class="displaymath" src="eqn087.png" WIDTH=242 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f\colon A \to B\colon \exists\ a\colon f(a) = b\ \forall\ b \in B" /></li><li>A function is a bijection if it is both a surjection and an injection
<ul>
<li>For a bijection the inverse function  <img class="inlinemath" src="eqn088.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -4px; margin: 0;" alt="f^{-1}" /> is defined  <img class="displaymath" src="eqn089.png" WIDTH=187 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="f^{-1}(b) = a \iff f(a) = b" /></li></ul></li>
</ul>
<h2 id="floors-and-ceilings">Floors and ceilings</h2>
<ul>
<li>The floor of a number is the greatest integer less than or equal to it  <img class="displaymath" src="eqn090.png" WIDTH=24 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \lfloor x \rfloor " /></li><li>The ceiling of a number is the smallest integer greater than or equal to it  <img class="displaymath" src="eqn091.png" WIDTH=24 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \lceil x \rceil " /></li><li>For all real numbers  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />  <img class="displaymath" src="eqn092.png" WIDTH=222 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" x-1 &lt; \lfloor x \rfloor \leq x \leq \lceil x \rceil &lt; x+1" /></li><li>For any integer  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />  <img class="displaymath" src="eqn093.png" WIDTH=135 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \lfloor n/2 \rfloor + \lceil n/2 \rceil = n" /></li></ul>
<h1 id="introduction-on-algorithms">Introduction on algorithms</h1>
<ul>
<li>The word algorithm comes from the name of the persian scientist Muhammad ibn Musa al-Khwaruzmi
<ul>
<li>He lived in Uzbekstan and wrote Algoritmi de numero Indorum, wrongly understood as a latin plural</li>
<li>He was also the founder of algebra (from al-jabr, a procedure to solve quadratic equations)</li>
</ul></li>
<li>First algorithms were written by Babylonian in 1600 BC</li>
<li>Study of algorithms dates to Euclid in 300 BC</li>
<li>Modern algortihms study started in 1920 and was formalized in 1930 by Turing and Church (matematicians)</li>
<li>Many algos were discovered recently also by students</li>
<li>An algorithm is a finite series of steps that solves a problem</li>
<li>In CS, an algorithm is a well defined computational procedure that takes some inputs, follows a series of steps and eventually produces outputs in order to solve a computational problem</li>
<li>Algorithms are for humans, while a program is for a computer</li>
<li>Algorithms are written in pseudocode, which follow specific conventions</li>
<li>A problem can be solved by many algorithms</li>
<li>An algorithm can be implemented in many different programs</li>
<li>Fundamental properties of algorithms
<ul>
<li>Inputs can be 0 or more</li>
<li>Outputs are always 1 or more</li>
<li>An algorithm should be clearly defined and unanbiguous</li>
<li>It should terminate after a finite number of steps</li>
<li>All operations described must be basic, meaning that they can be solved exactly and in finite time</li>
</ul></li>
<li>Correct algorithms are necessary to solve computational problems</li>
<li>Efficient algorithms are necessary to solve computational problems with the available resources</li>
<li>An algorithm is correct if for every input, it halts with the correct output</li>
<li>An incorrect algorithm does not halt or halts with incorrect results on at least 1 instance
<ul>
<li>In some cases they are still useful, if I can control their error rate</li>
</ul></li>
<li>The correctness of an algorithm is difficult to prove
<ul>
<li>Showing correctness in one instance is not a guarantee of correctness in every instance</li>
<li>I can prove correctness by testing instances only if the possible number of instances is finite</li>
</ul></li>
<li>Published algorithms needs to have a mathematical proof of correctness that shows that, for any given valid input, it halts with an output that is a solution for the problem</li>
<li>An algorithm without proof is an heuristic procedure that is not guaranteed to be correct</li>
</ul>
<h1 id="introduction-on-data-structures">Introduction on data structures</h1>
<ul>
<li>A data structure is a way to store and organise data so to facilitate its access and modification</li>
<li>A data structure is a way to represent and organize data needed to solve a problem</li>
<li>Algorithm efficiency is affected by the choice of data structures</li>
</ul>
<h1 id="pseudocode">Pseudocode</h1>
<ul>
<li>Pseudocode is a way of representing an algorithm intended for human reading</li>
<li>It has a syntax similar to that of many popular programming languages</li>
<li>It provides a compact, semi-formal, high-level description of an algorithm</li>
<li>In pseudocode I can omit environment-based details that are not essential to the human understanding the algorithm</li>
<li>Variables are always local to the given procedure, not global</li>
<li>Reserved words with special meaning are written in <strong>bold</strong></li>
<li><strong>return</strong> trasnfers control back to the point of call and can optionally return a value</li>
<li><strong>error</strong> indicates that an error occurred
<ul>
<li>There is no need to specify how the error should be handled, since this is managed by the calling procedure</li>
</ul></li>
<li>Some constructs</li>
<li>Assignment of the value  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> to the variable  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> is represented as  <img class="inlinemath" src="eqn096.png" WIDTH=37 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i = j" /></li><li>The conditional statement of equivalence is  <img class="inlinemath" src="eqn097.png" WIDTH=49 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i == j" /></li><li>Comments are written after <code>//</code></li>
<li>Block structure is represented with indentation</li>
<li>In our pseudocode we start array counters from 1 instead of 0 since it is easier to understand</li>
<li>Elements in an array are accessed by placing the index in squared brackets after the name of the array
<ul>
<li> <img class="inlinemath" src="eqn098.png" WIDTH=30 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[3]" /> gives the third element of the array  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /></li></ul></li>
<li>A slice of an array is indicated as  <img class="inlinemath" src="eqn099.png" WIDTH=52 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[3...5]" /></li><li>There is no colon/semicolon at the end of lines</li>
<li>Attributes of objects are indicated as <code>object_name.attribute</code>
<ul>
<li>The lenght of an array can be indicated as <code>A.lenght</code></li>
</ul></li>
</ul>
<h1 id="algorithm-design-approaches">Algorithm design approaches</h1>
<ul>
<li>Incremental approach: add one element at a time</li>
<li>Divide and conquer: divide into subproblems, solve them and combine their solutions
<ul>
<li>It is inspired by the political control tactique of making your enemies fight against each other for controlling them</li>
<li>The divide step involves dividing the problem in sub-problems of smaller size</li>
<li>The conquer step involves solving the sub-problems recursively
<ul>
<li>If the sub-problem is too big I break it into sub-sub-problems (recursive case)</li>
<li>If it is small enough I solve it directly (base case)</li>
</ul></li>
<li>The combine step uses the solutions of the elementary problems to give a solution of the original problem</li>
</ul></li>
</ul>
<h1 id="algorithm-analysis">Algorithm analysis</h1>
<ul>
<li>Efficiency is related to the ability of an algorithm to be executed with available resources</li>
<li>Resources are time and memory</li>
<li>CPU time is number of instruction divided by number of istructions per unit time
<ul>
<li>It is hardware-dependent</li>
</ul></li>
<li>Running time is the number of primitive operations to be performeda before termination, in proportion to the input size
<ul>
<li>A primitive operation is an arithmetic operation, data movement, comparison, decision (if)</li>
</ul></li>
<li>Generally when referring to the time complexity of an algorithm this is measured in running time, not CPU time</li>
<li>The algorithm influences time much more than hardware, so we do not focus on hardware</li>
<li>Time and memory are bounded resources and must be used wisely</li>
<li>The input size is the number of elements in the input</li>
<li>A running time  <img class="inlinemath" src="eqn100.png" WIDTH=40 HEIGHT=19 STYLE="vertical-align: -3px; margin: 0;" alt="\geq n^2" /> is unacceptable for large inputs</li><li>In a while and for loop, the test is always executed once more than the body</li>
<li>Analysing algorithms is useful for predicting the amount of resources required for running them and for selecting the most efficient one</li>
<li>We assume that instructions are executed sequentially and that each instructuon is simple and commonly found in real CPU instruction sets</li>
<li>One instructuion is assumed to require constant time</li>
<li>The running time of an algorithm is the proportionality between the input size and the number of primitive instructions executed</li>
<li>Caution note: the test of a loop is always executed once more than the body</li>
</ul>
<h2 id="order-of-growth">Order of growth</h2>
<ul>
<li>In running time analyses we can ignore constants, since we are interested in the asymptotic behaviour of the algorithm</li>
<li>I can focus only on the leading term, since the others are relatively insignificant</li>
<li>In general I am interested in the limiting behaviour of the algorithm as the input size increases</li>
</ul>
<h2 id="limiting-behaviour-of-functions">Limiting behaviour of functions</h2>
<ul>
<li>There are different notations to define the behaviour of functions</li>
<li>The  <img class="inlinemath" src="eqn101.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Theta" /> (theta) notation signifies asymptotic equality  <img class="displaymath" src="eqn102.png" WIDTH=552 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \Theta(g(n))= \{f(n): \exists (c_1, c_2, n_0 &gt; 0)\colon 0 \leq c_1*g(n)\leq f(n) \leq c_2*g(n) \quad \forall \ n \geq n_0\}" /> <ul>
<li>For a function  <img class="inlinemath" src="eqn103.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n)" /> having a certain  <img class="inlinemath" src="eqn101.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Theta" /> notation there are 2 constant that multiplied for the  <img class="inlinemath" src="eqn101.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Theta" /> function are constantly greater or smaller than  <img class="inlinemath" src="eqn103.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n)" /> for  <img class="inlinemath" src="eqn104.png" WIDTH=50 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="n \geq n_0" /></li><li>It provides a tight bound</li>
<li> <img class="inlinemath" src="eqn105.png" WIDTH=57 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(g(n))" /> is the set of functions with the same order of growth as  <img class="inlinemath" src="eqn106.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="g(n)" /></li></ul></li>
<li>The  <img class="inlinemath" src="eqn107.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="O" /> (big-O) notation indicates an upper bound for the asymptotic behaviour  <img class="displaymath" src="eqn108.png" WIDTH=453 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" O(g(n))= \{f(n): \exists (c, n_0 &gt; 0)\colon 0 \leq f(n) \leq c*g(n) \quad \forall \ n \geq n_0\}" /> <ul>
<li>The formal definiton is similar to that of  <img class="inlinemath" src="eqn101.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Theta" />, but instead of a tight bound I only search for an upper bound</li><li> <img class="inlinemath" src="eqn109.png" WIDTH=58 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(g(n))" /> is the set of functions with the same or smaller order of growth as  <img class="inlinemath" src="eqn106.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="g(n)" /></li><li>It provides an asymptotic upper bound</li>
</ul></li>
<li>The  <img class="inlinemath" src="eqn110.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Omega" /> (big-Omega) notation indicates a lower bound for the function  <img class="displaymath" src="eqn111.png" WIDTH=452 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \Omega(g(n))= \{f(n): \exists (c, n_0 &gt; 0)\colon 0 \leq c*g(n) \leq f(n) \quad \forall \ n \geq n_0\}" /> <ul>
<li> <img class="inlinemath" src="eqn112.png" WIDTH=56 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Omega(g(n))" /> is the set of functions with the same or larger order of growth as  <img class="inlinemath" src="eqn106.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="g(n)" /></li><li>It provides an asymptotic lower bound</li>
</ul></li>
<li>An important theorem: a  <img class="inlinemath" src="eqn101.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Theta" /> bound implies both a lower and upper bound  <img class="displaymath" src="eqn113.png" WIDTH=398 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n) = \Theta(g(n)) \iff f(n) = O(g(n)) \land f(n) = \Omega(g(n))" /></li><li>The  <img class="inlinemath" src="eqn114.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="o" /> and  <img class="inlinemath" src="eqn115.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\omega" /> (small-O and small-Omega) notation are equivalent to the big-O and big-Omega notations but require a strict inequality ( <img class="inlinemath" src="eqn116.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -4px; margin: 0;" alt="&gt;, &lt;" />) instead of a  <img class="inlinemath" src="eqn117.png" WIDTH=39 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="\geq, \leq" /> <ul>
<li>They define bounds which are not asymptotically tight</li>
</ul></li>
<li>If I say that  <img class="inlinemath" src="eqn118.png" WIDTH=111 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n) = \Theta(g(n))" /> I mean that  <img class="inlinemath" src="eqn119.png" WIDTH=110 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n) \in \Theta(g(n))" />, and in the same way for  <img class="inlinemath" src="eqn107.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="O" /> and  <img class="inlinemath" src="eqn110.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Omega" /> notation</li><li>When I use one of these notations in an equation, I want to indicate a generic function with that asymptotic behavior</li>
<li>In general , there is no unique set of constants that satisfies this notations: It is enough to find 1 set of constants that works</li>
</ul>
<h3 id="limiting-behaviour-of-notable-functions">Limiting behaviour of notable functions</h3>
<ul>
<li>Any positive polynomial is faster than a polylogarithmic function</li>
<li>The logarithm of a factorial is  <img class="inlinemath" src="eqn120.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n\log{n})" /></li><li>Factorials are faster than exponentials, but slower than  <img class="inlinemath" src="eqn121.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="n^n" />!</li></ul>
<h2 id="recurrence-equations">Recurrence equations</h2>
<ul>
<li>A recurrence equation describes a function in terms of its value on a smaller input termine a tight bound</li>
</ul>
<h3 id="iteration-method">Iteration method</h3>
<ul>
<li>I take as an example the following recurrence equation  <img class="displaymath" src="eqn122.png" WIDTH=136 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" T(n) = T(n/2)+c" /></li><li>I expand the recurrence to look at its structure  <img class="displaymath" src="eqn123.png" WIDTH=517 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)=T(n/2)+c \implies T(n/2)=T(n/4)+c \implies T(n)=T(n/4)+2c" /></li><li>I imagine to continue this until I get to the base case  <img class="inlinemath" src="eqn124.png" WIDTH=34 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T(1)" /></li><li>The base case will occur when the argument of the function is  <img class="inlinemath" src="eqn125.png" WIDTH=9 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="1" /></li><li>I am halving the input at each recursion, so at recursion call  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> the size of the input is  <img class="inlinemath" src="eqn127.png" WIDTH=17 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^k" /></li><li>If I start from an original input size  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />, the base case happens when the argument is  <img class="displaymath" src="eqn128.png" WIDTH=224 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="n/n=n/2^k=1 \implies k=\log{n}" /></li><li>So I can solve for  <img class="inlinemath" src="eqn129.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)" /> as  <img class="displaymath" src="eqn130.png" WIDTH=152 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)=T(n/2^k)+kc" />  <img class="displaymath" src="eqn131.png" WIDTH=314 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)=c\log{n}+T(n/2^{\log{n}})=c\log{n}+T(1)" /></li><li>Therefore the running time is  <img class="displaymath" src="eqn132.png" WIDTH=250 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)=\Theta(\log{n})+\Theta(1)=\Theta(\log{n})" /></li></ul>
<h3 id="recursion-tree-method">Recursion tree method</h3>
<ul>
<li>I convert the equation into a tree and sum up the cost of each node for each level</li>
<li>The cost at each level is the cost icurred at that recursion level</li>
<li>I then sum up the cost for all the levels</li>
<li>I take as an example the following recurrence equation  <img class="displaymath" src="eqn133.png" WIDTH=152 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)=2T(n/2)+n^2" /></li><li>The root has a cost  <img class="inlinemath" src="eqn134.png" WIDTH=18 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="n^2" /></li><li>The first level has a cost  <img class="displaymath" src="eqn135.png" WIDTH=135 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="2T(n/2)=2(n/2)^2" /></li><li>The second level has a cost  <img class="displaymath" src="eqn136.png" WIDTH=135 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="4T(n/4)=4(n/4)^2" /></li><li>I see that in general, level at depth  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> has a cost  <img class="displaymath" src="eqn137.png" WIDTH=154 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="2^iT(n/2^i)=2^i(n/2^i)^2" /></li><li>I continue to expand until the base case  <img class="displaymath" src="eqn138.png" WIDTH=314 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="T(n/2^i)=T(1) \implies 2^i=n \implies i=\log_2{n}" />  <img class="displaymath" src="eqn139.png" WIDTH=428 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="T(n/2^{\log_2{n}})=2^{\log_2{n}}T(n/\log_2{n})^2=2^{\log_2{n}}T(1)^2=2^{\log_2{n}}T(1)" /></li><li>So the total cost will be  <img class="displaymath" src="eqn140.png" WIDTH=602 HEIGHT=52 STYLE="vertical-align: -20px; margin: 0;" alt="T(n)=\sum_{i=0}^{\log_2{n}-1}(\frac{n}{2^i})^2+2^{\log_2{n}}T(1)=n^2\sum_{i=0}^{\log_2{n}-1}(\frac{1}{2})^{2i}+O(n) \leq n^2 \sum_{i=0}^\infty (\frac{1}{2})^{2i}+O(n)= O(n^2)" /></li></ul>
<h1 id="basic-data-structures">Basic data structures</h1>
<h2 id="arrays">Arrays</h2>
<ul>
<li>An array is a data structure consisting of a group of similar elements accessed by indexing</li>
<li>They typically have a fixed size that cannot change after their storage has been allocated</li>
<li>An array provides direct access to data:  <img class="inlinemath" src="eqn141.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i]" /> contains the element  <img class="inlinemath" src="eqn142.png" WIDTH=15 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="a_i" /></li><li>Every array is created empty by declaring its size, and then it is filled by assginment</li>
<li>Each location in the array can be accessed and modified in constant time</li>
<li>Arrays are easy to use and they can implement many more complex data structures</li>
<li>They are fast for direct access to a defined location</li>
<li>With arrays their size is fixed and needs to be specified at initialization time</li>
<li>The reorganization of data in an array is complex and costly</li>
<li>It is really inflexible for organising data</li>
<li>However, I cannot implement every possible data structure with arrays</li>
</ul>
<h2 id="trees">Trees</h2>
<ul>
<li>A tree is a set of nodes connected by edges such that there is one and only one way to get to go from one node to another</li>
<li>A tree is an acyclic graph</li>
<li>A forest is a set containing trees</li>
<li>Any non-empty tree with n nodes has n-1 edges
<ul>
<li>If this is not true, we don’t have a tree</li>
</ul></li>
<li>A tree is rooted if one of its nodes is distinguished as root
<ul>
<li>It can be defined recursively such that every non-root node of a rooted tree is itself the root of a subtree</li>
<li>The base case of the recursive definition of root is when the subtrees are empty: in this case the current node is a leaf</li>
</ul></li>
<li>Tree terminology is similar to that of ancestry trees: parents, ancestors, , children, descendant, sibilings
<ul>
<li>Among the ancestors of a node it is included the node itself</li>
<li>The proper ancestors of a node are its ancenstors minus the node itself</li>
<li>All the ancestors of a node form a path from the node to the root</li>
</ul></li>
<li>Nodes can be leaves or internal nodes
<ul>
<li>A leaf is a node whose subtrees are empty</li>
</ul></li>
<li>The depth of a node is the lenght of the path from it it the root (number of edges)</li>
<li>The height of a node is the lenght of the longest path from it to a leaf</li>
<li>The height of a tree is the height of its root</li>
<li>A sub-tree is formed by a node and all of its descendants</li>
<li>An ordered tree is a rooted tree in which the children of each node are ordered according to some criterion</li>
<li>A binary tree is an ordered tree which is empty or consists of a root node and 2 sub-trees wich are themselves binary trees</li>
<li>A full binary tree is a binary tree in which each node is either a leaf or it has degree exactly 2</li>
<li>A complete binary tree is a full binary tree in which all leaves have the same depth and all the internal nodes have exactly degree 2</li>
</ul>
<h2 id="heaps">Heaps</h2>
<ul>
<li>An heap is a nearly complete binary tree with peculiar properties</li>
<li>Structural property: all nodes of an heap are binary except for possibly the last level, that is filled always from left to righ</li>
<li>Heap property: the key of a parent must always be greter that that of its children (except for the root, that has no parent)  <img class="displaymath" src="eqn143.png" WIDTH=131 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" Parent(i) \geq i \quad \forall i" /> <ul>
<li>This is a max heap, there are also min heaps where the property is opposite</li>
<li>The maximum element of an heap is always the root</li>
</ul></li>
<li>The size of an heap is the number of nodes it contains</li>
<li>The heigh of an heap of size  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> is  <img class="inlinemath" src="eqn144.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\lfloor \log{n} \rfloor" /> <ul>
<li>I use the floor and not the ceiling since the root has level 0</li>
</ul></li>
<li>We can represent an heap with an array
<ul>
<li>The first element is the root</li>
<li>The children of the root are the second and third element</li>
<li>The fourth and fifth element are the children of the second, and so on</li>
</ul></li>
<li>The children of node  <img class="inlinemath" src="eqn141.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i]" /> are nodes  <img class="inlinemath" src="eqn145.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[2i]" /> (left child) and  <img class="inlinemath" src="eqn146.png" WIDTH=64 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[2i+1]" /> (right child)</li><li>The parent of  <img class="inlinemath" src="eqn141.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i]" /> is  <img class="inlinemath" src="eqn147.png" WIDTH=58 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[\lfloor i/2 \rfloor]" /></li><li>It always holds that the size of an heap is smaller or equal to the lenght of the array in which it is contained  <img class="displaymath" src="eqn148.png" WIDTH=166 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" A.heapsize \leq A.lenght" /> <ul>
<li>It can be smallr if not all the array is used for storing the heap</li>
</ul></li>
<li>Leaves are all the elements in the sub-array  <img class="inlinemath" src="eqn149.png" WIDTH=127 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[(\lfloor n/2 \rfloor+1)...n]" /></li></ul>
<h3 id="fundamental-heap-operations">Fundamental heap operations</h3>
<ul>
<li>These operations return fundamental feautures of an heap, like the values stored in the children and parent of the current node</li>
<li>Returning the maximum of an heap means returning its root value</li>
</ul>
<ul>
<li>max-heapify maintains the heap property when new elements are added to it</li>
<li>I assume that there is always at most 1 heap violation after I add 1 element to the heap
<ul>
<li>I am assuming that the sub-trees rooted in the children are max-heaps</li>
<li>Both children can never be bigger that their parent!</li>
</ul></li>
<li>I recursively explore the heap</li>
<li>If I find a parent that has a smaller key than one of its children, I swap them</li>
<li>This could generate a new heap violation down the tree</li>
<li>I continue swapping until no violations are left</li>
<li>Since an heap has  <img class="inlinemath" src="eqn150.png" WIDTH=38 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\log{n}" /> levels and I do constant work at each level (there are no loops and at most 1 recursive call), max-heapify has  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" /> running time</li><li>Equivalently, I can say that the running time of max-heapify is linear on the height of the heap  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> (it is  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" />)<ul>
<li>This is because  <img class="inlinemath" src="eqn154.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="h=\lfloor \log{n} \rfloor" /></li></ul></li>
</ul>
<ul>
<li>build-max-heap converts an array  <img class="inlinemath" src="eqn155.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[1...n]" /> to a max-heap of size  <img class="inlinemath" src="eqn156.png" WIDTH=96 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="n=A.lenght" /></li><li>The elements in the sub-array  <img class="inlinemath" src="eqn149.png" WIDTH=127 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[(\lfloor n/2 \rfloor+1)...n]" /> are leaves</li><li>I call max-heapify from the last non-leaf node to the root, so to reconstruct the max-heap property</li>
<li>I am constructive max-heaps in the subtrees by starting at the bottom, and then going up when everithing below the current level is a max-heap</li>
</ul>
<ul>
<li>Since max-heapify has a running time of  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" /> and the for loop is executed  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> times, it holds that the running time of buil-max-heap is  <img class="inlinemath" src="eqn158.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n\log{n})" /></li><li>This however is not a tight upper bound, we can define it more stringently</li>
<li>If  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> is the depth of a level, each levels has  <img class="inlinemath" src="eqn159.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -4px; margin: 0;" alt="n_i=2^i" /> nodes</li><li>An heap rooted at level  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> has an height of  <img class="inlinemath" src="eqn160.png" WIDTH=73 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="h_i = h-i" />, where  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> is the height of the complete heap</li><li>The cost of a max-heapify call is  <img class="inlinemath" src="eqn161.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h_i)" /> at level  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> <ul>
<li>Its cost is linear to the height of the node on which it is called</li>
</ul></li>
<li>The last level has height  <img class="inlinemath" src="eqn162.png" WIDTH=131 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="h = i_{max} = \lfloor \log{n} \rfloor" /></li><li>Consider also that  <img class="inlinemath" src="eqn163.png" WIDTH=67 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="h=\log{n}" /> and so  <img class="inlinemath" src="eqn164.png" WIDTH=49 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^h=n" /></li><li>I can therefore write  <img class="displaymath" src="eqn165.png" WIDTH=113 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" T(n) = \sum_{i=0}^h n_i h_i" />  <img class="displaymath" src="eqn166.png" WIDTH=144 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" T(n) = \sum_{i=0}^h 2^i (h-i)" />  <img class="displaymath" src="eqn167.png" WIDTH=164 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" T(n) = \sum_{i=0}^h 2^i (h-i)\frac{2^h}{2^h}" />  <img class="displaymath" src="eqn168.png" WIDTH=147 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" T(n) = 2^h \sum_{i=0}^h \frac{h-i}{2^h-i}" />  <img class="displaymath" src="eqn169.png" WIDTH=251 HEIGHT=52 STYLE="vertical-align: -21px; margin: 0;" alt=" T(n) = n \sum_{k=0}^h \frac{k}{2^k} \qquad\text{with } k=h-i" />  <img class="displaymath" src="eqn170.png" WIDTH=332 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt=" T(n) \leq n \sum_{k=0}^\infty \frac{k}{2^k} = \sum_{k=0}^\infty k (\frac{1}{2})^{k} = \frac{1/2}{(1-1/2)^2} = 2" />  <img class="displaymath" src="eqn171.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" T(n) = O(n)" /></li></ul>
<h2 id="priority-queues">Priority queues</h2>
<ul>
<li>A priority queue is a data structure from which I can extract elements according to their priority level (key value)</li>
<li>Application: it can manage job scheduling in a PC with jobs that have different priority</li>
<li>There are min-priority queues, which always return the lowest key in them, and max-priority queue, that always return the highest key in them</li>
<li>A max-priority queue can be conveniently implemented with a max-heap
<ul>
<li>A max-heap allows retrieval of the largest element in  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> with the heap-maximum routine</li></ul></li>
<li>A max priority queue supports the following operations
<ul>
<li>Return the element with largest key (heap-maximum, see heap operations)</li>
<li>Remove the element with largest key and return it (extract-max-heap)</li>
<li>Increase the key of an element (heap-increase-key)</li>
<li>Insert a new element (max-heap-insert)</li>
</ul></li>
<li>I can read the maximum element of the priority queue and remove it from the queue with the heap-extract-max procedure
<ul>
<li>I replace the root of the heap with the last element</li>
<li>I decrease the size of the heap by 1</li>
<li>I call max-heapify on the new root to restore the max-heap property</li>
<li>I do all constant time operations except for the max-heapify call, which is  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" /></li></ul></li>
</ul>
<ul>
<li>Increasing the value of an element is useful when I want to update its priority in the queue
<ul>
<li>Note that I can increase priority, not decrease!</li>
</ul></li>
<li>I first increase the value and then check if the new heap respects the max-heap property</li>
<li>If it does not i traverse the tree from the updated node to the root to find a proper place for it</li>
<li>It is doing all constant time operations, and a while loop</li>
<li>The while loop is executed at most once for each level, so the complexity is  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" /> on the size of the heap</li></ul>
<ul>
<li>Inserting a new element to a max-heap takes advantage of heap-increase-key</li>
<li>I insert the new element with a placeholder key of  <img class="inlinemath" src="eqn173.png" WIDTH=39 HEIGHT=14 STYLE="vertical-align: -3px; margin: 0;" alt="-\infty" /></li><li>I then increase its key to the actual value with heap-increase-key</li>
<li>max-heap-insert does all constant time operations and a call to heap-increase-key (which is  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" />), so the running time is  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" /></li></ul>
<h1 id="sorting">Sorting</h1>
<ul>
<li>Sorting is a common computational problem
<ul>
<li>The typical input is a series of numbers</li>
<li>The output is a permutation of the input such that  <img class="inlinemath" src="eqn174.png" WIDTH=65 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="a_i \leq a_{i+1}" /></li><li>A specific input sequence is an instance of the sorting problem</li>
</ul></li>
<li>Sorting is an intermediate step in many tasks in CS</li>
<li>There are many sorting algorithms</li>
<li>The input of the sorting problem is a sequence of numbers  <img class="inlinemath" src="eqn175.png" WIDTH=122 HEIGHT=16 STYLE="vertical-align: -4px; margin: 0;" alt="&lt;a_1, a_2, ..., a_n&gt;" /></li><li>The numbers in the input are also called keys</li>
<li>The output of the sorting problem is a permutation  <img class="inlinemath" src="eqn176.png" WIDTH=84 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="a_1', a_2', ..., a_n'" /> of the input such that  <img class="inlinemath" src="eqn177.png" WIDTH=128 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="a_1' \leq a_2 \leq...\leq a_n" /></li><li>When there are at least 2 elements that are identical, sorting algorithms can maintain the respective previous order of the elements or not</li>
<li>Normally, the numbers to be sorted are a key that is paired to other data, forming a record
<ul>
<li>A record is composed of a key and satellite data</li>
<li>A sorting algorithm permutes the keys, and then it permutes the satellite data accordingly</li>
</ul></li>
<li>In some applications it can be important that sorting does not alter the ordering of equal keys, especially when satellite data is involved
<ul>
<li>The other data can already be sorted following another criterion and I may need to not alter this</li>
</ul></li>
<li>An algorithm that sorts without altering the order of equal keys is said to perform a stable sort</li>
<li>A sorting algorithm is said to sort in place if it does not require extra space besides that needed to store the original array
<ul>
<li>It can require additional  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> space for variables, but it needs a constant amount of them at each given time</li><li>In practice, it is an algorithm that does not copy the array to be sorted</li>
</ul></li>
</ul>
<h2 id="insertion-sort">Insertion sort</h2>
<ul>
<li>Intuition: It is like arranging card in order in your hand by picking one at a time and placing it in the right position, by comparing it with all the other cards already in your hand</li>
<li>I always work on the same array but I put a moving boundary  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> before which all the elements are sorted<ul>
<li>The loop invariant is that  <img class="inlinemath" src="eqn178.png" WIDTH=80 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[1...j-1]" /> is always sorted</li></ul></li>
<li>I start with  <img class="inlinemath" src="eqn179.png" WIDTH=39 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j=2" /> and I loop on it until  <img class="inlinemath" src="eqn180.png" WIDTH=65 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="A.lenght" /></li><li>The current element at each iteration, called key, is  <img class="inlinemath" src="eqn181.png" WIDTH=30 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[j]" /></li><li>I update the moving boundary  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> to be  <img class="inlinemath" src="eqn182.png" WIDTH=37 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j-1" /></li><li>I compare the key with all the objects in the sorted portion of the array starting from the end of it  <img class="inlinemath" src="eqn141.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i]" />, until I find an element smaller than the current one or I reach the start of the array<ul>
<li>At each loop iteration I move the element  <img class="inlinemath" src="eqn141.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i]" /> to position  <img class="inlinemath" src="eqn183.png" WIDTH=56 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i+1]" /></li><li>I decrease  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> of 1</li></ul></li>
<li>When the loop ends (for any of the 2 reasons) I assign the value of the current element  <img class="inlinemath" src="eqn184.png" WIDTH=77 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="key=A[j]" /> to the position  <img class="inlinemath" src="eqn183.png" WIDTH=56 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i+1]" /> <ul>
<li>That position is empty since I shifted all the values in the previous loop</li>
</ul></li>
</ul>
<ul>
<li>Let’s assume that the input has  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> elements</li><li>The initial <strong>for</strong> test is executed n time, while the body of the <strong>for</strong> is executed n-1 times
<ul>
<li>I am looping on  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> elements, but I do a test more that will return false and exit the procedure!</li></ul></li>
<li>The body contains 3 constant operations and the while loop</li>
<li>The <strong>while</strong> test is executed a variable number of times at each iteration, for n-1 iterations (from  <img class="inlinemath" src="eqn186.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j=2 \to n" />)<ul>
<li>If  <img class="inlinemath" src="eqn187.png" WIDTH=13 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="t_j" /> is the number of times the while loop test is exectuted at each iteration of the <strong>for</strong> loop, then the test in total is executed  <img class="inlinemath" src="eqn188.png" WIDTH=57 HEIGHT=23 STYLE="vertical-align: -8px; margin: 0;" alt="\sum_{j=2}^n t_j" /> times</li></ul></li>
<li>The body of the <strong>while</strong> is executed always once less then the test ( <img class="inlinemath" src="eqn189.png" WIDTH=42 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="t_j-1" /> times for each iteration of the <strong>for</strong> loop)<ul>
<li>In total it is executed  <img class="inlinemath" src="eqn190.png" WIDTH=86 HEIGHT=23 STYLE="vertical-align: -8px; margin: 0;" alt="\sum_{j=2}^n t_j-1" /> times</li><li>There are 2 assignments on the while body</li>
</ul></li>
<li>The total running time is therefore  <img class="inlinemath" src="eqn191.png" WIDTH=342 HEIGHT=23 STYLE="vertical-align: -8px; margin: 0;" alt="T(n) = n+3(n-1)+\sum_{j=2}^nt_j+2\sum_{j=2}^n(t_j-1)" /></li><li>In the best case, the array is already sorted
<ul>
<li>I never enter the <strong>while</strong> at each iteration of the <strong>for</strong></li>
<li>This means that  <img class="inlinemath" src="eqn192.png" WIDTH=43 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="t_j=1" />, I only do the test</li><li>The time is linear:  <img class="inlinemath" src="eqn193.png" WIDTH=325 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)=n+3(n-1)+(n-1)+2*0=\Theta(n)" /></li><li>Nearly sorted numbers can be sorted fast with insertion sort</li>
</ul></li>
<li>In the worst case the array is in reverse sorted order
<ul>
<li>For each iteration of the for loop, I iterate the while loop on all the elements</li>
<li>The time is quadratic ( <img class="inlinemath" src="eqn194.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n^2)" />)</li></ul></li>
<li>Average case analysis is really difficult to do (it is probabilistic), therefore we prefer to focus on the worst case
<ul>
<li>The worst case provides an upper bound for the running time</li>
<li>For some algorithms, the worst case occurs frequently</li>
<li>The average case can be as bad as the worst case</li>
</ul></li>
<li>For almost sorted sequences the running time of insertion-sort is almost linear: good when this is the case</li>
<li>For unsorted array I go towards quadratic time: there are better alternatives</li>
<li>Time is quadratic also in the average case</li>
<li>Insertion-sort can operate online: it can sort sequences as they arrive</li>
<li>Typical application: keep a dynamic file sorted when adding elements to it and sorting almost-sorted files</li>
</ul>
<h1 id="merge-sort">Merge-sort</h1>
<ul>
<li>Merge-sort is a divide and conquer algorithm for sorting
<ul>
<li>I divide the input array of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> elements in 2 sub-sequences of  <img class="inlinemath" src="eqn195.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2" /> elements each</li><li>I sort the sub-sequences recursively</li>
<li>When the sub-sequence has just 1 element I am in the base case</li>
<li>A sub-sequence of 1 element is always sorted</li>
<li>I combine the sub-sequences to produce the sorted sequence</li>
</ul></li>
<li>Idea of the combine step
<ul>
<li>I need to combine 2 sorted sub-sequences</li>
<li>The first element of each sub-sequence is the smallest of that sub-sequence</li>
<li>I take the respective first elements of the 2 sub-sequences and compare them</li>
<li>I select the smallest of the 2 and put it as first element in the output</li>
<li>I proceed with what is now the first element of the 2 sub-sequences and repeat</li>
<li>When one of the 2 sub-sequences is empty I put in order all the remaining elements of the remaining sub-sequence to the end of the output array</li>
<li>The output array is sorted</li>
</ul></li>
<li>Implementation of merging
<ul>
<li>I actually use always only the original array but I maintain 3 indexes to separate diferent zones of it</li>
<li>The indexes are  <img class="inlinemath" src="eqn196.png" WIDTH=40 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="p,q,r" /> such that  <img class="inlinemath" src="eqn197.png" WIDTH=70 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="p\leq q \leq r" /> always holds</li><li>The indexes split the array  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> into 2 sub-arrays  <img class="inlinemath" src="eqn198.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[p...q]" /> and  <img class="inlinemath" src="eqn199.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[q+1...r]" /></li><li>I check that I am not in the base case ( <img class="inlinemath" src="eqn200.png" WIDTH=52 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="p==r" />)<ul>
<li>I sort recursively the 2 sub-arrays by calling again merge-sort 2 times with  <img class="inlinemath" src="eqn201.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(p=p, r=q)" /> and  <img class="inlinemath" src="eqn202.png" WIDTH=125 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(p=q+1, r=r)" /></li><li>After the 2 recursive calls return I have 2 sorted sub-arrays to merge,  <img class="inlinemath" src="eqn198.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[p...q]" /> and  <img class="inlinemath" src="eqn199.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[q+1...r]" /></li><li>I copy them to the new arrays  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> and  <img class="inlinemath" src="eqn052.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="R" /></li><li>I add at the end of both  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> and  <img class="inlinemath" src="eqn052.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="R" /> an  <img class="inlinemath" src="eqn204.png" WIDTH=18 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\infty" />, so that always the other sub-sequence will be added when I reach the end of one sequence</li><li>I compare the first element of  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> and  <img class="inlinemath" src="eqn052.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="R" />, and I place the smallest in the first position of the output array  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /></li><li>I continue with the second smallest and place it in the second position of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> and so on</li><li>When  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> or  <img class="inlinemath" src="eqn052.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="R" /> finish, there is the  <img class="inlinemath" src="eqn204.png" WIDTH=18 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\infty" /> remaining so all the comparison to it will return that the other sub-sequence has a smaller element</li><li>When both sequence finish I stop the comparison and return control to the calling procedure: now  <img class="inlinemath" src="eqn205.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[p...r]" /> is sorted (for the  <img class="inlinemath" src="eqn206.png" WIDTH=25 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="p,r" /> used in the current recursive call)</li></ul></li>
<li>If I am in the base case I do not do anything: the sub-arrays are sorted</li>
<li>The output is one sorted array input array</li>
</ul></li>
</ul>
<ul>
<li><p>Running time of merge-sort  <img class="displaymath" src="eqn207.png" WIDTH=230 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" T(n) = 2T(n/2)+T_{merge}(n)+c" /></p><ul>
<li>I perform 2 costant time operations at each call</li>
<li>I have 2 recursive calls on an input of  <img class="inlinemath" src="eqn195.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2" /> size</li><li>I have 1 merge call on an input of size  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /></li></ul></li>
<li><p>Running time of merge</p>
<ul>
<li>I perform 8 constant time operation</li>
<li>I have 2 for loops which are executed  <img class="inlinemath" src="eqn195.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2" /> times each, so together they take  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /> time</li><li>The last for loop is executed  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> times<ul>
<li>It always consists of 3 constant operations plus the initial test</li>
</ul></li>
<li>The total time is  <img class="inlinemath" src="eqn209.png" WIDTH=249 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T_{merge}(n)=2(n/2)+n+c=\Theta(n)" /></li></ul></li>
<li><p>The recurrence equation  <img class="displaymath" src="eqn210.png" WIDTH=268 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="T(n)=\begin{cases}\Theta(1) &amp; \text{if } n=1 \\ 2T(n/2)+n &amp; \text{if } n&gt;1 \end{cases}" /></p></li><li><p>It runs always as  <img class="inlinemath" src="eqn120.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n\log{n})" />, there is not worst or best case</p></li><li><p>The advantage of merge-sort is that its running time is guaranteed</p>
<ul>
<li>It is worse than insertion sort in the insertion-sort best case, but better in most cases</li>
</ul></li>
<li><p>The disadvantage is that it requires extra space and cannot work online</p>
<ul>
<li>Merge-sort cannot work online, since I need the whole input array at the first step</li>
<li>It requires a lot of memory to store all the sub-arrays</li>
</ul></li>
<li><p>Typical application: sort a huge randomly ordered data file</p></li>
<li><p>The complicated part of merge-sort is the combine step</p></li>
<li><p>Merge-sort does not sort in place: it copies the values to other arrays</p></li>
</ul>
<h1 id="heap-sort">Heap-sort</h1>
<ul>
<li>Heap-sort is another sorting algorithm running in  <img class="inlinemath" src="eqn158.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n\log{n})" /> (like merge-sort)</li><li>It is able to sort in place and it uses an heap as data structure</li>
<li>The sub-routines not written here are the ones for general heap operations</li>
<li>We start from a random array and we make it a max heap by calling build-max-heap on it</li>
<li>We swap the root of the heap with the last element of the array and decrease the heap-size by 1
<ul>
<li>What was the root is now not part of the heap</li>
</ul></li>
<li>We call max-heapify on the root to rebuild the max-heap property
<ul>
<li>The only heap violation is the root itself, and max-heapify will descend the tree to recover the max-heap property</li>
</ul></li>
<li>I repeat until the the heap has size 1: now the array is sorted</li>
</ul>
<ul>
<li>As we saw, build-max-heap is an  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> operation</li><li>The for loop body is called  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> times<ul>
<li>It performs 2 constant time operations and a call to max-heapify on input size from  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> down to  <img class="inlinemath" src="eqn211.png" WIDTH=10 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2" /></li></ul></li>
<li>max-heapify is an  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" /> operation</li><li>The total running time is therefore  <img class="inlinemath" src="eqn212.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n \log{n})" /></li><li>Heap-sort is insensitive to input arrangement: there is no best or worst case</li>
<li>Compared to mergesort, which has a  <img class="inlinemath" src="eqn120.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n\log{n})" />, it as the same upper bound but the bound is not tight<ul>
<li>It is marginally better</li>
</ul></li>
</ul>
<h2 id="quick-sort">Quick-sort</h2>
<ul>
<li>Quick-sort is a divide and conquer sorting algorithm with a worst-case running time of  <img class="inlinemath" src="eqn194.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n^2)" /> and an average case running time of  <img class="inlinemath" src="eqn120.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n\log{n})" /></li><li>It is one of the most popular sorting algorithms because of its good average performances</li>
<li>I works by splitting the array on a pivot, and then calling recursively on the sub-arrays at the 2 sides of the pivot (but not including it)
<ul>
<li>Before calling the recursions all the elements to the left of the pivot are smaller than it (or equal), and all the elements at its right are larger</li>
<li>This means that the pivot is in its correct final position in the array</li>
<li>The base case is when the sub-arrays is just made of 1 element, and so it is sorted</li>
</ul></li>
<li>After I select a pivot and before calling the recursions, I need to swap elements so that the pivot is in the right position
<ul>
<li>I select as a pivot  <img class="inlinemath" src="eqn213.png" WIDTH=62 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[r] = x" /></li><li>I mantain 4 regions in the array
<ul>
<li> <img class="inlinemath" src="eqn214.png" WIDTH=30 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[r]" /> is  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> itself</li><li> <img class="inlinemath" src="eqn215.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[p...i]" /> is smaller or equal to  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li> <img class="inlinemath" src="eqn216.png" WIDTH=105 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i+1...j-1]" /> is greater than  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li> <img class="inlinemath" src="eqn217.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[j...r-1]" /> is unrestricted</li></ul></li>
<li>I start by initializing  <img class="inlinemath" src="eqn215.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[p...i]" /> empty (I assign  <img class="inlinemath" src="eqn218.png" WIDTH=65 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i = p-1" />)</li><li>I check elements 1 by 1 from  <img class="inlinemath" src="eqn219.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="p" /> to  <img class="inlinemath" src="eqn220.png" WIDTH=38 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="r-1" /> (just before the pivot)</li><li>When I find an element taht belogs to  <img class="inlinemath" src="eqn215.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[p...i]" /> I increase  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> of 1 to make space for it and I place it there by swapping with the current  <img class="inlinemath" src="eqn141.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i]" /></li><li>When I reach  <img class="inlinemath" src="eqn221.png" WIDTH=58 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[r-1]" /> the unrestricted region  <img class="inlinemath" src="eqn217.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[j...r-1]" /> disappears</li><li>As a last thing I swap the pivot from the end of the array to where it belongs ( <img class="inlinemath" src="eqn183.png" WIDTH=56 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[i+1]" />)</li></ul></li>
<li>The conquer and combine parts are really easy in quick-sort, but divide requires effort
<ul>
<li>Conquer is just a recursive call on the sub-arrays</li>
<li>This is sharply different from MERGESORT, where combine is the most demanding part</li>
</ul></li>
</ul>
<ul>
<li>The partitioning procedure performs constant time operations and has a for loop</li>
<li>The for loop contains constant time operations and it is executed  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> times</li><li>The running time of partition is  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /></li><li>quicksort has a cost of  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> in the base case while in the recursive case it calls partition ( <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" />) and it makes 2 recursive calls on an input size which depends on the partitioning used</li><li>I am in the worst case when the partitioning is maximally unbalanced, since the recursion tree will have its maximum height ( <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />)<ul>
<li>In this case one recursive call will be called on  <img class="inlinemath" src="eqn222.png" WIDTH=10 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="0" /> element and one on  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> elements</li><li>If I am choosing the last elements as a pivot, the worst case occurs when the array is already sorted</li>
<li>In the worst case the recurrence equation is  <img class="displaymath" src="eqn223.png" WIDTH=367 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" T(n) = T(n-1)+T(0)+\Theta(n) = T(n-1) + \Theta(n)" />  <img class="displaymath" src="eqn224.png" WIDTH=240 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" T(n) = \sum_{i=0}^{n-1} n-i = \sum_{k=1}^n k = \Theta(n^2)" /></li></ul></li>
<li>The best case occurs when the partitioning is always perfectly balanced
<ul>
<li>In this case the recursive calls are done on input sizes  <img class="inlinemath" src="eqn195.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2" /> and  <img class="inlinemath" src="eqn225.png" WIDTH=56 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2-1" /></li><li>At recursion level  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> I have  <img class="inlinemath" src="eqn226.png" WIDTH=14 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^i" /> recursive calls on an input size of  <img class="inlinemath" src="eqn227.png" WIDTH=32 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="n/2^i" /></li><li>The total cost at each level is  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> and I have  <img class="inlinemath" src="eqn150.png" WIDTH=38 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\log{n}" /> levels</li><li>The recursion equation of the best case is  <img class="displaymath" src="eqn228.png" WIDTH=171 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" T(n) = 2T(n/2) + \Theta(n)" />  <img class="displaymath" src="eqn229.png" WIDTH=128 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" T(n) = \Theta(n\log{n})" /></li></ul></li>
<li>Actually I am in the best case when the split has constant proportionality, even if it is not perfectly balanced</li>
<li>In the average case I have a randomly ordered array
<ul>
<li>I expect a mix of balanced and unbalanced splits randomly distributed along the recursion tree</li>
<li>The average case running time is similar to the best case,  <img class="inlinemath" src="eqn230.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n \log{n})" /></li></ul></li>
<li>The choice of the pivot influences the performances of quick-sort, since it affects the proportionality of the split
<ul>
<li>The solution presented here is to choice always the last element as a pivot</li>
<li>Another approach is to pick 3 values from the array and choose their median as a pivot</li>
</ul></li>
<li>The worst case running time of quick-sort is pretty bad and could be caused volountarily by submitting a specific instance
<ul>
<li>This could be a security risk</li>
</ul></li>
<li>To assure that no particular input (i.e. a sorted array) cause the worst-case scenario of quicksort, I can use the randomized version of the algorithm
<ul>
<li>I can either randomize the input or the choice of the pivot</li>
</ul></li>
<li>Also quick-sort sorts is able to sort in place</li>
</ul>
<h1 id="some-reflections-on-comparison-based-sorting">Some reflections on comparison-based sorting</h1>
<ul>
<li>All the algorithms we saw sort by comparing elements</li>
<li>All of them sort in place with the exception of MERGESORT</li>
<li>Insertion-sort and merge-sort are stable, while heap-sort and quick-sort are not</li>
<li>The worst-case running time of insertion-sort and quick-sort is  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /></li><li>Heap-sort and merge-sort have a guaranteed running time of  <img class="inlinemath" src="eqn158.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n\log{n})" /> on every possible instance</li><li>Insertion-sort is linear in the best case</li>
<li>The lower bound for comparision-based sorting is  <img class="inlinemath" src="eqn232.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Omega(n \log{n})" /> because in the worst case I need to do at least  <img class="inlinemath" src="eqn233.png" WIDTH=48 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="n\log{n}" /> comparisons<ul>
<li>Any comparison-based sorting alogrithm must be able to sort any possible input of size  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /></li><li>There are  <img class="inlinemath" src="eqn234.png" WIDTH=15 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="n!" /> possible permutations of an array of size  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />, and the algorthm must be able to sort all of them</li><li>Every permutation requires a different rearrangement of the array in order to be sorted</li>
<li>I can imagine a decision tree with  <img class="inlinemath" src="eqn234.png" WIDTH=15 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="n!" /> leaves, corresponding to all the permutions</li><li>The height of the decision tree represent the number of single comparisons that the algorithm has to do in the worst case</li>
<li>A tree of heigh h has  <img class="inlinemath" src="eqn235.png" WIDTH=17 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^h" /> leaves, and so a tree with  <img class="inlinemath" src="eqn234.png" WIDTH=15 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="n!" /> leaves has heigh  <img class="inlinemath" src="eqn236.png" WIDTH=42 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\log{n!}" /></li><li>We saw before that  <img class="inlinemath" src="eqn237.png" WIDTH=134 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta (n!) = \Theta (n \log{n})" /></li></ul></li>
<li>Heapsort and Mergesort are asymptotically optimal comparison-based sorting algorithms</li>
</ul>
<h1 id="linear-time-sorting">Linear-time sorting</h1>
<ul>
<li>It is possible to sort in a time lower to  <img class="inlinemath" src="eqn238.png" WIDTH=61 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\Theta{n \log{n}}" /> if my algorithm is not based on comparisons</li><li>In this case I need to make assumptions about the input elements</li>
<li>Linear-timesorting algorithms are counting-sort and radix-sort</li>
</ul>
<h2 id="counting-sort">Counting sort</h2>
<ul>
<li>Counting-sort assumes that the input array contains only integers in the range  <img class="inlinemath" src="eqn239.png" WIDTH=33 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="0...k" /></li><li>For each element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> into the array, I determine how many elements are equal or smaller than  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>I put element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> in the correct position in the output array by knowing how many elements are smaller or equal to it</li><li>It uses an input array  <img class="inlinemath" src="eqn155.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A[1...n]" />, an output array  <img class="inlinemath" src="eqn240.png" WIDTH=54 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B[1...n]" /> and a counter array  <img class="inlinemath" src="eqn241.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="C[1...k]" /></li><li>I first initialize  <img class="inlinemath" src="eqn242.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="C[0...k]" /> to contain all  <img class="inlinemath" src="eqn222.png" WIDTH=10 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="0" />s</li><li>I go through all the elements in A
<ul>
<li>In each iteration i use A[j] as an index in C, and I increment that position of 1</li>
<li>In this way element C[i] contains the number of occurrences of the value i in the array A</li>
</ul></li>
<li>I go through C and I add, starting from the beginning, the value of C[i-1] to C[i]
<ul>
<li>In this way element C[i] contains the number of elements in A that are smaller or equal to i</li>
<li>I am converting a counter for i in a cumulative counter</li>
</ul></li>
<li>Finally, I iterate j from the A.lenght downto 1
<ul>
<li>I put in the output array B the element A[j] in the position that is stored in C[A[j]]
<ul>
<li>If there are i elements in A smaller than A[j], then A[j] is put in B[i]</li>
</ul></li>
<li>I decrease the respective counter in C of 1, so that if I find another element in A with the same key it is put in the previous position of B</li>
</ul></li>
</ul>
<ul>
<li>The first and third for loops require both time  <img class="inlinemath" src="eqn243.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(k)" /> since they loop through the counter array</li><li>The second and last for loops require both  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" />, since they loop through the input array</li><li>The total running time is therefore  <img class="inlinemath" src="eqn244.png" WIDTH=65 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n+k)" /></li><li>In practice, we use counting-sort only when  <img class="inlinemath" src="eqn245.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="k = O(n)" />, so we can say that its running time is  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /></li><li>The running time is at minimum  <img class="inlinemath" src="eqn246.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Omega(n)" />, and O(n+k)<ul>
<li>If k = O(n), then COUNTING-SORT runs in  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /></li><li>Since I use COUNTING-SORT only when k = O(n), in practice the algorithm runs in  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /></li></ul></li>
<li>counting-sort is stable since the last of the equal-key elements of the input array is the first of them to be put in the output array (the last for loop runs backwards)
<ul>
<li>This means that it will be put with the highest index, and so as last element in the output array</li>
</ul></li>
<li>The stability of counting-sort is important because the algorithm is frequently used as a subroutine of radix-sort, and radix-sort requires a stable sorting subroutine</li>
</ul>
<h2 id="radix-sort">Radix sort</h2>
<ul>
<li>It consideres the key as a number in base  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" />, which has  <img class="inlinemath" src="eqn247.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="d" /> digits and so occupies  <img class="inlinemath" src="eqn247.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="d" /> columns</li><li>It looks at  <img class="inlinemath" src="eqn125.png" WIDTH=9 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="1" /> column at a time, starting from the LEAST significant and sorting it with any stable sorting algorithm<ul>
<li>If I start from the most significant column, I need to recurse for sorting the least significant digits
<ul>
<li>This implementation is called MSD (most significant digit) radix-sort</li>
</ul></li>
<li>If I start from the least significant digits and I use a stable sort, when I sort the most significant column everithing is correclty sorted
<ul>
<li>This implementation is called LSD (least significant digit) radix-sort</li>
</ul></li>
</ul></li>
<li>It requires only a for loop that runs from the lowest order digit (last column) to the highest order digit (column  <img class="inlinemath" src="eqn247.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="d" />)<ul>
<li>In each iteration it calls a stable sorting algorithm on the column</li>
<li>It takes only  <img class="inlinemath" src="eqn247.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="d" /> passes on the array each with a running time depending on the sorting subroutine used, with input size  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /></li></ul></li>
</ul>
<ul>
<li>radix-sort takes  <img class="inlinemath" src="eqn248.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(d\ f(n))" /> time, where f(n) is the running time of the subroutine used</li><li>If (as it is usually the case) I use counting-sort as a subroutine, it take  <img class="inlinemath" src="eqn249.png" WIDTH=92 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(d\ (n+k))" /> time</li><li>In decimal notation  <img class="inlinemath" src="eqn250.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k=9" /> since a column can only hold digits in the range  <img class="inlinemath" src="eqn251.png" WIDTH=32 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="0...9" /></li><li>Therefore when the base used is smaller than  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />, radix-sort has complexity  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /></li><li>LSD radix-sort is stable while MSD radix-sort is not stable</li>
<li>radix-sort usually is implemented not in place, since it uses counting-sort
<ul>
<li>If memory is a problem then quick-sort is a better choice</li>
</ul></li>
</ul>
<h1 id="dynamic-sets">Dynamic sets</h1>
<ul>
<li>Sets are fundamental both for computer science and for maths</li>
<li>In maths sets are static, but in computer science they are dynamic
<ul>
<li>They can grow or change over time when manipulated by algorithms</li>
</ul></li>
<li>Elementary set operations are insertion, deletion and membership test</li>
<li>A set supporting all of the elementary operations is called a dictionary</li>
<li>A priority queue is a set that support the extract-max operation</li>
<li>Each set elements is identified by a key, and it can have optional features
<ul>
<li>It can have satellite data associated to it</li>
<li>It can store a pointer, which points to another element in the set</li>
</ul></li>
<li>Set operations can be queries or modifying operations</li>
<li>A query always returns a pointer to another element in the set: search, minimum, maximum, successor, predecessor</li>
<li>A modifying operation modifies the set itself: insert and delete</li>
<li>Dynamic sets can be represented with different data structures that use pointers: stacks, queues, linked lists, rooted trees</li>
</ul>
<h2 id="stacks">Stacks</h2>
<ul>
<li>A stack is a pile of elements on top of each other, deriving its element from an actual stack of plates in a resturant</li>
<li>A new element is always added to the top of the stack with a push operation</li>
<li>Elements are also always removed from the top of the stack, with a pop operation</li>
<li>The popping order is the reverse of the push order: stacks follow a last in first out (LIFO) policy</li>
<li>Elements cannot be accessed from a stack if they are not at its top</li>
<li>The top element can be popped (read and removed), or it can be accessed without removing it</li>
<li>A stack is NOT a good data structure for sorting and it is not used for this purpose</li>
<li>Some applications of stacks
<ul>
<li>Storing undo history in text editors</li>
<li>Synthax parsing: evaluating missing parenteses
<ul>
<li>I push open and close parenthesis to the stack and pop twice when I find matching parenthesis</li>
<li>At the end of the file I require the stack to be empty</li>
</ul></li>
</ul></li>
<li>A stack of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> elements can be implemented with an array  <img class="inlinemath" src="eqn252.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1..n]" /></li><li>A stack has a  <img class="inlinemath" src="eqn253.png" WIDTH=39 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S.top" /> attribute that contains the index of the top element of the stack<ul>
<li>The top element of a stack is usually the last element (index  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />)</li><li>If the stack is empty  <img class="inlinemath" src="eqn254.png" WIDTH=69 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S.top = 0" /></li></ul></li>
<li>Some basic stack operations</li>
</ul>
<ul>
<li>All these stack operations run in constant time</li>
</ul>
<h2 id="queues">Queues</h2>
<ul>
<li>A queue is a line of elements that behaves like a line of people in a shop</li>
<li>In a queue I use a FIFO policy instead of a LIFO policy</li>
<li>I add elements from the tail of the queue with the enqueue procedure and extract them from its head with the dequeue procedure</li>
<li>Elements can be always enqueued, but only the element that sat in the queue the longest can be dequeued</li>
<li>It is not possible to access elements in the middle of the queue</li>
<li>The element at the head of the queue can be dequeued or also read without removing it</li>
<li>Queues are used for scheduling processes in operating systems and for reservations for accessing a shared resource</li>
<li>A queue of  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> elements can be implemented with an array  <img class="inlinemath" src="eqn255.png" WIDTH=54 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[1...n]" /></li><li>Queues are circular, there is no end and beginning for their representaion on the array
<ul>
<li>An empty elements marks where the queue ends and starts</li>
</ul></li>
<li>The array must be  <img class="inlinemath" src="eqn125.png" WIDTH=9 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="1" /> element longer than the queue because I need an empty element for marking the end of the queue</li><li> <img class="inlinemath" src="eqn256.png" WIDTH=54 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.head" /> is the index of first element of the queue</li><li> <img class="inlinemath" src="eqn257.png" WIDTH=44 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.tail" /> is the index of the last element of the queue  <img class="inlinemath" src="eqn258.png" WIDTH=29 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="+ 1" />, it is the index of the spacer that marks the end of the queue *  <img class="inlinemath" src="eqn259.png" WIDTH=65 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[Q.tail]" /> is always an empty element!</li><li>The queue spans positions  <img class="inlinemath" src="eqn260.png" WIDTH=159 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[Q.head...Q.tail-1]" /> in circular order</li><li>A queue is empty when  <img class="inlinemath" src="eqn261.png" WIDTH=117 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.head = Q.tail" /> <ul>
<li>A new queue is initialized with  <img class="inlinemath" src="eqn262.png" WIDTH=147 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.head = Q.tail = 1" /></li></ul></li>
<li>A queue is full when  <img class="inlinemath" src="eqn263.png" WIDTH=145 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.head = Q.tail + 1" /> (circular case, the queue wraps around the end of the array) or when  <img class="inlinemath" src="eqn264.png" WIDTH=83 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.head = 1" /> and  <img class="inlinemath" src="eqn265.png" WIDTH=162 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.tail = Q.lenght = n" /> (linear case. the queue does not wrap around the end of the array)</li></ul>
<ul>
<li>In queue and dequeue operations, the pointers  <img class="inlinemath" src="eqn256.png" WIDTH=54 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.head" /> and  <img class="inlinemath" src="eqn257.png" WIDTH=44 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.tail" /> always move forward, running behind each other</li><li>When one of them reaches  <img class="inlinemath" src="eqn266.png" WIDTH=65 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="Q.lenght" />, it wraps around the end of the array and becomes  <img class="inlinemath" src="eqn125.png" WIDTH=9 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="1" /></li><li>Enquque and dequeue require both constant time</li>
</ul>
<h2 id="linked-lists">Linked lists</h2>
<ul>
<li>A linked list  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> is a data structure in which elements are arranged in a linear order</li><li>Differently from arrays, linked lists are dynamically allocated</li>
<li>The order of elements in a linked list is NOT determined by indeces, but by pointers in each element</li>
<li>Each element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> of a linked list has 2 fundamental attributes<ul>
<li> <img class="inlinemath" src="eqn267.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key" /> is the content of the element itself</li><li> <img class="inlinemath" src="eqn268.png" WIDTH=48 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x.next" /> is a pointer to the next element in the linked list</li></ul></li>
<li> <img class="inlinemath" src="eqn269.png" WIDTH=52 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="L.head" /> is an attribute of the linked list itself that stores a pointer to the first element of the list</li><li>A linked list is empty when  <img class="inlinemath" src="eqn270.png" WIDTH=108 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="L.head = NIL" /></li><li>The last element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> of a linked list is the one for which  <img class="inlinemath" src="eqn271.png" WIDTH=104 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x.next = NIL" /></li><li>Singly-linked lists store just the  <img class="inlinemath" src="eqn268.png" WIDTH=48 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x.next" /> attrivbute in each element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>Doubly-linked lists store an  <img class="inlinemath" src="eqn268.png" WIDTH=48 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x.next" /> and a  <img class="inlinemath" src="eqn272.png" WIDTH=47 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.prev" /> attribute for each element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> <ul>
<li> <img class="inlinemath" src="eqn272.png" WIDTH=47 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.prev" /> stores a pointer to the previous element in the linked list</li><li> <img class="inlinemath" src="eqn273.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="L.tail" /> is an attribute of a doubly linked list that stores a pointer to the last element of the list</li></ul></li>
<li>A circular list is a doubly-linked list where
<ul>
<li> <img class="inlinemath" src="eqn273.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="L.tail" /> points to the last element of  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /></li><li> <img class="inlinemath" src="eqn274.png" WIDTH=150 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="L.head.prev = L.tail" /></li><li> <img class="inlinemath" src="eqn275.png" WIDTH=151 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="L.tail.next = L.head" /></li></ul></li>
<li>Basic operations on linked lists are: list-search(key), list-insert(element), list-delete(element)</li>
<li>The following pseudocodes refer to doubly-linked lists</li>
</ul>
<ul>
<li>list-insert and list-delete are both constant time operations in linked lists</li>
<li>list-search is an  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> operation in linked lists since in the worst case I need to scan the entire list</li></ul>
<h2 id="representing-rooted-trees-with-linked-lists">Representing rooted trees with linked lists</h2>
<ul>
<li>We already saw how to represent a binary rooted tree with arrays</li>
<li>I can represent them also with linked lists</li>
<li>In this case each element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> of the linked list will contain<ul>
<li> <img class="inlinemath" src="eqn276.png" WIDTH=44 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.left" /> and  <img class="inlinemath" src="eqn277.png" WIDTH=53 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.right" />, pointers to the childrens of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li> <img class="inlinemath" src="eqn278.png" WIDTH=24 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.p" />, a pointer to the parent node of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li> <img class="inlinemath" src="eqn267.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key" /> and  <img class="inlinemath" src="eqn279.png" WIDTH=47 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="x.data" />, key and satellite data of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li></ul></li>
<li>The tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> will contain  <img class="inlinemath" src="eqn281.png" WIDTH=47 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T.root" />, a pointer to the root of the tree</li><li>The tree is empty when  <img class="inlinemath" src="eqn282.png" WIDTH=103 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T.root = NIL" /></li><li>If  <img class="inlinemath" src="eqn283.png" WIDTH=100 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.left = NIL" /> and  <img class="inlinemath" src="eqn284.png" WIDTH=109 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.right = NIL" />, then  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is a leaf</li><li>Note that always holds that  <img class="inlinemath" src="eqn285.png" WIDTH=116 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="T.root.p = NIL" /></li><li>I am not necessarily limited to binary trees with linked lists</li>
<li>I can have any number of branching factor by just increasing the number of child pointers for each element
<ul>
<li>This works well when I have a fixed branching factor  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> such that I can allocate pointers  <img class="inlinemath" src="eqn286.png" WIDTH=205 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.child_1, x.child_2, ..., x.child_k" /> for each node</li><li>This approach is wasteful when the branching factor is unbounded since I need to allocate statically the number of children for each node</li>
</ul></li>
<li>I can do it more efficiently by using a linked list also for representing the children
<ul>
<li>Each node  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> has the usual  <img class="inlinemath" src="eqn267.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key" />,  <img class="inlinemath" src="eqn279.png" WIDTH=47 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="x.data" />,  <img class="inlinemath" src="eqn278.png" WIDTH=24 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.p" /> pointers</li><li>The  <img class="inlinemath" src="eqn276.png" WIDTH=44 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.left" /> pointer points to the leftmost child of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>The  <img class="inlinemath" src="eqn277.png" WIDTH=53 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.right" /> pointer is put to new use: it points to the right sibiling of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>In this representation if  <img class="inlinemath" src="eqn287.png" WIDTH=100 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.left= NIL" />, then  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is a leaf</li><li>If  <img class="inlinemath" src="eqn284.png" WIDTH=109 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.right = NIL" />, then  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is the rightmost child of  <img class="inlinemath" src="eqn278.png" WIDTH=24 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.p" /></li></ul></li>
</ul>
<h2 id="hash-tables">Hash tables</h2>
<ul>
<li>In many applications I need a dynamic set that supports only the dictionary oerations INSERT, SEARCH and DELETE</li>
<li>A data structure implementing these operations is called a dictionary</li>
<li>An direct-address table is a convenient way of implementing a dictionary
<ul>
<li>In an direct-access table under reasonable assumptions, SEARCH and INSERT take  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" />, but the worst case SEARCH time is  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /></li></ul></li>
<li>An direct-address table is a generalization of an ordinary array
<ul>
<li>It contains  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> elements in the array, and each element is associated with a unique key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>The keys are drawn from a reasonably small universe  <img class="inlinemath" src="eqn288.png" WIDTH=147 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="U = \{0,1,...,m-1\}" /></li></ul></li>
<li>I can represent the direct-address table with an array  <img class="inlinemath" src="eqn289.png" WIDTH=86 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T[0...m-1]" /> <ul>
<li>Each position in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is called slot and maps to a key in  <img class="inlinemath" src="eqn028.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="U" /></li><li>For each element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> with key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" />,  <img class="inlinemath" src="eqn290.png" WIDTH=31 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T[k]" /> contains  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> itself or a pointer to it</li><li>If no elements has key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" />, then  <img class="inlinemath" src="eqn291.png" WIDTH=88 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T[k] = NIL" /></li></ul></li>
<li>All the fundamental operations in direct adress tables have an  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> running time</li></ul>
<ul>
<li>In general  <img class="inlinemath" src="eqn028.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="U" /> can be very large and the actual number of used keys can be small, so direct-access tables can be unpractical<ul>
<li>I need to allocate the table with all the possible keys in  <img class="inlinemath" src="eqn028.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="U" />!</li><li>I want to be able to allocate a table of lenght equal to the subset  <img class="inlinemath" src="eqn292.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="K" /> of keys actually used from the universe  <img class="inlinemath" src="eqn028.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="U" /></li></ul></li>
<li>To solve the space usage limitations of of direct-address tables, I can use an hash table
<ul>
<li>An hash table does not use  <img class="inlinemath" src="eqn290.png" WIDTH=31 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T[k]" /> as a slot for the key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" />, but  <img class="inlinemath" src="eqn293.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T[h(k)]" />, where  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> is an hash function</li></ul></li>
<li>An hash function  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> converts a key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> into an index in an hash table  <img class="inlinemath" src="eqn289.png" WIDTH=86 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T[0...m-1]" />  <img class="displaymath" src="eqn294.png" WIDTH=174 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" h:U \to \{0,1,...,m-1\}" /> <ul>
<li>We say that  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> hashes to the slot  <img class="inlinemath" src="eqn295.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="h(k)" /></li><li>We will not study hash functions, but we assume them to be well designed and to output with equal probability to each slot</li>
<li>Using a subset of the possible keys reduces the storage requirements</li>
</ul></li>
<li>It can happen that 2 elements hash to the same slot, and I define this event as a collision
<ul>
<li>It is impossible to completely avoid collisions, since  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> is smaller than the universe  <img class="inlinemath" src="eqn028.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="U" /> of possible elements</li></ul></li>
<li>To solve the collision problem, When I have a collision I create a linked list of the elements hashing at that location
<ul>
<li>In this configuration a slot does not contain a pointer to an element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />, but to the head of a linked list containing all the elements that hash to that slot</li><li>This approach is called collision by chaining</li>
</ul></li>
</ul>
<ul>
<li>Insertion in a chained hash table takes  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> in the worst case</li><li>Deletion takes  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> if the the lists are doubly linked, and takes the time needed for searching if singly linked<ul>
<li>If the lists are single-linked, I need to find its predecessor in order to update the pointers in the list, but I do not have a pointer to it!</li>
<li>No search is needed to find the element to delete, since I am given a pointer to it</li>
</ul></li>
<li>In the average case hashing with chaining has performances that depend on how well the hash function distributes the  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> keys among the  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> slots</li><li>The load factor  <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" /> of an hash table is the number of elements in the table  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> divided by the number of slots  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" />  <img class="displaymath" src="eqn298.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\alpha = n/m" /> <ul>
<li>This is true if I assume that every slot has the same probability to be hashed by an element (simple uniform hashing assumption)</li>
<li> <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" /> can be 1, bigger than 1 or smaller than 1</li></ul></li>
<li>An unsucessfull search in a chained hash table takes expected time  <img class="inlinemath" src="eqn299.png" WIDTH=65 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(1+\alpha)" /> under simple uniform hashing<ul>
<li>An unsuccessfull search is the worst case search for a chained hash table</li>
<li>In an unsuccessfull search I need to go through the all list, which has expected lenght  <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" /></li><li>If choose  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> to be proportional to  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> I have that  <img class="inlinemath" src="eqn300.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m=O(n)" /></li><li>In this case  <img class="inlinemath" src="eqn301.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\alpha=O(1)" /> since  <img class="inlinemath" src="eqn302.png" WIDTH=135 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)/O(n)=O(1)" /> and therefore an unsuccessfull search has a  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> running time</li></ul></li>
<li>The size of the hash table influences the speed in operating with it
<ul>
<li>If it has only 1 element essentially I don’t have an hash table but a linked list</li>
<li>If it is too big it requires a lot of space</li>
<li>Typically the right size is 1/5 to 1/10 of the number of elements to be stored in it</li>
</ul></li>
<li>I can keep the lists in an hash table ordered or not
<ul>
<li>If the lists are not ordered inserting is faster and I can implement a LIFO behaviour</li>
<li>If they are ordered seaching is faster</li>
</ul></li>
</ul>
<h2 id="binary-search-trees-bst">Binary search trees (BST)</h2>
<ul>
<li>A BST supports many dynamic set operations: SEARCH, MINIMUM, MAXIMUM, PREDECESSOR, SUCCESSOR, INSERT, DELETE
<ul>
<li>It can be used both as a dictionary and as a priority queue</li>
</ul></li>
<li>On average all operations take  <img class="inlinemath" src="eqn303.png" WIDTH=58 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(log n)" />, with a worst case  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /> <ul>
<li>The expected height of the tree is  <img class="inlinemath" src="eqn304.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(\log n)" />, while its biggest possible height is  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /> when the tree is actually alinear chain of elements</li></ul></li>
<li>A BST is represented as a linked data structure in which each node stores an object and several pointers
<ul>
<li>It has a key field, a ponter to the parent node, and pointers ti the right and left children of the node</li>
</ul></li>
<li>Binary search trees respect the binary search tree property
<ul>
<li>The key of all the elements in the left subtree of node  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> are smaller or equal to  <img class="inlinemath" src="eqn267.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key" /></li><li>The key of all the elements in the right subtree of node  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> are bigger or equal to  <img class="inlinemath" src="eqn267.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key" /></li></ul></li>
<li>Traversing a BST can be done with different tree walks</li>
<li>The inorder tree walk visits the keys of the BST in sorted order: each key is printed after the key of its left child and before the one of its right child
<ul>
<li>The order is therefore:  <img class="inlinemath" src="eqn305.png" WIDTH=148 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="left \to root \to right" /></li></ul></li>
<li>The preorder tree walk prints first the key of the current node and than the one of its right and lef children in this order
<ul>
<li>The order is therefore:  <img class="inlinemath" src="eqn306.png" WIDTH=148 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="root \to left \to right" /></li></ul></li>
<li>The postorder tree walk prints first the children and then the parent
<ul>
<li>The order is therefore:  <img class="inlinemath" src="eqn307.png" WIDTH=148 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="left \to right \to root" /></li></ul></li>
<li>Tree walks visit all the  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> nodes of the tree so they have always  <img class="inlinemath" src="eqn208.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n)" /> time complexity</li><li>The initial calls of tree walks are with  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> equal to a pointer to the root of the tree</li></ul>
<ul>
<li>Searching for a key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> in a BST means returning a pointer to the node whose key is  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> if it exists, NIL otherwise<ul>
<li>The input of TREE-SEARCH are the root of the tree and the key to be found</li>
<li>I start from the root and compare the key of current node  <img class="inlinemath" src="eqn267.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key" /> with the one to be found  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>If the keys are equal, I return the current node</li>
<li>If  <img class="inlinemath" src="eqn308.png" WIDTH=72 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="k &lt; x.key" /> I call recursively TREE-SEARCH on  <img class="inlinemath" src="eqn276.png" WIDTH=44 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.left" /></li><li>If  <img class="inlinemath" src="eqn309.png" WIDTH=72 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="k &gt; x.key" /> I call recursively TREE-SEARCH on  <img class="inlinemath" src="eqn277.png" WIDTH=53 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.right" /></li><li>If the function is called on NIL (I reached a leaf and call the function on one of its non-existen children), I return NIL</li>
</ul></li>
<li>The running time of TREE-SEARCH is  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" />, where  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> is the height of the tree (which is  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" />)</li></ul>
<ul>
<li>The search function can be equivalently performed also iteratively instead tan with recursion</li>
</ul>
<ul>
<li>Finding the minimum or maximum key in a BST is easy: always go left or always go right (respectively) until you reach a leaf
<ul>
<li>The running time is  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" />, which in the average case equals  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /></li></ul></li>
</ul>
<ul>
<li>If all keys are distinct, the successor of the node  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is defined as the node  <img class="inlinemath" src="eqn311.png" WIDTH=123 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="y = successor(x)" /> such that  <img class="inlinemath" src="eqn312.png" WIDTH=40 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="y.key" /> is the smallest key bigger or equal to  <img class="inlinemath" src="eqn267.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key" /> <ul>
<li>The successor is the node with key just bigger (or equal) to that of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>If  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> has a right subtree, the successor of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is the smallest key of  <img class="inlinemath" src="eqn277.png" WIDTH=53 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.right" /></li><li>If it has not, I need to go up the tree until I find a node that is the left child of its parent
<ul>
<li>If such a node exists, the successor of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is the parent of that node</li></ul></li>
<li>If  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is the biggest element of the tree I return NIL: there is no successor</li></ul></li>
<li>Similarly, the predecessor of a node is defined as the node with key which is the largest among the ones smaller than the key of that node</li>
<li>Successor and predecessor require both  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" /> time, since they at most pass once for each level of the tree</li></ul>
<ul>
<li>Insertion in a BST happens always on the leaves
<ul>
<li>I want to insert a node  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> with key  <img class="inlinemath" src="eqn314.png" WIDTH=70 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="z.key = v" /> into a BST  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /></li><li>I start from the root and maintain 2 pointers
<ul>
<li> <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is the current node</li><li> <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> is the parent of  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> (called trailing pointer)</li></ul></li>
<li>If  <img class="inlinemath" src="eqn315.png" WIDTH=71 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.key &lt; v" /> I move to  <img class="inlinemath" src="eqn277.png" WIDTH=53 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.right" />, else I move to  <img class="inlinemath" src="eqn276.png" WIDTH=44 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.left" /></li><li>When  <img class="inlinemath" src="eqn316.png" WIDTH=80 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x == NIL" /> we are at the correct position<ul>
<li>At this point either  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> is a leaf or it is a node with only 1 child</li><li>If  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> is smaller than  <img class="inlinemath" src="eqn312.png" WIDTH=40 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="y.key" />, then I insert  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> as  <img class="inlinemath" src="eqn318.png" WIDTH=44 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="y.left" />, else I insert it as  <img class="inlinemath" src="eqn319.png" WIDTH=52 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="y.right" /></li></ul></li>
</ul></li>
<li>The running time for insertion is also  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" /> since I go from the root to a leaf</li></ul>
<ul>
<li>Deletion of a node  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> from a BST  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is more complicated than insertion<ul>
<li> <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> can be a leaf, have one child, or have 2 children</li><li>If  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> has no children I just make  <img class="inlinemath" src="eqn320.png" WIDTH=23 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="z.p" /> point to  <img class="inlinemath" src="eqn321.png" WIDTH=36 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="NIL" /> instead of to  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /></li><li>If  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> has 1 child I set the pointer of  <img class="inlinemath" src="eqn320.png" WIDTH=23 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="z.p" /> to the child of  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> instead of to  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> itself<ul>
<li>I also need to update the parent pointer of  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" />’s child</li></ul></li>
<li>If  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> has 2 children it is more complicated<ul>
<li> <img class="inlinemath" src="eqn322.png" WIDTH=123 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="successor(z) = y" /> is the minimum element in  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" />’s right subtree<ul>
<li>Since  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> has 2 children it cannot be otherwise</li></ul></li>
<li> <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> cannot have a left child since there cannot be elements smaller than  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> in that subtree by definition<ul>
<li>Either  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> has no children or it has only a right child</li></ul></li>
<li>I delete  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> from the tree as seen for the cases above and replace  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> with  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> <ul>
<li> <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> will be in the right position when placed in where  <img class="inlinemath" src="eqn313.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="z" /> was, since it is its successor</li></ul></li>
</ul></li>
</ul></li>
<li>To make the code for delete easier to read I define a function called TRANSPLANT
<ul>
<li>It replaces the subtree rooted at  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> with the one rooted at  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /></li></ul></li>
<li>The TREE-DELETE operation also runs in  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" /></li></ul>
<ul>
<li>All the operations in binary search trees are  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" /></li><li>This means that they are fast when the tree is not too deep</li>
</ul>
<h1 id="ivan-lanese-module">Ivan Lanese module</h1>
<hr />
<h2 id="introduction">Introduction</h2>
<ul>
<li>Most algorithms on trees and graphs are recursive</li>
<li>Algorithm efficiency is extremely important when the input size is large</li>
</ul>
<h2 id="balanced-search-trees">Balanced search trees</h2>
<ul>
<li>A balanced tree is a special kind of bynary search tree (BST)
<ul>
<li>A BST must maintain the BST property during updates</li>
<li>The BST property is useful during lookups</li>
</ul></li>
<li>Insertions and deletions in a BST respect the BST property but they can alter the height of the tree
<ul>
<li>I can obtain a tree in which  <img class="inlinemath" src="eqn324.png" WIDTH=68 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="h = O(n)" /> with a sequence of n insertions by adding element with always increasing (or always decreasing) keys</li></ul></li>
<li>A tree built from ordered elements is maximally unbalanced
<ul>
<li>A way to create a generally balanced tree is to randomly permutate the input data when constructing the tree</li>
</ul></li>
<li>Modifications of BST have been developped for maintaining it as balanced as possible</li>
<li>Since most BST operation have a complexity of  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" />, it is important to minimize the height of the tree</li><li>There are variants of BSTs that aim at keeping the tree as balanced as possible, like red-black trees and AVL trees</li>
</ul>
<h3 id="avl-trees">AVL trees</h3>
<ul>
<li>An AVL (Adelson-Velskii and Landis) tree is a BST which is almost balanced
<ul>
<li>It was published by russian scientists in 1962</li>
</ul></li>
<li>It supports INSERT, DELETE, and LOOKUP operations in  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> in the worst case</li><li>For each node  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" />, an AVL tree evaluates the balancing factor  <img class="inlinemath" src="eqn325.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\beta(v)" /> as the difference in height between the left and right subtrees of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" />  <img class="displaymath" src="eqn326.png" WIDTH=283 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \beta(v) = height(v.left) - height(v.right)" /></li><li>A tree is said to be balanced in height if the absolute value of the load factor of each of its nodes is at most 1  <img class="displaymath" src="eqn327.png" WIDTH=246 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" T \mbox{ is balanced} \iff |\beta(v)| \leq 1 \ \forall \ v" /></li><li>An AVL tree is a BST which is balanced in height</li>
<li>The height of an AVL tree is always logarithmic with respect to the number of nodes  <img class="displaymath" src="eqn328.png" WIDTH=177 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" height(AVL) = O(\log n)" /> <ul>
<li>The most unbalanced AVL tree possible is a Fibonacci tree
<ul>
<li>It is a tree in which the heights of the left and right subtrees of the root are the Fibonacci trees of order (height)  <img class="inlinemath" src="eqn329.png" WIDTH=33 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="n_{h-1}" /> and  <img class="inlinemath" src="eqn330.png" WIDTH=34 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="n_{h-2}" /></li><li>The number of nodes in the Fibonacci tree of height  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> is  <img class="displaymath" src="eqn331.png" WIDTH=153 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" n_h = n_{h-1} + n_{h-2} +1" /></li></ul></li>
<li>I want to prove now that a Fibonacci tree of heigh  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> has  <img class="inlinemath" src="eqn332.png" WIDTH=63 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="F_{h+3}-1" /> nodes with  <img class="inlinemath" src="eqn333.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="F_n" /> being the  <img class="inlinemath" src="eqn334.png" WIDTH=23 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="n^{th}" /> Fibonacci number  <img class="displaymath" src="eqn335.png" WIDTH=102 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" n_h = F_{h+3} -1" /></li><li>In the base case I have a Fibonacci tree where  <img class="inlinemath" src="eqn336.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h=0" /></li><li>In this case I have 1 node and it satisfies the stated condition  <img class="displaymath" src="eqn337.png" WIDTH=246 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="n_0 = 1, F_3 = 2 \implies n_0 = F_{0+3} - 1" /></li><li>Induction:  <img class="inlinemath" src="eqn338.png" WIDTH=153 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="n_h = n_{h-1} + n_{h-2} + 1" /> by construction  <img class="displaymath" src="eqn339.png" WIDTH=429 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="n_h = n_{h-1} + n_{h-2} + 1=F_{h+2}-1+F_{h+1}-1+1=F_{h+3}-1" /></li><li>Therefore, any Fibonacci tree has  <img class="inlinemath" src="eqn340.png" WIDTH=63 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="F_{h+3} -1" /> nodes</li><li>Since it is known that  <img class="displaymath" src="eqn341.png" WIDTH=193 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="F_h = \Theta(\phi^h) \qquad, \phi \approx 1.618" /></li><li>Therefore  <img class="displaymath" src="eqn342.png" WIDTH=83 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="n_h = \Theta(\phi^h)" /></li><li>So I can conlude that  <img class="displaymath" src="eqn343.png" WIDTH=124 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(\log{n_h}) = \Theta(h)" />  <img class="displaymath" src="eqn344.png" WIDTH=99 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="h=\Theta(\log{n_h})" /></li><li>Since the height of the most unbalanced possible AVL tree is  <img class="inlinemath" src="eqn345.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(\log{n})" />, the heigh of an AVL tree is  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /></li></ul></li>
<li>Operations in AVL trees are similar to those in BSTs
<ul>
<li>SEARCH is the same as in a generic BST, since it does not modify the AVL property</li>
<li>INSERT and DELETE have to be modified so to maintain the AVL property</li>
<li>The balancing factor is stored in each node and it is updated during INSERT and DELETE operations</li>
</ul></li>
<li>The AVL property is maintained through an operation called rotation
<ul>
<li>A tree rotation does not alter the horizontal arrangement of nodes but only the vertical arrangement</li>
<li>It is a transformation of the tree that preserves the BST property and restores (sometimes in more than 1 passage) the AVL property</li>
<li>It decreases by 1 the heigh of a subtree and increases by one the height of another subtree</li>
<li>It is a movent described always by 3 nodes that pulls them like a string around one of the nodes, which is called pivot</li>
<li>A rotation can be done to the right or to the left, depending on the fact that we pull from the righmost or leftmost node</li>
<li>If the left child of the pivot has a right child, this becomes the left child of the pivot itself after the rotation in a right rotation, and symmetrically in a left rotation</li>
</ul></li>
<li>Unbalances in an AVL 3 can be of 4 types, which are symmetric in pairs: LL, RR, LR, RL
<ul>
<li>An LL unbalance derives from adding a leaf to the left of the left child of a node, and it is symmetric to an RR unbalance</li>
<li>An LR unbalance derives from adding a leaf to the left of the right child of a node, and it is symmetric to an RL unbalance</li>
</ul></li>
<li>Which rotation on sequence of rotations must be applied to an AVL tree after insertions and deletions depends on the kind of inbalance
<ul>
<li>An LL (or RR) unbalance requires only 1 rotation, which is called LL (or RR) rotation
<ul>
<li>An LL rotation is a single right rotation on the unbalanced node, an RR rotation a single left rotation onto it</li>
</ul></li>
<li>An LR (or RL) unbalance requires 2 rotations in sequence, on different pivots
<ul>
<li>I first do a left rotation on the left child of the unbalanced node: this brings me to the LL case</li>
<li>I then do the LL rotation to restore the AVL property: a right rotation on the unbalanced node</li>
</ul></li>
</ul></li>
<li>Insertion in AVL tree is similar to the normal BST insertion, but it also recalculates all the balancing factors that changed and performs the required rotations
<ul>
<li>The balancing factor can change in at most one node per level on the path from the inserted node to the root</li>
<li>The recalculation of the balancing factor is therefore done on each node in the path from the new node to the root, with a  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> time complexity</li><li>If at least one node is critical ( <img class="inlinemath" src="eqn346.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|\beta| &gt; 1" />), I need to rebalance the tree with rotations</li><li>The overall cost of insertion in AVL trees is  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /></li></ul></li>
<li>Deletion in AVL trees is similar to the standard BST deletion, but it is also needed to recalculate the balancing factors that possibly changed and to perform the required rotations
<ul>
<li>Similarly to insertion, the balancing factor needs to be recalculated in at most  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> nodes, in the path from the deleted node to the root</li><li>Critical nodes must be rebalanced with rotations, and rebalancing is performed from the bottom to the top</li>
<li>The overall cost of deletion is  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /></li></ul></li>
<li>Search in an AVL tree is also an  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> operation in the worst case</li></ul>
<h2 id="data-structures-for-working-on-disk">Data structures for working on disk</h2>
<ul>
<li>Large data structures cannot be kept always in memory but instead need to be partially loaded in memory from disk, as needed</li>
<li>Computational time in these cases is heavily dependent on the number of read/write operations, since disk is typically MUCH slower than memory</li>
<li>Some data structures were developped so to minimize disk access operations</li>
</ul>
<h3 id="trees-1">2-3 trees</h3>
<ul>
<li>2-3 trees are a data structure developped for minimizing disk access</li>
<li>It is a tree in which all the internal nodes have 2 or 3 children and all the leaves are at the same depth (the path from the root to each of the leaves has constant lenght)
<ul>
<li>The leaves contain keys and satellite data, and they are sorted in ascending key order from left to right</li>
<li>Each internal node  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> maintains up to 2 pieces of information<ul>
<li> <img class="inlinemath" src="eqn347.png" WIDTH=26 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="v.L" /> is the maximum key contained in the subtree rooted in the left child of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /></li><li>Only if  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> has 3 children,  <img class="inlinemath" src="eqn348.png" WIDTH=32 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="v.M" /> is the maximum key contained in the subtree rooted in the central child of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /></li></ul></li>
</ul></li>
<li>In 2-3 trees internal nodes are small and they can be easily kept in memory and read/written to disk in a single block, while leaves are large since they stire the satellite data
<ul>
<li>Leaves are typically left on disk and read when needed, while the internal nodes are kept in memory</li>
</ul></li>
<li>The height of a 2-3 tree is  <img class="inlinemath" src="eqn304.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(\log n)" /> <ul>
<li>Let  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> be a tree with  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> nodes,  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> leaves and height  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /></li><li>The following inequalities hold  <img class="displaymath" src="eqn349.png" WIDTH=87 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="2^h \leq f \leq 3^h" />  <img class="displaymath" src="eqn350.png" WIDTH=177 HEIGHT=39 STYLE="vertical-align: -12px; margin: 0;" alt="2^{h+1}-1 \leq n \leq \frac{3^{h+1}-1}{2}" /></li><li>If  <img class="inlinemath" src="eqn336.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h=0" /> the number of leaves is  <img class="inlinemath" src="eqn351.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f=1" />, and so  <img class="inlinemath" src="eqn352.png" WIDTH=87 HEIGHT=20 STYLE="vertical-align: -4px; margin: 0;" alt="2^h \leq f \leq 3^h" /> holds</li><li>If  <img class="inlinemath" src="eqn353.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h&gt;0" /> let’s consider the tree  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" /> equal to  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> but without the last level</li><li> <img class="inlinemath" src="eqn355.png" WIDTH=15 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="n'" /> and  <img class="inlinemath" src="eqn356.png" WIDTH=16 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f'" /> are respectively the number of nodes and leaves in  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" /></li><li>Every leaf in  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" /> can have either 2 or 3 children in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" />, so assuming that  <img class="inlinemath" src="eqn357.png" WIDTH=121 HEIGHT=20 STYLE="vertical-align: -4px; margin: 0;" alt="2^{h-1} \leq f' \leq 3^{h-1}" /> I observe that  <img class="displaymath" src="eqn358.png" WIDTH=295 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="2*2^{h-1} \leq f \leq 3*3^{h-1} \implies 2^h \leq f \leq 3^h" /></li><li>For the second inequality, when  <img class="inlinemath" src="eqn336.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h=0" /> the number of nodes in the tree is  <img class="inlinemath" src="eqn359.png" WIDTH=41 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="n=1" /> and so  <img class="inlinemath" src="eqn360.png" WIDTH=158 HEIGHT=26 STYLE="vertical-align: -7px; margin: 0;" alt="2^{h+1}-1 \leq n \leq \frac{3^{h+1}-1}{2}" /> holds</li><li>If  <img class="inlinemath" src="eqn353.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h&gt;0" /> I do the inductive assumption that (resuming the tree  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" /> used before)  <img class="inlinemath" src="eqn361.png" WIDTH=134 HEIGHT=26 STYLE="vertical-align: -7px; margin: 0;" alt="2^h-1 \leq n' \leq \frac{3^h-1}{2}" /></li><li>I observe that  <img class="inlinemath" src="eqn362.png" WIDTH=77 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="n = n'+f" /> and  <img class="inlinemath" src="eqn356.png" WIDTH=16 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f'" /> is under the previously computed bound  <img class="inlinemath" src="eqn352.png" WIDTH=87 HEIGHT=20 STYLE="vertical-align: -4px; margin: 0;" alt="2^h \leq f \leq 3^h" /></li></ul></li>
</ul>
<p> <img class="displaymath" src="eqn363.png" WIDTH=302 HEIGHT=39 STYLE="vertical-align: -12px; margin: 0;" alt=" (2^h-1)+(2^h) \leq n'+f \leq (\frac{3^h-1}{2})+(3^h)" />  <img class="displaymath" src="eqn364.png" WIDTH=189 HEIGHT=39 STYLE="vertical-align: -12px; margin: 0;" alt=" 2^{h+1}-1 \leq n \leq (\frac{3^{h+1}-1}{2})" /></p><ul>
<li>Search in a 2-3 tree is performed as follows, by calling initially 23-SEARCH on the root of the tree</li>
</ul>
<ul>
<li>Insertion of a key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> in a 2-3 tree procedes as follows<ul>
<li>I create a leaf  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> with key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>I use 23-SERACH to find a node  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> on the penultimate level that will become the father of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /></li><li>If  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> has not 3 children, I add  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> to it at the appropriate position</li><li>If  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> has 3 children already, I perform a splitting operation, that can also propagate back until the root</li><li>It takes  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> to find the father of the new node and  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> to do the each split</li><li>In the worst case I need to do  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> splits on the path from  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> back until the root</li><li>The overall insertion cost is  <img class="inlinemath" src="eqn151.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log{n})" /></li></ul></li>
<li>Deletion of a leaf  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> with key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> in a 2-3 tree procedes as follows<ul>
<li>I remove  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> by detaching it from its father  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /></li><li>If  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> had 2 children it will remain with just 1 child, violating the 2-3 property: in this case I need to merge  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> with a neighbor</li><li>The merging operations could propagate back until the root</li>
<li>Also deletion has an  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> cost</li></ul></li>
</ul>
<h3 id="b-trees">B trees</h3>
<ul>
<li>B trees are similar to 2-3 trees but used for even larger amounts of data, when also the keys themselves are too many to be kept in memory</li>
<li>They are typically used to manage large sets of ordered keys</li>
<li>A variant of B trees, called B+ trees, are an exact generalization of 2-3 trees and they are used in many filesystems and relational databases</li>
<li>Differently from 2-3 trees, B trees store keys and also satellite data in the internal nodes
<ul>
<li>B+ trees store satellite data only on the leaves</li>
</ul></li>
<li>Each node in a B tree can have a large number of children
<ul>
<li>They have a huge branching factor, they can have thousands of children per node</li>
<li>Thanks to the high branching factor, B trees can index vast amounts of data on disk, thus reducing the number of I/O operations</li>
</ul></li>
<li>B-trees are used for indexing large, slow storage disks</li>
<li>In general I cannot read a single byte from a disk, data is read in sectors
<ul>
<li>Also SSDs have a minimal access unit, the block</li>
</ul></li>
<li>A constant number of sectors is kept in memory at any given time for a B tree, regardless of its size</li>
<li>The grade  <img class="inlinemath" src="eqn365.png" WIDTH=38 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="t \geq 2" /> of a B tree is the minimum number of children that each node different from the root can have<ul>
<li>We select the grade so that each node can be as large as possible but fit in a single sector on the disk</li>
<li>The grade is constant for the whole tree</li>
<li>The root has from 1 to  <img class="inlinemath" src="eqn366.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="2t-1" /> children</li></ul></li>
<li>A B tree with grade  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> has the following properties<ul>
<li>All the leaves have the same depth</li>
<li>Every node  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> different from the root maintains  <img class="inlinemath" src="eqn368.png" WIDTH=25 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v.n" /> ordered keys with  <img class="inlinemath" src="eqn369.png" WIDTH=145 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="t-1 \leq v.n \leq 2t-1" /> <ul>
<li>These are  <img class="inlinemath" src="eqn370.png" WIDTH=180 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="v.key_1, v.key_2,...,v.key_{v.n}" /></li></ul></li>
<li>The root has at least 1 and at most  <img class="inlinemath" src="eqn366.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="2t-1" /> children</li><li>Every internal node  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> has  <img class="inlinemath" src="eqn371.png" WIDTH=52 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="v.n+1" /> children</li><li>The keys  <img class="inlinemath" src="eqn372.png" WIDTH=40 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="v.key" /> split the intervals of keys stored in every subtree<ul>
<li>The keys stored in the first subtree are smaller than the first key of the node, the ones in the second subtree are between the first and the second key, and so on</li>
</ul></li>
</ul></li>
<li>In general the branching factor of a B tree is choosen so that a single node occupies a whole disk block and can be read/written to disk in a single operation
<ul>
<li>Typical branching factors are between 50 and 2000</li>
<li>The number of I/O operations is  <img class="inlinemath" src="eqn153.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(h)" />, since in general I perform one operation per node</li></ul></li>
<li>The heigh of a B-tree with  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> keys is  <img class="displaymath" src="eqn373.png" WIDTH=103 HEIGHT=37 STYLE="vertical-align: -12px; margin: 0;" alt="h \leq \log_t \frac{n+1}{2}" /> <ul>
<li>Given a B tree of grade  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" />, the higest possible tree is the one with fewer children per node</li><li>A B tree of grade  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> as a minimum of  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> children per node, by definition</li><li>The smallest B tree of grade  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> has exactly  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> children per internal node and 1 on the root</li><li>A tree with 1 node has depth 0</li>
<li>A tree of 2 nodes has depth 1</li>
<li>A tree of  <img class="inlinemath" src="eqn374.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2t" /> nodes has depth 2</li><li>A tree of  <img class="inlinemath" src="eqn375.png" WIDTH=22 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2t^2" /> nodes has depth 3</li><li>A tree of  <img class="inlinemath" src="eqn376.png" WIDTH=35 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2t^{i-1}" /> nodes has depth  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /></li><li>The minimum total number of nodes in a B tree of height  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> is therefore  <img class="displaymath" src="eqn377.png" WIDTH=90 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" 1+\sum_{i=1}^h 2t^{i-1}" /></li><li>All the internal nodes (except the root) contain exactly  <img class="inlinemath" src="eqn378.png" WIDTH=36 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="t-1" /> keys</li><li>The total number of keys  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> satisfies  <img class="displaymath" src="eqn379.png" WIDTH=393 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" n \geq 1+(t-1) \sum_{i=1}^h2t^{i-1} = 1+2(t-1) \frac{t^h-1}{t-1} = 2t^h-1" /></li><li>This is because  <img class="displaymath" src="eqn380.png" WIDTH=183 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt="\sum_{i=1}^h t^{i-1} = \sum_{i=0}^{h-1} t^i = \frac{t^h-1}{t-1}" /></li><li>Now, since  <img class="inlinemath" src="eqn381.png" WIDTH=83 HEIGHT=19 STYLE="vertical-align: -3px; margin: 0;" alt="n \geq 2t^h-1" /> we get that  <img class="displaymath" src="eqn382.png" WIDTH=78 HEIGHT=37 STYLE="vertical-align: -12px; margin: 0;" alt=" t^h \leq \frac{n+1}{2}" />  <img class="displaymath" src="eqn383.png" WIDTH=103 HEIGHT=37 STYLE="vertical-align: -12px; margin: 0;" alt=" h \leq \log_t \frac{n+1}{2}" /></li></ul></li>
<li>In the following pseudocodes I am assuming that the root is always in memory, and unused blocks are discarded from memory automatically</li>
<li>The operations DISK-READ and DISK-WRITE are used to retrieve and write data from disk</li>
<li>The search operation of the key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> in a B tree is a generalization of the BST search<ul>
<li>At each recursion I search for  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> in the current node</li><li>If I find  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> I stop</li><li>If  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> is not contained in the node I descend into the appropriate subtree of the current node</li><li>The number of visited nodes is  <img class="inlinemath" src="eqn384.png" WIDTH=65 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log_t n)" /></li><li>Each visit costs  <img class="inlinemath" src="eqn385.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(t)" /> since I need to scan all the keys in the node</li><li>The total cost of BTREE-SEARCH is  <img class="inlinemath" src="eqn386.png" WIDTH=68 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(t log_t n)" /></li><li>Note that the keys on any given node are sorted: I can do a binary search instead of a linear search to identify the right one
<ul>
<li>Binary search takes  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /></li><li>In this case the total complexity will be  <img class="inlinemath" src="eqn387.png" WIDTH=178 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log t \log_t n)=O(\log n)" /> (using the change of base formula)</li></ul></li>
<li>I search the leaf  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> in which I can insert the key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>If the leaf is not full (less than 2t-1 keys) I insert  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> in the correct position</li><li>If it is full I split the leaf  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> <ul>
<li>I put the key number  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> of  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> to  <img class="inlinemath" src="eqn388.png" WIDTH=63 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f.parent" /> <ul>
<li>If  <img class="inlinemath" src="eqn389.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f.p" /> is full I need to split it and recurse</li><li>In the worst case this will split the root and generate a new one</li>
</ul></li>
</ul></li>
<li>I cannot use binary search in this case since I cannot split an array in that way, I need to copy half of its elements in  <img class="inlinemath" src="eqn385.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(t)" /></li><li>Total cost is  <img class="inlinemath" src="eqn390.png" WIDTH=74 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(t \log_t{n})" /></li></ul></li>
</ul>
<ul>
<li>Insertion in B trees happens always in the leaves
<ul>
<li>I search for the leaf  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> in which to insert the key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>If the selected leaf is not full (it has less than  <img class="inlinemath" src="eqn366.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="2t-1" /> keys) I insert  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> into it</li><li>If the leaf has already  <img class="inlinemath" src="eqn366.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="2t-1" /> keys I need to split the nodes<ul>
<li>The leaf  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> is split into 2 and the key number  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> is moved to the father of  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /></li><li>If also the father is full, the split backpropagates, possibly until the root</li>
<li>In the worst case the split propagates to the root, which is also full and needs to be split, generating a new root</li>
</ul></li>
<li>In total I am visiting  <img class="inlinemath" src="eqn384.png" WIDTH=65 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log_t n)" /> nodes in the worst case</li><li>Each visit has a cost of  <img class="inlinemath" src="eqn385.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(t)" /> because of the split operations</li><li>The total cost of B tree insertion is  <img class="inlinemath" src="eqn391.png" WIDTH=74 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(t \log_t n)" /></li><li>To minimize disk access, I actually split all the full nodes (nodes with  <img class="inlinemath" src="eqn366.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="2t-1" /> children) in the path to the leaf, regardless to the fact that it is needed or not<ul>
<li>This allows to perform the insertion with a single pass down the tree</li>
<li>In this way, every time that I need to split a node, I am sure that its parent cannot be full</li>
</ul></li>
<li>The only way for a B tree to increase in height is through a split of its root</li>
</ul></li>
<li>Deletion in a B tree is different depending if the key  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> to be deleted is in an internal node or in a leaf<ul>
<li>If  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> is in a leaf  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> <ul>
<li>If the leaf has more than  <img class="inlinemath" src="eqn392.png" WIDTH=20 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="t-" /> keys, I just remove  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>If the leaf has exactly  <img class="inlinemath" src="eqn378.png" WIDTH=36 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="t-1" /> keys there are 2 cases according on the adjacent brothers of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> <ul>
<li>If at least 1 of the adjacent brothers of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> has more than  <img class="inlinemath" src="eqn378.png" WIDTH=36 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="t-1" /> keys I redistribute the keys and perform the deletion of  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>Note that the redistribution involves one brother of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> and also  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" />’s parent!</li><li>If not, I perform a fusion operation of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> with one of the brothers and one key from  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" />’s parent</li></ul></li>
</ul></li>
<li>If  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> is in an internal node  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> <ul>
<li>I find a node containing the predecessor of  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" />, which is necessarily on a leaf</li><li>I copy the max key in  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> in the place of  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" />, which is thus deleted</li><li>I delete the original copy of the predecessor of  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" />, which is on a leaf, using the procedure already seen</li></ul></li>
<li>Also the cost of deletion in B trees is  <img class="inlinemath" src="eqn391.png" WIDTH=74 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(t \log_t n)" /> in the worst case</li><li>Also in deletion, I want to be able to operate in a single pass down the tree
<ul>
<li>I assure that whenever BTREE-DELETE is called on a node, that node has at least  <img class="inlinemath" src="eqn367.png" WIDTH=8 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="t" /> children (1 more than the minimum required of  <img class="inlinemath" src="eqn378.png" WIDTH=36 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="t-1" />)</li><li>This means that I can be sure that I can fuse to nodes without making their parent violate the B tree property</li>
<li>If the root ever becomes without any key, it is deleted and the tree decreases its height</li>
</ul></li>
</ul></li>
</ul>
<h2 id="graphs-and-visits">Graphs and visits</h2>
<ul>
<li>A graph  <img class="inlinemath" src="eqn393.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G = (V,E)" /> is composed of a set of verteces  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /> and edges  <img class="inlinemath" src="eqn395.png" WIDTH=79 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="E \subset V*V" /></li><li>An edge  <img class="inlinemath" src="eqn396.png" WIDTH=68 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="e = (u,v)" /> is defiend by a pair of veritices</li><li>An edge is said to be directed if it is composed by an ordered pair of verteces</li>
<li>An edge is said to be undirected if it is composed by an unordered pair of verteces</li>
<li>A graph is said undirected if all of its edges are undirected</li>
<li>A graph is directed if all of its edges are directed</li>
<li>Two verteces are said to be adjacent if they are connected by an edge</li>
<li>The degree of a vertex is equal to the number of adjacent verteces it has</li>
<li>The sum of the degree of all the verteces is two times the number of edges  <img class="displaymath" src="eqn397.png" WIDTH=234 HEIGHT=41 STYLE="vertical-align: -21px; margin: 0;" alt=" \sum_{v \in V} deg(v) = 2 (\mbox{number of edges})" /></li><li>A path is a sequence of verteces  <img class="inlinemath" src="eqn398.png" WIDTH=86 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="V_1,V_2,...,V_k" /> such that  <img class="inlinemath" src="eqn399.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="V_i" /> and and  <img class="inlinemath" src="eqn400.png" WIDTH=32 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="V_{I+1}" /> are adjacent</li><li>A simple path is a path that does not contain repeated verteces (it does not pass twice on the same vertex)</li>
<li>A cycle is a simple path, except for the fact that the start and end vertex are the same</li>
<li>A connected graph is a graph in which any 2 verteces are connected by a path</li>
<li>A sub-graph is a subset of verteces and edges forming a graph</li>
<li>A graph does not necessarily need to be connected
<ul>
<li>There can be verteces or sub-graphs that don’t have edge between them</li>
</ul></li>
<li>A connected component is a maximal connected subgraph
<ul>
<li>Two verteces are in the same connected compenent iff there is a path between them</li>
</ul></li>
<li>A directed graphs is said to be strongly connected if for every pair of verteces  <img class="inlinemath" src="eqn401.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="u,v" /> there is a path from  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> to  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> and from  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> to  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /></li><li>The strongly connected components of a directed graph are its maximal strongly connected sub-graphs
<ul>
<li>The strongly connected components form a partition of the graph</li>
</ul></li>
<li>A tree is a connected graph without cycles</li>
<li>A forest is a collection of trees</li>
<li>Both trees and forests are special cases of graphs</li>
<li>Fundamental graph operations are
<ul>
<li>Create a new graph: CREATE( <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" />)</li><li>Return True if a graph is empty, False otherwise: EMPTY( <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" />)</li><li>Insert a new vertex: INS-VERTEX( <img class="inlinemath" src="eqn403.png" WIDTH=30 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="G,v" />)</li><li>Insert a new edge: INS-EDGE( <img class="inlinemath" src="eqn404.png" WIDTH=58 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="G,v_1,v_2" />)</li><li>Delete an existing vertex: DEL-VERTEX( <img class="inlinemath" src="eqn403.png" WIDTH=30 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="G,v" />)</li><li>Delete an existing edge: DEL-EDGE( <img class="inlinemath" src="eqn404.png" WIDTH=58 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="G,v_1,v_2" />)</li><li>Return the set of adjacent verteces of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" />: ADJ-SET( <img class="inlinemath" src="eqn403.png" WIDTH=30 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="G,v" />)</li></ul></li>
<li>I can represent a graph with an adjacency matrix  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> <ul>
<li>It is a boolean matrix where  <img class="inlinemath" src="eqn406.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="M[i,j]" /> is True if the edge  <img class="inlinemath" src="eqn407.png" WIDTH=34 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(i,j)" /> exists in the graph, False otherwise</li><li>The space requirement of the adjacency matrix is  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" />, where  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> is the number of verteces in the graph</li><li>An adjancency matrix representation is preferred when the grpah is dense ( <img class="inlinemath" src="eqn408.png" WIDTH=75 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="|E| \approx |V|^2" />), or when I need to quickly tell if 2 verteces are connected</li></ul></li>
<li>I can represent a graph also with adjacency lists
<ul>
<li>The adjacency list of a vertex  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> is the list of verteces adjacent to it</li><li>A graph is represented by the adjacency lists of all of its verteces</li>
<li>The space requirement for the adjacency list of a graph is  <img class="inlinemath" src="eqn409.png" WIDTH=213 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n+\sum deg(v) = \Theta(n+m))" /> <ul>
<li> <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> is the number of verteces in the graph,  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> the number of edges</li></ul></li>
<li>The adjacency list representation is preferred for sparse graphs
<ul>
<li>A sparse graph is a graph in which  <img class="inlinemath" src="eqn410.png" WIDTH=80 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|V| &gt;&gt; |E|" /></li></ul></li>
</ul></li>
<li>I can represent a graph using an adjacency set
<ul>
<li>An adjacency set is composed by a vector of verteces and a vector of edges</li>
<li>The space requirement for an adjacency set is also  <img class="inlinemath" src="eqn411.png" WIDTH=70 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(n+m)" /></li><li>The verteces vector contains for each vertex the address, in the edges vector, of where the adjacent verteces of the current vertex are listed</li>
<li>In low-level programming languages I also need to keep track of the end of the array, so I need to insert in the verteces array a fake node that points to the last position of the edges vector</li>
<li>I can use the verteces vector to parse correctly the edges vector</li>
<li>The edges vector contains the address of the adjacent verteces for each vertex in the verteces vector, in a continuous uninterrupted array</li>
</ul></li>
<li>A graph traversal is the process of visiting all the verteces of a graph</li>
<li>There are 2 common graph traversal algorithms: breadth-first serach (BFS) and depth-first search (DFS)</li>
<li>Breadth-first search (BFS), given a source vertex  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" />, explores all the verteces adjacent to  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" />, and then all the verteces adjacent to those, iteratively<ul>
<li>Vertices are explored in order of increasing distance from the source  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> <ul>
<li>The distance of a vertex from the source  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> is the number of edges in the path from  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> to the vertex</li></ul></li>
<li>At the beginning all the verteces are undiscovered (they are said to be WHITE)</li>
<li>I start from vertex  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" />, I put it in the queue  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> and I mark it as discovered (referred to as GREY)</li><li>Until there is somenthing in  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> I dequeue one vertex  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> from it and I loop on the verteces  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> into its adjacency set<ul>
<li>If the vertex  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> in the set is WHITE I mark it as GREY (I discovered it) and I enqueue  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> in  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /></li></ul></li>
<li>When all the adjacency set of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> is GREY I mark  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> as BLACK</li><li>BFS works iteratively until the whole graph is BLACK (I discovered all the vertices)</li>
<li>BFS produces a breadth-first tree of the graph by adding verteces and edges to it when they are discovered</li>
<li>BFS tells me also which verteces are connected to the source  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /></li><li>If the graph is implemented with and adjacency list the time complexity of BFS is  <img class="inlinemath" src="eqn414.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n+m)" /> <ul>
<li>Each vertex in the graph is marked only once</li>
<li>For each vertex, I explore once its adjacency set</li>
<li>The size of the adjacency set of the whole graph is  <img class="inlinemath" src="eqn415.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m)" /> since  <img class="inlinemath" src="eqn416.png" WIDTH=252 HEIGHT=21 STYLE="vertical-align: -7px; margin: 0;" alt="\sum_{v \in V} deg(v) = 2 (\mbox{number of edges})" /></li></ul></li>
<li>If the graph is implemented with and adjacency matrix the time complexity of BFS is  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /> <ul>
<li>For each of the  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> verteces, I need to scan its whole adjacency array of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> elements</li><li>With an adjacency matrix the complexity is independent from the number of edges in the graph</li>
</ul></li>
</ul></li>
</ul>
<ul>
<li>Depth-first search (DFS), given a source vertex  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" />, explores recursively all the verteces adjacent to  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> <ul>
<li>When I visit a vertex  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> from the vertex  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" />, I recursively visit all the unvisited neighbors of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /></li><li>When there are no more unvisited neighbors to explore, I backtrack to  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and give control to the upper recursion level</li><li>In general, differently from BFS, DFS is used on the entire graph in order to produce a DFS forest of DFS trees, one for each connected component</li>
<li>DFS also create timestamps that record when a given vertex was discovered ( <img class="inlinemath" src="eqn417.png" WIDTH=24 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="v.d" />) and when it was blackened ( <img class="inlinemath" src="eqn418.png" WIDTH=25 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="v.f" />)<ul>
<li>Any vertex  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> is WHITE before time  <img class="inlinemath" src="eqn417.png" WIDTH=24 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="v.d" />, GREY between time  <img class="inlinemath" src="eqn417.png" WIDTH=24 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="v.d" /> and time  <img class="inlinemath" src="eqn418.png" WIDTH=25 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="v.f" />, and BLACK after time  <img class="inlinemath" src="eqn418.png" WIDTH=25 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="v.f" /></li></ul></li>
<li>The time complexity is  <img class="inlinemath" src="eqn414.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n+m)" /> with an adjacency list and  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /> with an adjacency matrix for the same considerations made for BFS</li></ul></li>
</ul>
<h2 id="topological-sorting">Topological sorting</h2>
<ul>
<li>A dependency graph is a graph representing casual dependencies between tasks</li>
<li>In general, tasks to be completed can be arranged into a directed acyclic graph (DAG)
<ul>
<li>Each task is represented by a vertex</li>
<li>A directed edge in the DAG represent a casual dependecy relationship between tasks</li>
</ul></li>
<li>Tasks dependencies cannot be represented by a cyclic graph: there would be an infinite loop</li>
<li>Given a DAG  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" />, an ordered set of verteces  <img class="inlinemath" src="eqn420.png" WIDTH=131 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=\{v_1,v_2,...,v_n\}" /> is a topological sorting iff<ul>
<li>It contains all the verteces in  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" />  <img class="displaymath" src="eqn421.png" WIDTH=163 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="s=\{v_1,v_2,...,v_n\}=V" /></li><li>There is no path from  <img class="inlinemath" src="eqn422.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -5px; margin: 0;" alt="v_j" /> to  <img class="inlinemath" src="eqn423.png" WIDTH=14 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="v_i" /> for all the  <img class="inlinemath" src="eqn424.png" WIDTH=37 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i &lt; j" /></li><li>Equivalently, I can say that if there is an edge  <img class="inlinemath" src="eqn401.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="u,v" /> then  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> must appear before  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> in the topological sorting</li></ul></li>
<li>A series of tasks can be executed in topological order without violating any dependency</li>
<li>There can be more than 1 topological sorting for a given DAG</li>
<li>Topological sorting algorithms add verteces one by one at the beginning of tha list such that any given vertex is added only after all the nodes reachable from it have been added</li>
<li>The algorithm that we will see uses a modified version of DFS to find nodes that are reachable from the current node</li>
</ul>
<h2 id="greedy-algorithms">Greedy algorithms</h2>
<ul>
<li>Algorithms for optimization problems typically go through a series of steps, with a set of choices at each step</li>
<li>For some optimization problems a dynamic programming approach is not needed, since a simpler and more efficient approach will suffice</li>
<li>A greedy algorithm always makes the choice that looks best at the moment</li>
<li>It makes a locally optimal choice with the hope that it will lead to a globally optimal solution</li>
<li>Greedy algorithms can lead to a globally optimal solutions in some problems, but in general they are not guaranteed to do so in any possible problem</li>
<li>Usually greedy algorithms are easy to design and write</li>
<li>The basic steps of the greedy approach are first defining a problem and the greedy strategy for solving it, and then showing that the greedy approach leads to an optimal solution</li>
<li>A problem is said to have optimal substructure if it is possible to find a globally optimal solution to it by combining optimal solutions to its sub-problems</li>
<li>For a problem to be solvable with a greedy approach, it is necessary but not sufficient that it has an optimal substructure</li>
<li>Problems that can be solved with a greedy approach are said to repsect the greedy choice property: locally optimal choices are optimal also globally</li>
</ul>
<h3 id="the-knapsack-problem">The knapsack problem</h3>
<ul>
<li>The problem is formulated as follows: a thief breaks into a museum and sees many items, of which he knows exactly the value and the weight. The thief has only a single knapsack with him, and he can take away only what he is able to carry with his knapsack. He is able to carry only items up to a certain total weight and he wants to maximise the value of the knapsack content. Items cannot be sub-divided, but just taken or not. The problem consists in finding the optimal set of items that will respect the weight contraint and maximize the value of the knapsack content.</li>
<li>This problem formulation is said 0-1 knapsack problem since it is the whole or none variant, in which items cannot be split up.</li>
<li>More formally, the problem can be formulated as: among a set of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> items, where item  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> has value  <img class="inlinemath" src="eqn425.png" WIDTH=47 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="v_i \in \mathbb{N}" /> and weigth  <img class="inlinemath" src="eqn426.png" WIDTH=51 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="w_i \in \mathbb{N}" />, find the subset of items that maximises the total value  <img class="inlinemath" src="eqn427.png" WIDTH=42 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sum_i v_i" /> while respecting a total weight contraint  <img class="inlinemath" src="eqn428.png" WIDTH=52 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W \in \mathbb{N}" /> such that  <img class="inlinemath" src="eqn429.png" WIDTH=86 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sum_i w_i \leq W" /></li><li>The 0-1 knapsack problem cannot be solved with a greedy approach, but it can be solved with dynamic programming</li>
<li>It shows optimal substructure but it does not have a greedy choice property</li>
<li>The fractional knapsack problem is similar to the 0-1 knapsack problem with one fundamental difference: it is possible to take fractions of items</li>
<li>The formulation is usually stated similarly to the one for the 0-1 knapsack, but instead of undividable items it is said that the thief wants to maximize the value of the dust of gold and other precious metals that he can carry</li>
<li>Formally we can define the problem as: among a set of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> items, where item  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> has value  <img class="inlinemath" src="eqn425.png" WIDTH=47 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="v_i \in \mathbb{N}" /> and  <img class="inlinemath" src="eqn426.png" WIDTH=51 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="w_i \in \mathbb{N}" /> amount (in weight) is available of it, find the set of fractions of items that maximises the total value  <img class="inlinemath" src="eqn430.png" WIDTH=68 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sum_i v_i*t_i" /> with  <img class="inlinemath" src="eqn431.png" WIDTH=51 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="t_i \leq w_i" /> being the amount of item  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> taken, while respecting a total weight contraint  <img class="inlinemath" src="eqn428.png" WIDTH=52 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W \in \mathbb{N}" /> such that  <img class="inlinemath" src="eqn432.png" WIDTH=80 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sum_i t_i \leq W" /></li><li>The fractional knapsack problem can be solved with a greedy approach
<ul>
<li>I first choose the item with the highest unitary value and take as much of it as possible</li>
<li>If the I still have space in the knapsack after having taken all of the most precious item, I proceed with the second most valuable item and so on until the knapsack is full (until  <img class="inlinemath" src="eqn433.png" WIDTH=86 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sum_i w_i = W" />)</li></ul></li>
<li>The greedy approach is optimal in this case since it ensures that the knapsack will always be full (if there are enough items to fill it) and replacing any of the items choosen with any other possible item will decrease the total value of the knapsack</li>
<li>This is the pseudocode for a possible greedy algorithm for the fractional case of the knapsack problem</li>
</ul>
<h3 id="huffman-codes">Huffman codes</h3>
<ul>
<li>Huffman codes are effective ways to compress sequences of characters with a 20% to 90% compression ratio</li>
<li>The Huffman greedy algorithm uses a table of character frequencies in the data to built an optimal space-efficient binary representation of each character</li>
<li>I can represent each possible charachter present in the message with an unique binary string called codeword</li>
<li>If I choose to use fixed-length codewords, for an alphabet of 6 different characters I would need 3 bits per character ( <img class="inlinemath" src="eqn434.png" WIDTH=77 HEIGHT=19 STYLE="vertical-align: -3px; margin: 0;" alt="2^3 = 8 \geq 6" /> while  <img class="inlinemath" src="eqn435.png" WIDTH=77 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^2 = 4 &lt; 6" />)</li><li>With a variable-lenght code I can reach a greater efficency by reducing the average number of bits per character below 3
<ul>
<li>It would be efficient to assign a short codeword to frequent characters and a longer codeword to rare characters</li>
</ul></li>
<li>We will restrict our attention to binary codes in which no codeword is also a prefix of some other codeword
<ul>
<li>These codes are called, somewhat counter-intuitively, prefix codes</li>
<li>It can be proven that a prefix code can always achieve optimal data compression among any character code, so we are not suffering a loss in generality by limiting ourselves to prefix codes</li>
<li>Prefix codes are desirable since the decoding of characters from a binary string is unambiguous</li>
</ul></li>
<li>In Huffmann codes, I represent all the codewords in a given message as leaves in a binary tree
<ul>
<li>A codeword is interpreted as the simple path from the root to the corresponding leaf, where each left turn corresponds to a 0 and each right turn to a 1</li>
<li>Note that these trees are not BSTs, since leaves do not appear in sorted order and internal nodes do not contain any key</li>
</ul></li>
<li>Given an Huffman tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" />, I can compute the number of bits needed to encode a file<ul>
<li>For each charachter  <img class="inlinemath" src="eqn436.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="c" /> in the alphabet  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" />, let  <img class="inlinemath" src="eqn438.png" WIDTH=47 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="c.freq" /> be the frequency of the charachter in the file and  <img class="inlinemath" src="eqn439.png" WIDTH=38 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_T(c)" /> denote the depth of the leaf corresponding to  <img class="inlinemath" src="eqn436.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="c" /> in the tree</li><li>Note that  <img class="inlinemath" src="eqn439.png" WIDTH=38 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_T(c)" /> is also the lenght of the codeword for character  <img class="inlinemath" src="eqn436.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="c" /></li><li>The number of bits required for encoding the file is thus  <img class="displaymath" src="eqn440.png" WIDTH=185 HEIGHT=41 STYLE="vertical-align: -21px; margin: 0;" alt="B(T) = \sum_{c \in C} c.freq*d_T(c)" /></li><li> <img class="inlinemath" src="eqn441.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(T)" /> is also defined as the cost of the tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /></li></ul></li>
<li>The Huffman tree for a message can be built using the greedy Huffman algorithm
<ul>
<li>It works on an alphabet  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /></li><li>It uses a min-priority queue  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> keyed on the  <img class="inlinemath" src="eqn442.png" WIDTH=35 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="freq" /> attribute</li><li>It starts from a set of  <img class="inlinemath" src="eqn443.png" WIDTH=23 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|C|" /> leaves</li><li>It merges together leaves starting from the least frequent ones</li>
<li>The frequency of an internal node is built from the sum of the frequencies of all the leaves under it</li>
</ul></li>
</ul>
<h2 id="dynamic-programming">Dynamic programming</h2>
<ul>
<li>Dynamic programming, similarly to the divide-et-impera approach, solves problems by finding the solution to sub-problems
<ul>
<li>“Programming” here refers to the use of a matrix, not to computer programming (this is the same also in linear programming)</li>
<li>It was formalized in the 1950s by R. Bellman</li>
</ul></li>
<li>While divide-et-impera is used to solve problems made up of disjoint sub-problems, dynamic programming is used when the sub-problems overlap
<ul>
<li>This is, in dynamic programming sub-problems share sub-sub-problems</li>
<li>In this context a divide-et-impera approach wastes resources by solving multiple times the same sub-problems</li>
<li>Dynamic programming stores intermediate solution and so avoids to solve multiple times the same sub-problems</li>
<li>While divide-et-impera is typically done recursively and from the top-down, dynamic programmic is typically implemented iteratively and from the bottom-up</li>
</ul></li>
<li>Problems that can be solved with dynamic programming are typically optimization problems
<ul>
<li>These have many possible solutions, each associated one with a different value</li>
<li>We want to find the solution with associated value that is minimal/maximal (according to the problem) in the set of possible solution values</li>
<li>This solution is called <strong>an</strong> optimal solution instead as <strong>the</strong> optimal solution, since there can be many equally optimal solutions</li>
</ul></li>
<li>Developping a dynamic programming algorithm is done in a sequence of 4 steps
<ul>
<li>Describe what the structure of an optimal solution should be</li>
<li>Define the value of the optimal solution recursively</li>
<li>Compute the value of an optimal solution, typically from the bottom-up</li>
<li>Contruct the optimal solution from the computed information
<ul>
<li>This step can be omitted if I am only interested in the value of an optimal solution</li>
</ul></li>
</ul></li>
<li>For a problem to be solvable with dynamic programming, it has to have some key characteristics
<ul>
<li>It should show optimal substructure</li>
<li>It should have overlapping sub-problems</li>
</ul></li>
<li>A problem is said to show optimal substructure if a solution to the problem contains the solution to its sub-problems</li>
<li>To show that a problem has an optimal substructure a common pattern is followed
<ul>
<li>First I show that the solution to the problem consists in making a choice, and this choice leaves one or more similar sub-problems to be solved</li>
<li>Then I suppose that I know what is the optimal choice for the problem, the one that leads to an optimal solution</li>
<li>Given the optimal choice, I determine which sub-problems I should solve and how can I characterize the space of sub-problems
<ul>
<li>Characterizing the space of sub-problems means to define the parameter space relevant for the problem (in the 0-1 knapsack problem this corresponds to all the possible combinations of the maximum weight of the knapsack  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> and the subset of items up to  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" />)</li></ul></li>
<li>I show by contradiction that the solution to sub-problems used for finding an optimal solution to the problem must be themselves optimal
<ul>
<li>I show that the solution of the problem obtain from sub-optimal solution to its sub-problems can be improved by choosing an optimal sub-problem solution, thus showing that the original problem solution was sub-optimal</li>
</ul></li>
</ul></li>
<li>A problem solvable with dynamic programming has independent and overlapping sub-problems
<ul>
<li>Sub-problems are independent in the sense that they do not share resources</li>
<li>Sub-problems overlap in the sense that the same problem occurs as sub-problem of different problems
<ul>
<li>I can take advantage of this by storing the result of sub-problems</li>
</ul></li>
<li>A problem with overlapping sub-problems shows a small sub-problem space
<ul>
<li>This is because the recursive solution to sub-problems incurs again and again in the same sub-problems</li>
<li>Quantitatively, the sub-problem space is typically polynomial on input size</li>
<li>A problem with optimal sub-structure but non-overlapping sub-problems is a typical divide-et-impera problem</li>
</ul></li>
</ul></li>
<li>Storing the choice made in each sub-problem in a table allows to easily reconstruct a global solution
<ul>
<li>If we need to reconstruct the solution and not only to know its value, I typically keep 2 tables, one storing the solutions themselves and one storing the choices made to reach them</li>
</ul></li>
<li>A subtly different alternative to the iterative bottom-up dynamic programming approach is the memoized recursive dyanmic programming approach
<ul>
<li>Instead of using the iterative bottom-up approach, I maintain the recursive top-down approach of the divide-et-impera paradigm</li>
<li>I store the solution to the sub-problems that I encounter in a table, so to not solve the same sub-problems again and again</li>
<li>In general, if all the possible sub-problems in problem space must be solved at least once, than the bottom-up approach outperforms the memoized recursive approach by a constant factor
<ul>
<li>This is because the bottom-up approach lacks all the overhead due to recursive calls and has less overhead for mantaining the solution table</li>
<li>With the bottom-up approach I can also exploit the regular pattern of table access to store at any given time only a constant number of solutions
<ul>
<li>This is what we did in the last version of the Fibonacci algorithm</li>
</ul></li>
</ul></li>
<li>If some sub-problems do not need to be solved at all, the memoized recursive version has the advantage of solving only those sub-problems that are effectively needed</li>
</ul></li>
</ul>
<h3 id="fibonacci-numbers">Fibonacci numbers</h3>
<ul>
<li>The Fibonacci sequence is defined by the Fibonacci function  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> as  <img class="displaymath" src="eqn445.png" WIDTH=241 HEIGHT=73 STYLE="vertical-align: -32px; margin: 0;" alt="\begin{cases}F_1=1 \\F_2=1 \\ F_n= F_{n-1}+F_{n-2} &amp; n &gt; 2\end{cases}" /></li><li>The number of clockwise and anticlockwise spirals in many vegetables (sunflower, cauliflower, ecc.) tend to have adjacent values of the Fibonacci sequence</li>
<li>The  <img class="inlinemath" src="eqn334.png" WIDTH=23 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="n^{th}" /> Fibonacci number can be calculated recursively in a very ineffcient way<ul>
<li>The computational cost of this implementation is described by the following recurrence equation  <img class="displaymath" src="eqn446.png" WIDTH=344 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt=" T(n) = \begin{cases}c_1 &amp; n \leq 2 \\ T(n-1)+T(n-2)+c_2 &amp; n &gt; 2\end{cases}" /></li><li>Solving the equation gives that  <img class="inlinemath" src="eqn447.png" WIDTH=99 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T(n)=O(2^n)" />, so the algorith has exponential time complexity</li></ul></li>
</ul>
<ul>
<li>I can solve the same problem iteratively in linear time and space</li>
</ul>
<ul>
<li>This approach can be further improved by not storing the intermediate values of the sequence
<ul>
<li>In this way I can reach linear time and constant space complexity</li>
</ul></li>
</ul>
<h3 id="dynamic-programming-for-the-0-1-knapsack-problem">Dynamic programming for the 0-1 knapsack problem</h3>
<ul>
<li>For the 0-1 knapsack problem, I can describe an optimal solution in terms of the optimal solution for a smaller knapsack and number of objects</li>
<li>I have an array of weights for each object  <img class="inlinemath" src="eqn448.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w[1...n]" /> and an array of values  <img class="inlinemath" src="eqn449.png" WIDTH=50 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="v[1...n]" /></li><li>The maximum capacity of the knapsack is  <img class="inlinemath" src="eqn450.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W" /></li><li>I start by creating the dynamic programming matrix  <img class="inlinemath" src="eqn451.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="V(i,j)" /> with  <img class="inlinemath" src="eqn452.png" WIDTH=61 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i=0...n" /> and  <img class="inlinemath" src="eqn453.png" WIDTH=71 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j=1...W" /></li><li>I want to find the solution  <img class="inlinemath" src="eqn451.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="V(i,j)" /> consisting of a sub-set of the first  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> objects whose total weight is less than  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> and that maximize the total value of the knapsack</li><li>The optimal solution for a knapsack of capacity  <img class="inlinemath" src="eqn450.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W" /> with a set of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> objects available will be the value computed in  <img class="inlinemath" src="eqn454.png" WIDTH=62 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="V(n,W)" /></li><li>I initialize the matrix by filling the first row and the first column as follows
<ul>
<li>I set the first column to 0 since for a capacity  <img class="inlinemath" src="eqn455.png" WIDTH=40 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j=0" /> no object can fit, and so the maximal value of the knapsack is always 0  <img class="displaymath" src="eqn456.png" WIDTH=163 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="v(i,0)=0 \mbox{ for } i=1...n" /></li><li>I set the first row to the value of the first object if it can fit ( <img class="inlinemath" src="eqn457.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="j \leq w[1]" />), 0 otherwise  <img class="displaymath" src="eqn458.png" WIDTH=244 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="v(1,j)= \begin{cases} v[1] &amp; \mbox{for } j \geq w[1] \\ 0 &amp; \mbox{for } j &lt; w[1] \end{cases}" /></li></ul></li>
<li>Then I compute the matrix  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /> iteratively for  <img class="inlinemath" src="eqn452.png" WIDTH=61 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i=0...n" /> and  <img class="inlinemath" src="eqn453.png" WIDTH=71 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j=1...W" /> as follows  <img class="displaymath" src="eqn459.png" WIDTH=500 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="V(i,j) = \begin{cases} V(i-1,j) &amp; \mbox{if } w[i] &gt; j\\ max(V(i-1,j),V(i-1,j-w[i])+v[i]) &amp; \mbox{if } w[i] \leq j \end{cases}" /> <ul>
<li>If the  <img class="inlinemath" src="eqn460.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="i^{th}" /> item does not fit in an empty knapsack of capacity  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" />, I cannot take it and the optimal composition of the knapsack of capacity  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> considering the subset of objects  <img class="inlinemath" src="eqn461.png" WIDTH=29 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="0...i" /> is the same as considering the subset of objects  <img class="inlinemath" src="eqn462.png" WIDTH=57 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="0...i-1" />  <img class="displaymath" src="eqn463.png" WIDTH=248 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" V(i,j) = V(i-1,j) \qquad \mbox{if } w[i] &gt; j" /></li><li>If it can fit in the knapsack, I make the choice that maximizes the total knapsack value among
<ul>
<li>Putting the object in the knapsack and filling the remaining  <img class="inlinemath" src="eqn464.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="j-w[i]" /> free capacity with the optimal solution already found  <img class="inlinemath" src="eqn465.png" WIDTH=94 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="V(i,j-w[i])" />: in this case the value of the optimal knapsack of capacity  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> is the value of the optimal knapsack of capacity  <img class="inlinemath" src="eqn464.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="j-w[i]" /> plus the value of the current object  <img class="inlinemath" src="eqn466.png" WIDTH=24 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="v[i]" />  <img class="displaymath" src="eqn467.png" WIDTH=233 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="V(i,j) = V(i-1,j-w[i])+v[i]" /> <ul>
<li>Note that since I am using  <img class="inlinemath" src="eqn464.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="j-w[i]" /> has an index for the matrix,  <img class="inlinemath" src="eqn468.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w[i]" /> has to be an integer!</li></ul></li>
<li>Not putting the  <img class="inlinemath" src="eqn460.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="i^{th}" /> object in the knapsack and retaining the composition that it had considering only the subset of objects  <img class="inlinemath" src="eqn469.png" WIDTH=57 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="1...i-1" />  <img class="displaymath" src="eqn470.png" WIDTH=144 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" V(i,j) = V(i-1,j)" /></li></ul></li>
</ul></li>
<li>In order to know which objects are in the best solution  <img class="inlinemath" src="eqn454.png" WIDTH=62 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="V(n,W)" /> I need to build an additional table of booleans  <img class="inlinemath" src="eqn471.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="K(i,j)" /> <ul>
<li>I set  <img class="inlinemath" src="eqn472.png" WIDTH=122 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="K(i,j)=TRUE" /> if the  <img class="inlinemath" src="eqn460.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="i^{th}" /> object belongs to the set of objects used for calculating  <img class="inlinemath" src="eqn451.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="V(i,j)" />, false otehrwise  <img class="displaymath" src="eqn473.png" WIDTH=369 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="K(i,j)= \begin{cases} TRUE &amp; \mbox{if } V(i,j)\not=V(i-1,j) \\ FALSE &amp; \mbox{if } V(i,j)==V(i-1,j) \end{cases}" /></li></ul></li>
<li>From the matrix  <img class="inlinemath" src="eqn292.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="K" />, I start from the bottom right and I procede by subtracting  <img class="inlinemath" src="eqn468.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w[i]" /> at each step (I move to  <img class="inlinemath" src="eqn474.png" WIDTH=96 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="K(i,j-w[i])" />)<ul>
<li>The included objects are the ones for which  <img class="inlinemath" src="eqn292.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="K" /> is true in this path</li></ul></li>
<li>The following pseudocode can print the objects included in the optimal solution</li>
</ul>
<h3 id="the-subset-sum-problem">The subset-sum problem</h3>
<ul>
<li>The subset-sum problem is a variant of the 0-1 knapsack problem in which I want to find a set of objects whose total weight is exactly  <img class="inlinemath" src="eqn450.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W" /> <ul>
<li>Note that in this case the total value of the set is completely irrelevant (the value of the objects is not even defined)</li>
</ul></li>
<li>Given a set  <img class="inlinemath" src="eqn475.png" WIDTH=116 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X=\{1,2,...,n\}" /> of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> objects where object  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> weights  <img class="inlinemath" src="eqn468.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w[i]" /> which is a positive integer, and a total capacity  <img class="inlinemath" src="eqn450.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W" />, I want to find a subset  <img class="inlinemath" src="eqn476.png" WIDTH=52 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="Y \subseteq X" /> such that  <img class="inlinemath" src="eqn477.png" WIDTH=113 HEIGHT=21 STYLE="vertical-align: -7px; margin: 0;" alt="\sum_{i \in Y} w[i] = W" /></li><li>I can solve the subset-sum problem with dynamic programming similarly to how I can solve the 0-1 knapsack problem</li>
<li>In this case the sub-problem  <img class="inlinemath" src="eqn478.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="P(i,j)" /> is to determine if a set of objects drawn from the subset of objects  <img class="inlinemath" src="eqn479.png" WIDTH=29 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="1...i" /> with total weight exactly  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> exists</li><li>A solution  <img class="inlinemath" src="eqn480.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i,j)" /> is TRUE iff a subset of the first  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> objects with total weight exactly  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> exists, FALSE otherwise</li><li>To solve the subset-sum problem, I create the solution matrix  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> and I initialize the first row to TRUE, since I can always find a set of objects that fills completely a capacity  <img class="inlinemath" src="eqn455.png" WIDTH=40 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j=0" />: the empty set  <img class="displaymath" src="eqn481.png" WIDTH=237 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i,0) = TRUE \qquad \mbox{for } i=1...n" /></li><li>The first row is set to TRUE if the first object fits exactly in the capacity, 0 otherwise (this is, if  <img class="inlinemath" src="eqn482.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w[1]\not=j" />)  <img class="displaymath" src="eqn483.png" WIDTH=348 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="B(1,j) = \begin{cases} TRUE &amp; \mbox{if } j=w[1]\\FALSE &amp; \mbox{if } j&gt;0 \mbox{ and } j \not=w[1] \end{cases}" /></li><li>Then in the general case, for each cell  <img class="inlinemath" src="eqn480.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i,j)" /> I compute has follows<ul>
<li>If  <img class="inlinemath" src="eqn484.png" WIDTH=57 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="j&lt;w[i]" /> than the object  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> does not fit in the capacity and so the optimal solution is the same found without considering that object  <img class="displaymath" src="eqn485.png" WIDTH=247 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i,j)=B(i-1,j) \qquad \mbox{if } j&lt;w[i]" /></li><li>Otherwise if  <img class="inlinemath" src="eqn486.png" WIDTH=57 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="j \geq w[i]" />  <img class="inlinemath" src="eqn480.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i,j)" /> is TRUE if either of these 2 conditions is verified<ul>
<li>The capacity  <img class="inlinemath" src="eqn464.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="j-w[i]" /> can be filled exactly with the  <img class="inlinemath" src="eqn469.png" WIDTH=57 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="1...i-1" /> subset of objects  <img class="displaymath" src="eqn487.png" WIDTH=359 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i-1,j-w[i]) = TRUE \implies B(i,j) = TRUE" /></li><li>I already filled exactly capacity  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> without considering object  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" />  <img class="displaymath" src="eqn488.png" WIDTH=312 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i-1,j) = TRUE \implies B(i,j) = TRUE" /></li></ul></li>
<li>If none of these conditions is verified than  <img class="inlinemath" src="eqn489.png" WIDTH=130 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i,j) = FALSE" /></li></ul></li>
<li>The solution of the subset-sum problem can be found by interrogating  <img class="inlinemath" src="eqn490.png" WIDTH=62 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(n,W)" /> after the computation</li><li>The following pseudocode prints the solution of the subset-sum problem</li>
</ul>
<h2 id="shortest-paths">Shortest paths</h2>
<ul>
<li>I am given an edge  <img class="inlinemath" src="eqn491.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(x,y) \in E" /> with an associated cost  <img class="inlinemath" src="eqn492.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(x,y)" /></li><li>The cost of a path  <img class="inlinemath" src="eqn493.png" WIDTH=125 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\pi=(v_0,v_1,...,v_k)" /> that connects the vertex  <img class="inlinemath" src="eqn494.png" WIDTH=16 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="v_0" /> with the vertex  <img class="inlinemath" src="eqn495.png" WIDTH=17 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="v_k" /> is the sum of the weights of all the edges that it includes  <img class="displaymath" src="eqn496.png" WIDTH=156 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt="w(\pi)=\sum_{i=1}^k w(v_{i-1}, v_i)" /></li><li>The shortest path between the verteces  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" />  <img class="inlinemath" src="eqn497.png" WIDTH=29 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="pi^*_{uv}" /> is the path with minimal cost between them (if it exists)<ul>
<li>A path between 2 verteces does not exist when they are not reachable from each other
<ul>
<li> <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> is not reachable from  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> if there are no edges among them or if the edges are directed in the wrong direction</li></ul></li>
<li>Also cycles with an overall negative cost make the target unreachable, since when one of them is present I will continuously go around the cycle getting lower and lower cost</li>
<li>There can be many shortest paths with equal costs</li>
<li>In a directed graph  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /> is not necessarily equal to  <img class="inlinemath" src="eqn499.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{vu}" /></li></ul></li>
<li>The single source shortest path from a source vertex  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> is the set of shortest paths  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" /> from  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> to all the verteces  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> reachable from it</li><li>The all-pairs shortest path is the set of shortest paths  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /> for all possible pairs of connected verteces  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> in a graph</li><li>There is no known algorithm that solves the shortest path between 2 arbitrary verteces  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /> without solving also the single source shortest path for  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> in the worst case</li><li>The shortest path problem shows an optimal substructure: each sub-path of the shortest path is by itself a shortest path among different nodes
<ul>
<li>Let  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /> be the shortest path from vertex  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> to vertex  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /></li><li>Let  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> and  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> be 2 intermediate verteces along the path  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /> that are connected by the sub-path  <img class="inlinemath" src="eqn501.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -5px; margin: 0;" alt="\pi_{ij}" />, contained in  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /></li><li>I assume by contradiction that there is an alternative path  <img class="inlinemath" src="eqn502.png" WIDTH=20 HEIGHT=21 STYLE="vertical-align: -7px; margin: 0;" alt="\pi'_{ij}" /> such that  <img class="inlinemath" src="eqn503.png" WIDTH=111 HEIGHT=21 STYLE="vertical-align: -7px; margin: 0;" alt="w(\pi'_{ij}) &lt; w(\pi_{ij})" /></li><li>If that was true, then  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /> would not be a shortest path, since I could find a path between  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> passing along  <img class="inlinemath" src="eqn502.png" WIDTH=20 HEIGHT=21 STYLE="vertical-align: -7px; margin: 0;" alt="\pi'_{ij}" /> instead that along  <img class="inlinemath" src="eqn501.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -5px; margin: 0;" alt="\pi_{ij}" /></li></ul></li>
<li>In a directed graph without negative-weight cycles there is a shortest path between any pair of connected verteces
<ul>
<li>In the absence of negative-weight cycles a shortest path between connected verteces exists since there is only a finite number of paths among those verteces</li>
<li>There is a finite number of paths among them since I cannot create a shorter path by adding a cycle to it (I am in a graph without negative-wieght cycles)</li>
</ul></li>
<li>A shortest path cannot contain positive-weight cycles
<ul>
<li>If a path contains a positive-weight cycle it is always possible to make the path shorter by removing the cycle</li>
</ul></li>
<li>If a shortest path among 2 verteces exists, it is always possible to find an acyclic shortest path among them
<ul>
<li>I can have a shortest path between 2 verteces that contains a cycle with a total weight of 0, but in this case there would be also an alternative shortest path that skips that cycle</li>
</ul></li>
<li>A shortest path tree  <img class="inlinemath" src="eqn504.png" WIDTH=17 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="T_s" /> contains all the verteces reachable from a source  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" />, which is the root of the tree, such that all the paths from  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> are shortest paths<ul>
<li>I can build it from a partial tree by exploiting the optimal substructure of shortest paths</li>
</ul></li>
<li>The distance  <img class="inlinemath" src="eqn505.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="d_{uv}" /> between the verteces  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> is the cost of any shortest path  <img class="inlinemath" src="eqn498.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{uv}" /> connecting them if one exists,  <img class="inlinemath" src="eqn506.png" WIDTH=38 HEIGHT=14 STYLE="vertical-align: -3px; margin: 0;" alt="+\infty" /> otherwise  <img class="displaymath" src="eqn507.png" WIDTH=213 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="d_{uv} = \begin{cases}w(\pi^*_{uv}) &amp; \mbox{if } \exists \ \pi^*_{uv}\\ +\infty &amp; \mbox{if } \nexists \ \pi^*_{uv} \end{cases}" /></li><li>The distance of a vertex to itself is always 0  <img class="displaymath" src="eqn508.png" WIDTH=54 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="d_{vv} = 0" /></li><li>Distances on graphs respect the triangle inequality  <img class="displaymath" src="eqn509.png" WIDTH=110 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt=" d_{uv} \leq d_{ux} + d_{xv}" /></li></ul>
<h3 id="relaxation">Relaxation</h3>
<ul>
<li>Relaxation is a technique used by various shortest-path algorithms</li>
<li>For each vertex  <img class="inlinemath" src="eqn510.png" WIDTH=44 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="v \in V" /> I maintain an attribute  <img class="inlinemath" src="eqn417.png" WIDTH=24 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="v.d" /> which is an upper bound for the shortest path from the source  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> to  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> <ul>
<li> <img class="inlinemath" src="eqn417.png" WIDTH=24 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="v.d" /> is a shortest path estimate</li></ul></li>
<li>I also maintain  <img class="inlinemath" src="eqn511.png" WIDTH=25 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v.\pi" /> as the predecessor of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> in the shortest path tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /></li><li>First I initialise everithing by setting  <img class="displaymath" src="eqn512.png" WIDTH=53 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="s.d = 0" />  <img class="displaymath" src="eqn513.png" WIDTH=191 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="v.d = +\infty \quad \forall \ v \in V- \{s\}" />  <img class="displaymath" src="eqn514.png" WIDTH=166 HEIGHT=16 STYLE="vertical-align: -2px; margin: 0;" alt="v.\pi = NIL \quad \forall v \in G.V" /></li><li>Then I relax the edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> by testing whether I can improve the shortest path to  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" /> by passing through  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" />, and updating the relative attributes of  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> accordingly</li></ul>
<h3 id="dijkstra-algorithm">Dijkstra algorithm</h3>
<ul>
<li>The Dijkstra algorithm computes the single-source shortest path with a greedy approach provided that there are no negative-weight edges (not cycles, edges!) in the graph</li>
<li>The similar Bellman-Ford algorithm solves the problem also when negative edges are present, but it is slower and it is based on dynamic programming</li>
<li>With a good implementation the Dijkstra algorithm is faster than the Bellman-Ford algorithm</li>
<li>Let  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> be a drected weighted graph such that  <img class="inlinemath" src="eqn516.png" WIDTH=201 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(u,v) \geq 0 \quad \forall \ (u,v) \in G.E" /></li><li>Let  <img class="inlinemath" src="eqn517.png" WIDTH=66 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="S \subseteq G.V" /> be the set of vertices that are part of a partial shortest path tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> rooted in the vertex  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> <ul>
<li> <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> contains only shortest paths originating from  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" />, but not all of them</li></ul></li>
<li>The edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> with  <img class="inlinemath" src="eqn518.png" WIDTH=43 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="u \in S" /> and  <img class="inlinemath" src="eqn519.png" WIDTH=93 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="v \in G.V-S" /> that minimizes  <img class="inlinemath" src="eqn520.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{su}+w(u,v)" /> belongs to the shortest path  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" /> if all the edges  <img class="inlinemath" src="eqn521.png" WIDTH=91 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(x,y) \in G.E" /> are non-negative<ul>
<li>In practice it means that the shortest edge connecting a shortest path to the node of interest is part of the shortest path to that node</li>
<li>If I take another route with more edges from the shortest path to the node I am guaranteed to not decrease the cost, sice weights are assumed to not be negative</li>
<li>If an edge is negative this is not necessarily true since adding an edge can decrese the cost</li>
<li>Let’s assume by contradiction that  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> does not belong to  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" /></li><li>In this case I have that  <img class="displaymath" src="eqn522.png" WIDTH=135 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" d_{su}+w(u,v) &gt; d_{sv}" /></li><li>Therefore, there must be a shortest path  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" /> that does not include  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> with weight less than  <img class="inlinemath" src="eqn523.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{su} + w(u,v)" /></li><li>I can decompose this hypotetical shortest path  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" /> into the shortest paths  <img class="inlinemath" src="eqn524.png" WIDTH=23 HEIGHT=20 STYLE="vertical-align: -7px; margin: 0;" alt="\pi^*_{sy}" />,  <img class="inlinemath" src="eqn525.png" WIDTH=24 HEIGHT=20 STYLE="vertical-align: -7px; margin: 0;" alt="\pi^*_{xy}" /> and  <img class="inlinemath" src="eqn526.png" WIDTH=24 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{xv}" /> where  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> and  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> are a pair of adjacent verteces along the path  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" /> <ul>
<li>This is thanks to the optimal substructure property of shortest paths</li>
</ul></li>
<li>Since  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> and  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> are adjacent verteces IN THE SHORTEST PATH  <img class="inlinemath" src="eqn500.png" WIDTH=23 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\pi^*_{sv}" />, the shortest path among them is represented by the edge  <img class="inlinemath" src="eqn527.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(x,y)" /></li><li>I can therefore write  <img class="displaymath" src="eqn528.png" WIDTH=176 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" d_{sv} = d_{sx}+w(x,y)+d_{yv}" /></li><li>By definition, the edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> is the edge among a vertex in the partial shortest-path tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> and a vertex in the graph  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /> but not in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> that minimizes  <img class="inlinemath" src="eqn529.png" WIDTH=85 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{su}+w(uv)" /></li><li>Therefore, for any alternative vertex  <img class="inlinemath" src="eqn017.png" WIDTH=43 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x \in S" /> connected to  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" />  <img class="displaymath" src="eqn530.png" WIDTH=206 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" d_{su} +w(u,v) \leq d_{sx} + w(x,y)" /></li><li>Note that  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> can be ANY vertex  <img class="inlinemath" src="eqn531.png" WIDTH=34 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\in S" /> and  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> can be ANY vertex  <img class="inlinemath" src="eqn532.png" WIDTH=84 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\in G.V-S" /></li><li>The pair of verteces  <img class="inlinemath" src="eqn401.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="u,v" /> is choosen such that there is NO other pair  <img class="inlinemath" src="eqn533.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x,y" /> with  <img class="inlinemath" src="eqn534.png" WIDTH=205 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{sx}+w(x,y) &lt; d_{su}+w(u,v)" />  <img class="displaymath" src="eqn535.png" WIDTH=471 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" d_{su}+w(u,v) \leq d_{sx}+w(x,y) \qquad \forall \ x,u \in S, \qquad \forall \ y,v \in G.V-S " /></li><li>This leads to the absurd conclusion that  <img class="inlinemath" src="eqn520.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{su}+w(u,v)" /> is shorter than  <img class="inlinemath" src="eqn536.png" WIDTH=92 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{sx}+w(x,y)" />, but  <img class="inlinemath" src="eqn537.png" WIDTH=134 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{sx}+w(x,y)+d_{yv}" /> is shorter than  <img class="inlinemath" src="eqn520.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d_{su}+w(u,v)" /></li><li>By constraint of the algorithm,  <img class="inlinemath" src="eqn538.png" WIDTH=196 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(x,y) \geq 0 \quad \forall (x,y) \in G.E" />, so the above is impossible</li><li>From the last statement we can see also why the Dijkstra algorithm cannot work properly in the presence of negative-weight edges</li>
</ul></li>
<li>This implementation of the Dijkstra algorithm uses a min priority queue  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> containing the nodes  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> with keys equal to  <img class="inlinemath" src="eqn417.png" WIDTH=24 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="v.d" /> <ul>
<li>Calling EXTRACT-MIN( <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />) means taking the node in the queue which is closest to the source  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> in terms of shortest path estimate</li><li>At the fist call  <img class="inlinemath" src="eqn412.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="s" /> itself is extracted since  <img class="inlinemath" src="eqn539.png" WIDTH=53 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="s.d = 0" /> while  <img class="inlinemath" src="eqn540.png" WIDTH=62 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="v.d = \infty" /> for all the other nodes</li></ul></li>
<li>The running time of this implementation of the Dijkstra algorithm depends on how the min-priority queue is implemented
<ul>
<li>The INITIALIZE-SINGLE-SOURCE call is an  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> operation with  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> being the number of verteces<ul>
<li>It set 2 pointers for each of the  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> verteces and finally it sets  <img class="inlinemath" src="eqn541.png" WIDTH=53 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="s.d=0" /></li></ul></li>
<li>The initialization of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> to an empty set is an  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> operation</li><li>The queue is filled once with  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> elements (an  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> operation with a min-heap) and since then always emptied</li><li>Each iteration of the while loop removes one element from  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />, so it iterates  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> times<ul>
<li>EXTRACT-MIN is an  <img class="inlinemath" src="eqn542.png" WIDTH=82 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="=O(\log n)" /> operation in a min-heap</li><li>The addition of  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> to the set  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is an  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> operation</li><li>The for loop iterates a number of times equal to the lenght of the adjacency set of the current node
<ul>
<li>The RELAX procedure is an  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> operation since it implicitely calls DECREASE-KEY ( <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> in a min-heap)</li></ul></li>
</ul></li>
<li>In general the number of total iteration of the for loop across all the while loop iterations is the sum of the adjacency lists of all the nodes,  <img class="inlinemath" src="eqn415.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m)" /></li><li>So we have an  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> time for the rows outside the loops, a while loop executed  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> times containing a for loop executed, overall,  <img class="inlinemath" src="eqn415.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m)" /> times</li><li>The unitary cost of the while loop except the for loop is  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" />, while the cost of each iteration of the for loop is  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /></li><li>The overall cost of the while loop is  <img class="inlinemath" src="eqn543.png" WIDTH=119 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O((m+n) \log n)" /></li><li>The final cost of DIJKSTRA implemented with a min-heap is thus  <img class="displaymath" src="eqn544.png" WIDTH=217 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O((m+n)\log n) = O(m \log n)" /></li></ul></li>
</ul>
<h1 id="roberto-amandini-module">Roberto Amandini module</h1>
<hr />
<h2 id="disjoint-sets">Disjoint sets</h2>
<ul>
<li>Sometimes we are interested in joining  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> distinct elements into a collection of disjoint-sets<ul>
<li>It is useful for determining the connected components of an undirected graph</li>
</ul></li>
<li>Two sets are disjoint if they do not have any common element  <img class="displaymath" src="eqn545.png" WIDTH=259 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" S_i,S_j \mbox{ are disjoint } \iff S_i \cap S_j = \emptyset" /></li><li>A collection of disjoint-sets  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is a set of sets  <img class="inlinemath" src="eqn546.png" WIDTH=88 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_1, S_2,..., S_n" /> that are disjoint  <img class="displaymath" src="eqn547.png" WIDTH=429 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=\{S_1,S_2,...,S_n\} \ :\ S_i \cap S_j = \emptyset \ \forall \ i \not= j \ \land \ i,j \in 1,2,...,n" /></li><li>The sets in a disjoint-set collection can change over time (they are dynamic)</li>
<li>Data structures have been implemented for working with disjoint-set collections (disjoint-set data structures)</li>
<li>These data structures must implement some basic operations
<ul>
<li>Creating a disjoint-set  <img class="inlinemath" src="eqn548.png" WIDTH=64 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S_i = \{x\}" /></li><li>Finding the set  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> to which an element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> belongs to</li><li>Merging the disjoint-sets  <img class="inlinemath" src="eqn550.png" WIDTH=39 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="S_i, S_j" /> by computing their unioin  <img class="inlinemath" src="eqn551.png" WIDTH=50 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="S_i \cup S_j" /></li></ul></li>
<li>Each disjoint-set  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> is uniquely identified by a representative  <img class="inlinemath" src="eqn552.png" WIDTH=50 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="\rho_i \in S_i" />, a member of the set itself<ul>
<li>In most cases it doesn’t matter which element is choosen as a representative</li>
<li>Any FIND operation on the set  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> must return the same representative  <img class="inlinemath" src="eqn553.png" WIDTH=15 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="\rho_i" /></li><li>When 2 disjoint-sets are merged, the representative can change</li>
<li>It is possible to use a specific element of  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> as a representative, for instance the maximum or minimum element of the set</li></ul></li>
<li>MAKE-SET( <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />) creates a set  <img class="inlinemath" src="eqn554.png" WIDTH=27 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\{x\}" /> assuming that  <img class="inlinemath" src="eqn555.png" WIDTH=136 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x\not\in S_i \ \mbox{for } i=1...n" /> <ul>
<li>Since  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is the only element of the new set, it will also be its representative</li><li>I need to check that  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> is not contained in any other set before inserting it in a new set!</li></ul></li>
<li>FIND-SET( <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />) returns a pointer to the representative  <img class="inlinemath" src="eqn553.png" WIDTH=15 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="\rho_i" /> of the unique set  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> containing  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>UNION( <img class="inlinemath" src="eqn556.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x, y" />) returns  <img class="inlinemath" src="eqn557.png" WIDTH=54 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="S_x \cup S_y" /> assuming that  <img class="inlinemath" src="eqn558.png" WIDTH=48 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="x \in S_x" />,  <img class="inlinemath" src="eqn559.png" WIDTH=47 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="y \in S_y" />, and  <img class="inlinemath" src="eqn560.png" WIDTH=85 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S_x \cap S_y = \emptyset" /> <ul>
<li>The condition  <img class="inlinemath" src="eqn560.png" WIDTH=85 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S_x \cap S_y = \emptyset" /> can be verified by enforcing that they belong to sets with different representatives  <img class="displaymath" src="eqn561.png" WIDTH=351 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt="\mbox{FIND-SET}(x)\not=\mbox{FIND-SET}(y) \implies S_x \cap S_y = \emptyset" /></li><li>The UNION operation destroys the sets  <img class="inlinemath" src="eqn562.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_x" /> and  <img class="inlinemath" src="eqn563.png" WIDTH=18 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="S_y" /></li><li>After UNION, a new representative for the set  <img class="inlinemath" src="eqn557.png" WIDTH=54 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="S_x \cup S_y" /> must be choosen<ul>
<li>Usually either the representative of  <img class="inlinemath" src="eqn562.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_x" /> or that of  <img class="inlinemath" src="eqn563.png" WIDTH=18 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="S_y" /> is used</li></ul></li>
</ul></li>
</ul>
<h3 id="connected-components">Connected components</h3>
<ul>
<li>A subgrapg  <img class="inlinemath" src="eqn564.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G'=(V',E')" /> of the graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> is a connected component if there is a path among all the possible pairs of verteces in  <img class="inlinemath" src="eqn565.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="V'" /> and there is no path among any vertex in  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /> and any vertex in  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /> but not in  <img class="inlinemath" src="eqn565.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="V'" />  <img class="displaymath" src="eqn566.png" WIDTH=587 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="G'=(V',E') \mbox{ is a connected component } \iff \mbox{ for } x \in V' \begin{cases} \exists \ x \leadsto y \ \forall \ y \in V' \\  \nexists \ x \leadsto z \ \forall \ z \in V-V'  \end{cases}" /></li><li>Disjoint sets can be used for determining the connected components in an undirected grpah  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> <ul>
<li>When the graph  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /> is static, I can quickly determine the connected components with a series of depth-first searches</li><li>When the graph is dynamic (edges are added and removed over time), disjoint-sets are more efficient in maintaining the connected components as the graph is modified
<ul>
<li>When an edge is added I can just join the respective sets</li>
</ul></li>
</ul></li>
<li>We can define some operations based on disjoint-sets to work on connected components
<ul>
<li>CONNECTED-COMPONENTS( <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" />) computes what are the connected components</li><li>SAME-COMPONENTS( <img class="inlinemath" src="eqn401.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="u,v" />) returns TRUE if  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> belong to the same component</li></ul></li>
</ul>
<h3 id="disjoint-sets-representations">Disjoint sets representations</h3>
<ul>
<li>Disjoint sets can be implemented naively with linked lists
<ul>
<li>In this case each disjoint-set is represented by a linked list  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> where each element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> stores<ul>
<li>The set member  <img class="inlinemath" src="eqn567.png" WIDTH=50 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="x.elem" /></li><li>A pointer to the next element in the list  <img class="inlinemath" src="eqn268.png" WIDTH=48 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x.next" /></li><li>A pointer back to the set object  <img class="inlinemath" src="eqn568.png" WIDTH=37 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x.set" /></li></ul></li>
<li>The first object of the list  <img class="inlinemath" src="eqn569.png" WIDTH=51 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S.head" /> is taken as representative</li><li>In this case MAKE-SET( <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />) and FIND-SET( <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />) are easy to implement and have constant time complexity ( <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" />)<ul>
<li>MAKE-SET just creates a new list containing only the object  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>FIND-SET follows the pointer  <img class="inlinemath" src="eqn568.png" WIDTH=37 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x.set" /> back to the set object, and then returns the head of the respective list  <img class="inlinemath" src="eqn269.png" WIDTH=52 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="L.head" /></li></ul></li>
<li>UNION( <img class="inlinemath" src="eqn533.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x,y" />) can be implemented naively by appending the list  <img class="inlinemath" src="eqn570.png" WIDTH=19 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="L_y" /> to which  <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" /> belongs to the list  <img class="inlinemath" src="eqn571.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="L_x" /> to which  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> belongs<ul>
<li>This operations costs  <img class="inlinemath" src="eqn572.png" WIDTH=54 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(|L_y|)" /> since I need to update all the pointers  <img class="inlinemath" src="eqn573.png" WIDTH=36 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="y.set" /> for all the elements in  <img class="inlinemath" src="eqn570.png" WIDTH=19 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="L_y" /></li></ul></li>
<li>In order to inprove the performances of UNION( <img class="inlinemath" src="eqn533.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x,y" />) I can use a weighted-union heuristic: I always append the sortest list among  <img class="inlinemath" src="eqn571.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="L_x" /> and  <img class="inlinemath" src="eqn570.png" WIDTH=19 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="L_y" /> to the longer one</li></ul></li>
<li>Here we will always refer to the total number of MAKE-SET, UNION, and FIND-SET operations as  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" />, and to the total number of MAKE-SET operations as  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> <ul>
<li>Since the number of MAKE-SET operations  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> is included in the number of total operations  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" />, we have that  <img class="inlinemath" src="eqn574.png" WIDTH=48 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="m \geq n" /></li><li>We assume that the first  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> operations performed of the  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> total operations are all MAKE-SET operations</li><li>The total number of UNION operations in a collection of disjoint-sets is at most  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> <ul>
<li> <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> is the number of MAKE-SET operations, and so the number of initial sets</li><li>After  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> unions on  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> sets I am left with a single set</li></ul></li>
</ul></li>
<li>The running time is  <img class="inlinemath" src="eqn575.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m+n \log n)" /> with a linked lists representation of disjoint-sets<ul>
<li>We are performing at most  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> UNION operations</li><li>Since we are using the weighted-union heuristic, when I perform an UNION operation the pointers are always updated in the smaller original set</li>
<li>Let’s look at an element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>After 1 union in which  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />’s pointer is updated the resulting set has at least 2 members, after 2 updates at least 4, and so on</li><li>For any  <img class="inlinemath" src="eqn576.png" WIDTH=43 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="k \leq n" />, when  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />’s pointer has been updated  <img class="inlinemath" src="eqn577.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\lceil \log k \rceil" /> times, the resulting set has at least  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> members</li><li>Since the largest set has at most  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> members, each object’s pointer is updated at most  <img class="inlinemath" src="eqn578.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\lceil \log n \rceil" /> times overall</li><li>The total time spent in UNION operations is thus  <img class="inlinemath" src="eqn579.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n \log n)" /></li><li>Each MAKE-SET and FIND-SET operation takes  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> time, and  <img class="inlinemath" src="eqn415.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m)" /> of them are performed</li><li>Thus the total time for the entire sequence is  <img class="inlinemath" src="eqn580.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m+n\log n)" /></li></ul></li>
<li>The amortized cost (average cost per operation) with a linked-list representation of disjoint-sets is thus  <img class="displaymath" src="eqn581.png" WIDTH=220 HEIGHT=42 STYLE="vertical-align: -16px; margin: 0;" alt="\frac{O(m+n \log n)}{m} = O\left(\frac{n \log n}{m}\right)" /></li><li>Instead of linked lists, we can use a disjoint-set forest representation
<ul>
<li>In this case each disjoint-set is represented by a rooted tree</li>
<li>Each node in each tree contains an element  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> and a pointer to its parent node  <img class="inlinemath" src="eqn278.png" WIDTH=24 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.p" /></li><li>The representative of a set is the root of the corresponding tree</li>
<li>The parent pointer of the root of each tree points to itself  <img class="displaymath" src="eqn582.png" WIDTH=174 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" x.p = x \implies x \mbox{ is a root}" /></li><li>MAKE-SET( <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />) creates a tree with just the root in  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> time</li><li>FIND-SET( <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />) traverses the tree up to the root with a worst-case running time of  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /></li><li>UNION( <img class="inlinemath" src="eqn533.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x,y" />) just redirects the pointer  <img class="inlinemath" src="eqn278.png" WIDTH=24 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.p" /> of the root of a tree to the root of another tree<ul>
<li>If I know who the 2 roots are the running time is  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> <ul>
<li>I know the roots if I am maintaining a table of all the roots</li>
</ul></li>
<li>If I don’t know I need to call FIND-SET( <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" />) and FIND-SET( <img class="inlinemath" src="eqn018.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y" />)<ul>
<li>In this case UNION becomes an  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> operation in the worst case</li></ul></li>
</ul></li>
</ul></li>
<li>So far it seems that the disjoint-set forest representation is not better than the linked-list representation, but we can improve dramatically the amortized cost of the disjoint-set forest by using some heuristics</li>
<li>Union-by-rank: I can minimize the height of each tree resulting from UNION operations by making the root of the tree with fewer nodes point to the root of the tree with more nodes, and not vice-versa
<ul>
<li>I maintain an  <img class="inlinemath" src="eqn583.png" WIDTH=51 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="x.rank" /> attribute for each node which is equal to the height of the subtree rooted in  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /></li><li>When performing an UNION, I append the root with smaller rank to the root of higher rank
<ul>
<li>This cannot alter the rank of the resulting root</li>
</ul></li>
<li>If the 2 roots have the same rank, I just choose one of the 2 trees and append it to the other
<ul>
<li>In this case I need to increment by 1 the rank of the resulting root</li>
</ul></li>
</ul></li>
<li>Union-by-rank improves the running time from  <img class="inlinemath" src="eqn575.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m+n \log n)" /> to  <img class="inlinemath" src="eqn584.png" WIDTH=77 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \log n)" /> <ul>
<li>A tree rooted in  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> has at least  <img class="inlinemath" src="eqn585.png" WIDTH=46 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^{x.rank}" /> nodes<ul>
<li>This can be proven by induction on the number of UNION operations performed</li>
</ul></li>
<li>Since  <img class="inlinemath" src="eqn586.png" WIDTH=78 HEIGHT=19 STYLE="vertical-align: -3px; margin: 0;" alt="2^{x.rank} \leq n" />, I have that  <img class="inlinemath" src="eqn587.png" WIDTH=107 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x.rank \leq \log n" /></li><li>FIND-SET can thus at most traverse  <img class="inlinemath" src="eqn588.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\log_n" /> nodes in  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> time</li><li>Since I am performing at most  <img class="inlinemath" src="eqn589.png" WIDTH=46 HEIGHT=14 STYLE="vertical-align: -3px; margin: 0;" alt="m-n" /> FIND-SET operations, the overall cost is bounded by  <img class="inlinemath" src="eqn584.png" WIDTH=77 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \log n)" /></li></ul></li>
<li>The amortized cost implementing union-by-rank becomes  <img class="displaymath" src="eqn590.png" WIDTH=277 HEIGHT=42 STYLE="vertical-align: -16px; margin: 0;" alt="\frac{O(m \log n)}{m} = O\left(\frac{m \log n}{m}\right)=O(\log n)" /></li><li>Path compression: I add redirect  <img class="inlinemath" src="eqn278.png" WIDTH=24 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x.p" /> directly to the root of the respective tree on each node  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> on the path to the root when performing a FIND-SET operation<ul>
<li>This makes future FIND-SET operations on the affected nodes run in  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> time since I avoid traversing the whole path</li></ul></li>
<li>Path compression reduces the worst case running time to  <img class="inlinemath" src="eqn591.png" WIDTH=176 HEIGHT=23 STYLE="vertical-align: -8px; margin: 0;" alt="O(n+f(1+\log_{2+f/n}n))" />, where  <img class="inlinemath" src="eqn075.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="f" /> is the number of FIND-SET operations performed<ul>
<li>This is complicated but possible to prove</li>
</ul></li>
<li>Hybrid approach: I can combine the use of union-by-rank and path compression
<ul>
<li>In this case when I perform a path compression with FIND-SET I do not waste time updating all the affected  <img class="inlinemath" src="eqn583.png" WIDTH=51 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="x.rank" /> pointers</li><li> <img class="inlinemath" src="eqn583.png" WIDTH=51 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="x.rank" /> is update only bu UNION operations and is no more the exact height of the subtree rooted in  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> (as in pure union-by-rank) but an upper bound on this height</li></ul></li>
<li>Combining both union-by-rank and path compression yields a worst case running time of  <img class="inlinemath" src="eqn592.png" WIDTH=141 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \ \alpha(n)) \approx O(m)" />, where  <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" /> is the inverse Ackermann function<ul>
<li>The inverse Ackermann function grows incredibly slowly:  <img class="inlinemath" src="eqn593.png" WIDTH=65 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\alpha(n) &lt; 5" /> for any  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> that can be written in the physical universe<ul>
<li>We can safely assume that  <img class="inlinemath" src="eqn594.png" WIDTH=90 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\alpha(n) \approx O(1)" /></li></ul></li>
</ul></li>
<li>The amortized cost of the hybrid approach is thus  <img class="displaymath" src="eqn595.png" WIDTH=336 HEIGHT=42 STYLE="vertical-align: -16px; margin: 0;" alt="\frac{O(m \ \alpha(n))}{m} = O\left(\frac{m \ \alpha(n)}{m}\right)=O(\alpha(n)) \approx O(1)" /></li><li>The following pseudocode implements the hybrid approach with union-by-rank and path compression</li>
</ul>
<ul>
<li>Disjoint-sets are useful for the representation of dynamic sets that grow over time</li>
<li>A disjoint-set forest implementing the heuristics union-by-rank and path compression reaches an almost constant  <img class="inlinemath" src="eqn596.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\alpha(n))" /> amortized running time per operation</li><li>The dishoint-sets representation of connected components does not support the removal of edges, but only their addition</li>
<li>Many of the results for disjoint-sets are due to the american scientist Robert E. Tarjan</li>
</ul>
<h2 id="dynamic-programming-1">Dynamic programming</h2>
<ul>
<li>Divide-et-impera solve problems recursively in a top-down way
<ul>
<li>It is efficient when subproblems are disjoint and balanced</li>
</ul></li>
<li>Dynamic programming avoids to solve repeatedly the same sub-problem by storing the solution of sub-problems in a table
<ul>
<li>It works from the bottom-up and it is typically used for optimization problems</li>
</ul></li>
<li>In an optimization problem I want to find the solution  <img class="inlinemath" src="eqn597.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S^*" /> such that its value  <img class="inlinemath" src="eqn598.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\phi(S^*)" /> is minimal/maximal (according to the problem) in the set of possible solution values  <img class="displaymath" src="eqn599.png" WIDTH=323 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S^* = argmax_S(\{\phi(S)\ |\ S \mbox{ is a solution of }P\})" /></li><li>The value of an optimal solution  <img class="inlinemath" src="eqn598.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\phi(S^*)" /> is called optimal value</li><li>I should use dynamic programming on a problem  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> when<ul>
<li>The problem  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> has optimal substructure</li><li>The subproblems of  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> are independent and overlapping</li><li>There is a polynomial number of subproblems  <img class="inlinemath" src="eqn601.png" WIDTH=50 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P_1...P_k" /></li><li>Deriving  <img class="inlinemath" src="eqn597.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S^*" /> from  <img class="inlinemath" src="eqn602.png" WIDTH=50 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="S_1^*...S_k^*" /> requires polynomial time</li></ul></li>
</ul>
<h3 id="longest-common-subsequence">Longest common subsequence</h3>
<ul>
<li>A sequence  <img class="inlinemath" src="eqn603.png" WIDTH=138 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X = \langle x_1, x_2, ..., x_m \rangle" /> is a subsequence of the sequence  <img class="inlinemath" src="eqn604.png" WIDTH=129 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Y = \langle y_1, y_2, ..., y_n \rangle" /> if it is possible to obtain  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> from  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> by removing some elements  <img class="inlinemath" src="eqn607.png" WIDTH=68 HEIGHT=14 STYLE="vertical-align: -5px; margin: 0;" alt="y_{i_1},...,y_{y_k}" />  <img class="displaymath" src="eqn608.png" WIDTH=423 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" subseq(X,Y) \iff \exists \ i_1,...,i_k \ : \ \forall \ j \in \{1,...,k\} \ :\ x_{i_j} = y_{i_j}" /></li><li>For  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> to be a subsequence of  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />, the elements ion  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> must appear in the same order as the elements in  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />, but they are NOT required to be contiguous in  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /></li><li>The empty sequence  <img class="inlinemath" src="eqn609.png" WIDTH=19 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\langle \ \rangle" /> is a subsequence of every sequence</li><li>A string is a sequence of characters drawn from a given alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /></li><li>A string  <img class="inlinemath" src="eqn611.png" WIDTH=149 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\langle c_1,...,c_m \rangle\ :\ c_i \in \Sigma^*" /> is conventionally represented as  <img class="inlinemath" src="eqn612.png" WIDTH=62 HEIGHT=14 STYLE="vertical-align: -4px; margin: 0;" alt="c_1 \cdot \cdot \cdot c_m" /> <ul>
<li>The string  <img class="inlinemath" src="eqn613.png" WIDTH=78 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\langle h,e,l,l,o \rangle" /> is represented as  <img class="inlinemath" src="eqn614.png" WIDTH=37 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="hello" /></li></ul></li>
<li>The empty string is represented with  <img class="inlinemath" src="eqn615.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\epsilon" />  <img class="displaymath" src="eqn616.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \epsilon = \langle \ \rangle" /></li><li>Given the sequences  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> we say that  <img class="inlinemath" src="eqn617.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Z" /> is a common subsequence of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> ( <img class="inlinemath" src="eqn618.png" WIDTH=48 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="CS_{X,Y}" />) if it is a subsequence of both  <img class="displaymath" src="eqn619.png" WIDTH=327 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" CS_{X,Y} = \{Z\ |\ subseq(Z,X)\ \land\ subseq(Z,Y)\}" /></li><li> <img class="inlinemath" src="eqn617.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Z" /> is a longest common subsequence of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> ( <img class="inlinemath" src="eqn620.png" WIDTH=59 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="LCS_{X,Y}" />) if it is a common subsequence of maximal lenght  <img class="displaymath" src="eqn621.png" WIDTH=363 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" LCS_{X,Y} = \{Z \in CS_{X,Y}\ |\ \forall\ Z' \in CS_{X,Y}\ |Z| \geq |Z'|\}" /></li><li>All the longest common sequences of 2 sequences are of the same length  <img class="displaymath" src="eqn622.png" WIDTH=203 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" |Z| = |Z'| \ \forall\ Z,Z' \in LCS_{X,Y}" /></li><li>The longest common subsequence problem consists in finding, given 2 sequences  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />, a longest common subsequence  <img class="inlinemath" src="eqn623.png" WIDTH=91 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="Z \in LCS_{X,Y}" /> <ul>
<li>Note that  <img class="inlinemath" src="eqn624.png" WIDTH=128 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\exists \ LCS_{X,Y} \ \forall \ X,Y" /> since  <img class="inlinemath" src="eqn625.png" WIDTH=169 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\epsilon = \langle \ \rangle \in CS_{X,Y} \ \forall \ X,Y" /></li><li>There can be more than 1 LCS for a given pair of sequences  <img class="displaymath" src="eqn626.png" WIDTH=153 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" |LCS_{X,Y}| \geq 1 \ \forall \ X,Y" /></li><li>In some cases we are interested in finding how many LCS there are among 2 sequences ( <img class="inlinemath" src="eqn627.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|LCS_{X,Y}|" />), and not in finding the structure of any particolar LCS</li></ul></li>
<li>A brute force approach for the LCS problem requires to enumerate all of the possible  <img class="inlinemath" src="eqn628.png" WIDTH=21 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2^m" /> subsequences of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and checking wether they occur in  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> <ul>
<li>The worst-case running time is  <img class="inlinemath" src="eqn629.png" WIDTH=56 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n 2^m)" /> where  <img class="inlinemath" src="eqn630.png" WIDTH=61 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m = |X|" /> and  <img class="inlinemath" src="eqn631.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n = |Y|" /></li></ul></li>
<li>Dynamic programming can drammatically reduce the time required for solving the LCS problem</li>
<li>I can show that the LCS problem has an optimal substructure
<ul>
<li>I can define the  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" />-th prefix of the sequence  <img class="inlinemath" src="eqn632.png" WIDTH=115 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X = \langle x_1,...,x_m \rangle" /> as the subsequence  <img class="inlinemath" src="eqn633.png" WIDTH=104 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X_i = \langle x_1,...x_i \rangle" /> with  <img class="inlinemath" src="eqn634.png" WIDTH=80 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i = 0,...,m" />  <img class="displaymath" src="eqn635.png" WIDTH=61 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" X_0 = \langle \ \rangle" />  <img class="displaymath" src="eqn636.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" X_1 = \langle x_1 \rangle" />  <img class="displaymath" src="eqn637.png" WIDTH=94 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" X_2 = \langle x_1,x_2 \rangle" />  <img class="displaymath" src="eqn638.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" X_i = \langle x_1,..,x_i \rangle" />  <img class="displaymath" src="eqn639.png" WIDTH=158 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" X_m = \langle x_1,..,x_m \rangle = X" /></li><li>I observe that, given  <img class="inlinemath" src="eqn632.png" WIDTH=115 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X = \langle x_1,...,x_m \rangle" />,  <img class="inlinemath" src="eqn604.png" WIDTH=129 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Y = \langle y_1, y_2, ..., y_n \rangle" />, and  <img class="inlinemath" src="eqn640.png" WIDTH=183 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Z = \langle z_1,...,z_k \rangle \in LCS_{X,Y}" /> <ul>
<li>If  <img class="inlinemath" src="eqn641.png" WIDTH=60 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x_m = y_n" /> then  <img class="inlinemath" src="eqn642.png" WIDTH=96 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="z_k = x_n = y_m" /> and  <img class="inlinemath" src="eqn643.png" WIDTH=35 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Z_{k-1}" /> is an LCS of  <img class="inlinemath" src="eqn644.png" WIDTH=41 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_{m-1}" /> and  <img class="inlinemath" src="eqn645.png" WIDTH=34 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Y_{n-1}" /></li><li>If  <img class="inlinemath" src="eqn646.png" WIDTH=60 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x_m \not= y_n" /> and  <img class="inlinemath" src="eqn647.png" WIDTH=58 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="z_k \not= x_m" /> then  <img class="inlinemath" src="eqn617.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Z" /> is an LCS of  <img class="inlinemath" src="eqn644.png" WIDTH=41 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_{m-1}" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /></li><li>If  <img class="inlinemath" src="eqn646.png" WIDTH=60 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x_m \not= y_n" /> and  <img class="inlinemath" src="eqn648.png" WIDTH=54 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="z_k \not= y_n" /> then  <img class="inlinemath" src="eqn617.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Z" /> is an LCS of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn645.png" WIDTH=34 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Y_{n-1}" /></li></ul></li>
<li>These statements can be prooven by contradiction assuming the negation of the aforementioned property  <img class="inlinemath" src="eqn649.png" WIDTH=24 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\lnot \mathbb{P}" /></li><li>For the first statement, I assume by contradiction that  <img class="inlinemath" src="eqn650.png" WIDTH=135 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="x_m = y_n \land z_k \not = x_m" /> <ul>
<li>I can then append  <img class="inlinemath" src="eqn641.png" WIDTH=60 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x_m = y_n" /> to  <img class="inlinemath" src="eqn617.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Z" /> to get  <img class="inlinemath" src="eqn651.png" WIDTH=215 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Z'=\langle z_1,...,z_k,x_m \rangle \in LCS_{X,Y}" /></li><li>Therefore,  <img class="inlinemath" src="eqn652.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="Z'" /> will be  <img class="inlinemath" src="eqn653.png" WIDTH=38 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="k+1" /> characters long:  <img class="inlinemath" src="eqn654.png" WIDTH=82 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|Z| = k+1" /></li><li>This is impossible since  <img class="inlinemath" src="eqn655.png" WIDTH=174 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|W| = k \ \forall \ W \in LCS_{X,Y}" /></li></ul></li>
<li>For the second statement I assume by contradiction that  <img class="inlinemath" src="eqn647.png" WIDTH=58 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="z_k \not= x_m" /> and there is a sequence  <img class="inlinemath" src="eqn450.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W" /> such that  <img class="inlinemath" src="eqn656.png" WIDTH=207 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="W\in LCS_{X_{m-1},Y} \land |W| &gt; |Z|" />, where  <img class="inlinemath" src="eqn657.png" WIDTH=93 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="Z = LCS_{X,Y}" /> <ul>
<li>In this case then must be that  <img class="inlinemath" src="eqn658.png" WIDTH=97 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="W \in LCS_{X,Y}" />, which contradicts the assumption that  <img class="inlinemath" src="eqn623.png" WIDTH=91 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="Z \in LCS_{X,Y}" /></li></ul></li>
<li>The third statement is symmetric to the second</li>
<li>Therefore, the LCS of 2 sequences contains the LCS of their subsequences: we have an optimal substructure</li>
</ul></li>
<li>I can define the LCS of 2 sequences recursively because of the theorems stated above  <img class="displaymath" src="eqn659.png" WIDTH=492 HEIGHT=73 STYLE="vertical-align: -32px; margin: 0;" alt="LCS_{X,Y} = \begin{cases}\epsilon = \langle \ \rangle &amp; \mbox{if } m = 0 \lor n=0 \\ LCS_{X_{m-1},Y_{n-1}} \cdot x_m &amp; \mbox{if } x_m = y_n \\ max(|LCS_{X_{m-1},Y}|,|LCS_{X,Y_{n-1}}|) &amp; \mbox{otherwise}\end{cases}" /></li><li>The LCS problem can involve many overlapping subproblems
<ul>
<li>If  <img class="inlinemath" src="eqn660.png" WIDTH=65 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="m_m \not= y_n" /> finding first  <img class="inlinemath" src="eqn661.png" WIDTH=82 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="LCS_{X_{m-1},Y}" /> and then from that  <img class="inlinemath" src="eqn662.png" WIDTH=75 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="LCS_{X,Y_{n-1}}" /> leads to calculating  <img class="inlinemath" src="eqn663.png" WIDTH=98 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="LCS_{X_{m-1},Y_{n-1}}" />, which is calculated directly also from  <img class="inlinemath" src="eqn664.png" WIDTH=36 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X,Y" /> when  <img class="inlinemath" src="eqn641.png" WIDTH=60 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x_m = y_n" /></li><li>This case happens for any  <img class="inlinemath" src="eqn665.png" WIDTH=42 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="X_i,Y_j" /> with  <img class="inlinemath" src="eqn666.png" WIDTH=80 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i=2,...,m" /> and  <img class="inlinemath" src="eqn667.png" WIDTH=78 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j=2,...,n" /></li></ul></li>
<li>I can create a dynamic programming table  <img class="inlinemath" src="eqn668.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="C(i,j)" /> of dimensions  <img class="inlinemath" src="eqn669.png" WIDTH=50 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\Theta(mn)" /> such that  <img class="displaymath" src="eqn670.png" WIDTH=446 HEIGHT=73 STYLE="vertical-align: -32px; margin: 0;" alt="C(i,j) = \begin{cases} 0 &amp; \mbox{if } i = 0 \lor j=0 \\ C(i-1,j-1)+1 &amp; \mbox{if } x_i = y_j \\ max(C(i-1,j),C(i,j-1)) &amp; \mbox{otherwise}\end{cases}" />  <img class="displaymath" src="eqn671.png" WIDTH=188 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" i = 0,...,m \qquad j = 0,...,n" /></li><li>After computing the whole table,  <img class="inlinemath" src="eqn672.png" WIDTH=58 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="C(m,n)" /> will contain the lenght of the LCS of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />  <img class="displaymath" src="eqn673.png" WIDTH=305 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" C(m,n) = |LCS_{X,Y}| \qquad m=|X|,\ n=|Y|" /></li><li>The table  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> can be filled iteratively by starting from  <img class="inlinemath" src="eqn674.png" WIDTH=50 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="C(0,0)" /></li><li>In order to reconstruct the solution of the LCS problem we need to use a backtrack table  <img class="inlinemath" src="eqn480.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(i,j)" /> such that  <img class="displaymath" src="eqn675.png" WIDTH=400 HEIGHT=73 STYLE="vertical-align: -32px; margin: 0;" alt="B(i,j) = \begin{cases}MATCH &amp; \mbox{if } x_i = y_j \\ UP &amp; \mbox{if } C(i-1,j) \geq C(i,j-1)) \\ LEFT &amp; \mbox{otherwise}\end{cases}" />  <img class="displaymath" src="eqn671.png" WIDTH=188 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" i = 0,...,m \qquad j = 0,...,n" /></li><li>Note that  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> will contain the reverse of an LCS of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />  <img class="displaymath" src="eqn676.png" WIDTH=126 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" inv(S) \in LCS_{X,Y}" /></li><li>The solution can be reconstructed by starting from  <img class="inlinemath" src="eqn677.png" WIDTH=58 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B(m,n)" /> and iterating until  <img class="inlinemath" src="eqn678.png" WIDTH=94 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i=0 \lor j=0" />, building the solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> as  <img class="displaymath" src="eqn679.png" WIDTH=418 HEIGHT=73 STYLE="vertical-align: -32px; margin: 0;" alt="\begin{cases} B(i,j) = MATCH \implies S=S \cdot x_i,\ i=i-1,j=j-1 \\ B(i,j) = UP \implies i=i-1 \\ B(i,j)=LEFT \implies j=j-1\end{cases}" /></li><li>I can now define the function LCS-LENGTH( <img class="inlinemath" src="eqn664.png" WIDTH=36 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X,Y" />) that returns the corresponding  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> and  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> tables<ul>
<li>Its cost is  <img class="inlinemath" src="eqn680.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(mn)" /> since I need to fill the tables  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> and  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> which have dimensions  <img class="inlinemath" src="eqn680.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(mn)" /></li></ul></li>
</ul>
<ul>
<li>The function PRINT-LCS( <img class="inlinemath" src="eqn681.png" WIDTH=64 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="B,X,i,j" />) prints a sequence  <img class="inlinemath" src="eqn682.png" WIDTH=79 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\in LCS_{X,Y}" /> using the  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> table<ul>
<li>Its initial call is PRINT-LCS( <img class="inlinemath" src="eqn683.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="B,X,m,n" />)</li><li>Note that since the function is recursive the LCS is printed in the correct order!</li>
<li>Its cost is  <img class="inlinemath" src="eqn684.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m+n)" /> since at each step either  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> or  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> is decreased, and at most I can have  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> steps in which  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> is reduced and  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> steps in which  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> is reduced</li></ul></li>
</ul>
<ul>
<li>Note that the  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> table speeds up the reconstruction of the solution but it is redundant<ul>
<li>If space is an issue I can avoid storing it and re-calculate the backtrack path (at a time cost)</li>
</ul></li>
<li>If I am only interested in  <img class="inlinemath" src="eqn627.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|LCS_{X,Y}|" /> I can avoid filling  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> without worries and I can at any time store only 2 rows of  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /></li></ul>
<h3 id="approximate-string-matching">Approximate string matching</h3>
<ul>
<li>The string matching problem: I want to find occurrences of a query string  <img class="inlinemath" src="eqn685.png" WIDTH=99 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P=p_1 \cdot \cdot \cdot p_m" /> called pattern in a target string  <img class="inlinemath" src="eqn686.png" WIDTH=90 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="T = t_1 \cdot \cdot \cdot t_n" /> with  <img class="inlinemath" src="eqn687.png" WIDTH=48 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="m \leq n" /></li><li>A k-approximation of a string  <img class="inlinemath" src="eqn688.png" WIDTH=99 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P = p_1 \cdot \cdot \cdot p_m" /> is a string  <img class="inlinemath" src="eqn689.png" WIDTH=103 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="P'=p_1' \cdot \cdot \cdot p_m'" /> that can be obtained from the  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> by performing  <img class="inlinemath" src="eqn690.png" WIDTH=78 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="0 \leq k \leq m" /> edit operations<ul>
<li> <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> is defined as the edit distance between  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> and  <img class="inlinemath" src="eqn691.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="P'" /></li></ul></li>
<li>An edit operation is one of the following
<ul>
<li>A substitution where a character  <img class="inlinemath" src="eqn692.png" WIDTH=14 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="p_i" /> is replaced by the character  <img class="inlinemath" src="eqn693.png" WIDTH=14 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="p_i'" /></li><li>An insertion where a new character  <img class="inlinemath" src="eqn693.png" WIDTH=14 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="p_i'" /> is added</li><li>A deletion where a character  <img class="inlinemath" src="eqn692.png" WIDTH=14 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="p_i" /> is removed from  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /></li></ul></li>
<li>Approximate string matching (ASM) takes in input the strings  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> and  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> and it returns a k-approximation  <img class="inlinemath" src="eqn691.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="P'" /> of  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> with minimum  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> <ul>
<li>Note that all the approximations  <img class="inlinemath" src="eqn691.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="P'" /> with minimum  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> that occur in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> are solution to the ASM problem, regardless of their length</li></ul></li>
<li>Let now  <img class="inlinemath" src="eqn691.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="P'" /> be a k-approximated occurrence of  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> with minimum  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li>I can compute  <img class="inlinemath" src="eqn691.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="P'" /> by defining a table  <img class="inlinemath" src="eqn694.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="D" /> where  <img class="inlinemath" src="eqn695.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(i,j)" /> is the minimum  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> for which a k-approximation of the prefix  <img class="inlinemath" src="eqn696.png" WIDTH=17 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P_i" /> in the prefix  <img class="inlinemath" src="eqn697.png" WIDTH=17 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="T_j" /> exists  <img class="displaymath" src="eqn698.png" WIDTH=584 HEIGHT=73 STYLE="vertical-align: -32px; margin: 0;" alt="D(i,j) = \begin{cases} 0 &amp; \mbox{if } i=0 \\ i &amp; \mbox{if } j=0 \\ min(D(i-1,j-1)+\delta_{ij},D(i-1,j), D(i,j-1))+1 &amp; \mbox{otherwise}\end{cases}" />  <img class="displaymath" src="eqn699.png" WIDTH=184 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="\delta_{ij} = \begin{cases} 0 &amp; \mbox{if } p_i=t_j \\ 1 &amp; \mbox{otherwise}\end{cases}" />  <img class="displaymath" src="eqn671.png" WIDTH=188 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt=" i = 0,...,m \qquad j = 0,...,n" /> <ul>
<li>The value  <img class="inlinemath" src="eqn695.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(i,j)" /> remains equal to  <img class="inlinemath" src="eqn700.png" WIDTH=105 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(i-1,j-1)" /> if  <img class="inlinemath" src="eqn701.png" WIDTH=48 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="p_i = t_j" /></li><li>If  <img class="inlinemath" src="eqn702.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="p_i \not= t_j" />, the cell from which  <img class="inlinemath" src="eqn695.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(i,j)" /> is derived is choosen so to minimize its final value</li><li>Note how the ASM problem shows optimal substructure</li>
<li> <img class="inlinemath" src="eqn703.png" WIDTH=178 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(0,j) = 0 \ \forall\ j=0,...,n" /> since the prefix  <img class="inlinemath" src="eqn704.png" WIDTH=48 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P_0 = \epsilon" /> occurs in any possible substring  <img class="inlinemath" src="eqn697.png" WIDTH=17 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="T_j" /></li><li> <img class="inlinemath" src="eqn705.png" WIDTH=175 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(i,0) = i \ \forall\ i=0,...,m" /> since to match  <img class="inlinemath" src="eqn696.png" WIDTH=17 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P_i" /> with  <img class="inlinemath" src="eqn706.png" WIDTH=18 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="T_0" /> I need to delete all the characters in  <img class="inlinemath" src="eqn696.png" WIDTH=17 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P_i" /></li><li> <img class="inlinemath" src="eqn707.png" WIDTH=57 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(m,j)" /> contains the minimum  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> for a k-approximation of  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> in  <img class="inlinemath" src="eqn697.png" WIDTH=17 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="T_j" /></li><li>The minimum value  <img class="inlinemath" src="eqn708.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k^*" /> for a k-approximation of  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is the smallest value of the last row (except the trivial  <img class="inlinemath" src="eqn709.png" WIDTH=38 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i=0" />, where  <img class="inlinemath" src="eqn710.png" WIDTH=54 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="k=|P|" />)  <img class="displaymath" src="eqn711.png" WIDTH=221 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" k^* = min\{D(m,j)|j=1,...,n\}" /></li></ul></li>
<li>I can define the function APP-STR-MATCH( <img class="inlinemath" src="eqn712.png" WIDTH=33 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="P,T" />) that returns  <img class="inlinemath" src="eqn708.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k^*" /> and the prefix  <img class="inlinemath" src="eqn697.png" WIDTH=17 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="T_j" /> on which it was obtained<ul>
<li>This algorithm costs  <img class="inlinemath" src="eqn680.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(mn)" /> similarly to the LCS algorithm and we can use a backtrack matrix to build the solution</li></ul></li>
<li>To build the solution I follow the backtrack matrix from the cell corresponding to the minimal value in the last row of the matrix  <img class="inlinemath" src="eqn694.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="D" /> <ul>
<li>Each direction on the backtrack matrix indicates what kind of edit operation must be performed</li>
<li>A special direction can be inserted in the matrix for when  <img class="inlinemath" src="eqn701.png" WIDTH=48 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="p_i = t_j" /> and  <img class="inlinemath" src="eqn700.png" WIDTH=105 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(i-1,j-1)" /> was the minimal value choosen,<ul>
<li>In this case no edit needs to be performed</li>
</ul></li>
</ul></li>
</ul>
<h3 id="related-problems">Related problems</h3>
<ul>
<li>Dynamic programming can be applied to many problems related to finding the longest common subsequent and to approximate string matching, but it is not necessarily the best approach</li>
<li>The longest common substring problem is similar to the longest common subsequence problem but with the further constraint that the common characters must be contiguous (they must be a substring, not a subsequence!)</li>
<li>Exact string matching is similar to approximate string matching but it requires the edit distance  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> to be 0</li><li>Minimum edit distance is similar to ASM but it requires that the  <img class="inlinemath" src="eqn691.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="P'" /> approximation found be equal to  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> <ul>
<li>It is the problem of finding the minimum number of edits that can transform  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /></li></ul></li>
</ul>
<h2 id="greedy-algorithms-1">Greedy algorithms</h2>
<ul>
<li>An optimization algorithm typically go through a series of steps  <img class="inlinemath" src="eqn713.png" WIDTH=64 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_1,...,S_n" /> where at each step  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> I can have different choices  <img class="inlinemath" src="eqn714.png" WIDTH=77 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="C_{i_1},...,C_{i_m}" /></li><li>Dynamic programming evaluates all the possible choices at each step in a bottom-up fashion, avoiding to re-evaluate the same choice multiple times</li>
<li>Dynamic programming guarantees to find a globally optimal solution if its assumptions are respected</li>
<li>However, sometimes a simpler and more efficient greedy approach suffices for our problem</li>
<li>Greedy algorithms make a single choice  <img class="inlinemath" src="eqn715.png" WIDTH=23 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="C_{i^*}" /> that is locally optimal at each step without considering all the possible choices</li><li>Greedy algorithms first appeared in a 1971 paper form Jack Edmonds “Matroids and the greedy algorithm”</li>
<li>A greedy approach is based on the hope that a sequence of locally optimal choice will bring to a globally optimal solution
<ul>
<li>This is NOT guaranteed to be true, and in general greedy algorithms are NOT guaranteed to find a globally optimal solution</li>
</ul></li>
<li>However, if our problem shows the 2 following properties it is possible to develop a globally optimal greedy algorithm
<ul>
<li>The problem shows optimal substructure</li>
<li>The problem exhibits the greedy-choice property: I can get a globally optimal solution by making always locally optimal choices</li>
</ul></li>
<li>Any problem that can be solved by a greedy approach can also be solved by dynamic programming, but DP is typically slower than a greedy algorithm in these cases</li>
<li>Given an input set of objects  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" />, a greedy strategy selects an hopefully optimal subset  <img class="inlinemath" src="eqn716.png" WIDTH=50 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="S \subseteq X" /></li><li>The solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is built incrementally, adding at each step the locally optimal object  <img class="inlinemath" src="eqn717.png" WIDTH=46 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x \in X" /> according to an optimality criterion  <img class="inlinemath" src="eqn436.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="c" /></li></ul>
<ul>
<li>In a greedy algorithm decisions are take from the top-down and do not depend on sub-problems</li>
<li>Advantages of a greedy strategy
<ul>
<li>It is easy and intuitive to design</li>
<li>It is pretty efficient</li>
<li>It is globally optimal if the probelm has optimal substructure and it exhibits the greedy choice property</li>
<li>Even when it gives a sub-optimal solution, for some problems this can be acceptable!
<ul>
<li>This is true especially when I can give a bound to the distance between the greedy solution and the globally optimal solution</li>
</ul></li>
</ul></li>
<li>Disadvantages of a greedy strategy
<ul>
<li>Only few problems exhibit the greedy choice property</li>
</ul></li>
</ul>
<h3 id="minimum-spanning-tree">Minimum spanning tree</h3>
<ul>
<li>The minimum spanning tree problem is formulated as follows: given a connected, undirected, and weighted graph  <img class="inlinemath" src="eqn718.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G = (V, E)" /> with weight function  <img class="inlinemath" src="eqn719.png" WIDTH=113 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="w : V \times V \to E" />, return a minimum spanning tree (MST)  <img class="inlinemath" src="eqn720.png" WIDTH=49 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="T \subseteq E" /> such that<ul>
<li> <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is a connected, undirected and acyclic graph (it is a tree!)</li><li> <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> connects all the nodes in  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /> (it is a spanning tree!)  <img class="displaymath" src="eqn721.png" WIDTH=193 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\exists u \leadsto v \in T \qquad \forall \ u, v \in V" /></li><li>The weight of  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is minimal: there is no other spanning tree  <img class="inlinemath" src="eqn706.png" WIDTH=18 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="T_0" /> with weight smaller than that of  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" />  <img class="displaymath" src="eqn722.png" WIDTH=324 HEIGHT=44 STYLE="vertical-align: -24px; margin: 0;" alt="\nexists T' : w(T') &lt; w(T) \qquad w(T) = \sum_{(u,v) \in T} w(u,v)" /></li></ul></li>
<li>The minimum spanning tree probelm is relevant for many applications
<ul>
<li>Designing an electronic circuit with the least amount of wire</li>
<li>Constructin a minimum ultrametric tree</li>
</ul></li>
<li>The MST problem can be optimally solved with a greedy strategy</li>
<li>An MST always exists for a connected and undirected graph, but it may not be unique</li>
<li>The greedy algorithm for obtaining a MST starts from an empty tree  <img class="inlinemath" src="eqn723.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T = \emptyset" /> add adds to it a safe edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> at a time  <img class="displaymath" src="eqn724.png" WIDTH=268 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt=" T_i = \begin{cases} T_{i-1} \cup \{(u,v)\} &amp; \mbox{for } i &gt; 0 \\ T_i = 0 &amp; \mbox{for } i = 0 \end{cases}" /></li><li>An edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> is safe for  <img class="inlinemath" src="eqn725.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="T_i" /> iff the tree resulting from adding it to  <img class="inlinemath" src="eqn725.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="T_i" /> is a subset of some MST  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" />  <img class="displaymath" src="eqn726.png" WIDTH=302 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v) \mbox{ is safe } \iff T_i \cup \{(u,v)\} \\subseteq T" /></li></ul>
<ul>
<li>A cut  <img class="inlinemath" src="eqn727.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(S, V - S)" /> of  <img class="inlinemath" src="eqn728.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V, E)" /> is a partition of  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /></li><li>An edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> crosses the cut  <img class="inlinemath" src="eqn727.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(S, V - S)" /> if  <img class="inlinemath" src="eqn729.png" WIDTH=309 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u \in S \land v \in V - S)\lor(v \in S \land u \in V - S)" /></li><li>A cut  <img class="inlinemath" src="eqn730.png" WIDTH=75 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(S,S-V)" /> respects a set of edges  <img class="inlinemath" src="eqn731.png" WIDTH=50 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="A \subseteq E" /> if no edge in  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> crosses the cut</li><li>An edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> crossing a cut  <img class="inlinemath" src="eqn732.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(S,V-S)" /> is a light edge if  <img class="inlinemath" src="eqn733.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(u,v)" /> is minimal among all the edges crossing the cut</li><li>Let  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> be a connected, underected graph with weight function  <img class="inlinemath" src="eqn734.png" WIDTH=14 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="w" /></li><li>Let  <img class="inlinemath" src="eqn735.png" WIDTH=49 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="A \subseteq T" /> be the subset of some MST  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> for  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /></li><li>If  <img class="inlinemath" src="eqn732.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(S,V-S)" /> is a cut repsecting  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> and if  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> is a light edge crossing the cut, then  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> is safe for  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> <ul>
<li>I know that  <img class="inlinemath" src="eqn735.png" WIDTH=49 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="A \subseteq T" />, but I have to prove that  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> is safe for  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /></li><li>Proving that  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> is safe for  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> means proving that adding  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> to  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> I get a subset of some MST  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" />  <img class="displaymath" src="eqn736.png" WIDTH=121 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A \cup \{(u,v)\} \subseteq T" /></li><li>If  <img class="inlinemath" src="eqn737.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v) \in T" /> I am done since  <img class="inlinemath" src="eqn738.png" WIDTH=49 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="A\subseteq T" /> and so  <img class="inlinemath" src="eqn739.png" WIDTH=121 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A\cup\{(u,v)\} \subseteq T" /></li><li>If  <img class="inlinemath" src="eqn740.png" WIDTH=72 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v) \not\in T" /> I build a spanning tree  <img class="inlinemath" src="eqn741.png" WIDTH=219 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="T'=(T-\{(u',v')\})\cup\{(u,v)\}" /> where  <img class="inlinemath" src="eqn742.png" WIDTH=80 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u',v') \not\in A" /> is an edge on the path  <img class="inlinemath" src="eqn743.png" WIDTH=45 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u \leadsto v" /></li><li>I note that  <img class="inlinemath" src="eqn744.png" WIDTH=248 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(T')=w(T)-w(u',v')+w(u,v)" /> and  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> is light, so  <img class="inlinemath" src="eqn745.png" WIDTH=100 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(T')\leq w(T)" /></li><li>I also know that  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is a MST so  <img class="inlinemath" src="eqn746.png" WIDTH=100 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(T')\geq w(T)" />  <img class="displaymath" src="eqn747.png" WIDTH=361 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" w(T') \leq w(T) \land w(T') \geq w(T) \implies w(T')=w(T)" /></li><li>Since  <img class="inlinemath" src="eqn748.png" WIDTH=100 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(T')=w(T)" />, I conclude that  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" /> is a MST</li><li>Since  <img class="inlinemath" src="eqn735.png" WIDTH=49 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="A \subseteq T" /> and  <img class="inlinemath" src="eqn742.png" WIDTH=80 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u',v') \not\in A" /> I have that  <img class="inlinemath" src="eqn749.png" WIDTH=130 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A \subseteq T-\{(u',v')\}" /> and thus  <img class="inlinemath" src="eqn750.png" WIDTH=326 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A \cup\{(u,v)\}\subseteq (T-\{(u',v')\})\cup\{(u,v)\}=T'" /></li></ul></li>
<li>Thanks to this theorem, I can build a MST by adding safe edges to a smaller MST</li>
</ul>
<h4 id="kruskal-algorithm">Kruskal algorithm</h4>
<ul>
<li>The Kruskal algorithm is a possible implementation of the GENERIC-MST algorithm seen above</li>
<li>I grow and merge forests of MSTs by incrementally adding safe edges until the final MST is computed</li>
<li>The algorithm is greedy since at each steps it adds to the forest the edge with minimal weight</li>
<li>It is possible to implement the Kruscal algorithm with the disjoint-set data structure
<ul>
<li>I represent each MST as a disjoint-set, where each MST node is an element of the set</li>
<li>FIND-SET and UNION operations are used to determine whether to merge disjoint sets</li>
</ul></li>
<li>If  <img class="inlinemath" src="eqn751.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|V|" /> and  <img class="inlinemath" src="eqn752.png" WIDTH=59 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m=|E|" />, I have the following time costs<ul>
<li>MAKE-SET costs in total  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /></li><li>SORT costs in total  <img class="inlinemath" src="eqn753.png" WIDTH=82 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \log m)" /></li><li>FIND-SET and UNION are performed  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> times so their total cost is  <img class="inlinemath" src="eqn754.png" WIDTH=136 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \alpha(n)) \approx O(m)" /> using path compression and union-by-rank</li><li>The overall cost is  <img class="inlinemath" src="eqn753.png" WIDTH=82 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \log m)" /></li></ul></li>
</ul>
<h4 id="other-mst-algorithms">Other MST algorithms</h4>
<ul>
<li>Kruskal’s algorithm is not the only MST algorithm known</li>
<li>Prim’s MST algorithm works similarly to the Dijkstra algorihtm for the shortest path in a graph and it has the same asymptotic complexity of Kruscal’s algorithm ( <img class="inlinemath" src="eqn753.png" WIDTH=82 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \log m)" />)</li><li>Fredman and Tarjan’s MST algorithm is based on the Fibonacci heap and runs in  <img class="inlinemath" src="eqn575.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m+n \log n)" /></li><li>Karger, Klein and Tarjan’s MST randomized algorithm runs in  <img class="inlinemath" src="eqn684.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m+n)" /></li><li>Fredman and Willard’s MST algorithm is not based on comparisons and runs in  <img class="inlinemath" src="eqn684.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m+n)" /></li></ul>
<h3 id="optimal-greedy-algorithms">Optimal greedy algorithms</h3>
<ul>
<li>Greedy algorithms can find the globally optimal solution for other problems besides MST in polynomial time</li>
<li>Huffman codes: given an alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /> and weights  <img class="inlinemath" src="eqn755.png" WIDTH=78 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="w : \Sigma \to \mathbb{R}" /> return a prefix code with codewords of minimum lenght</li><li>Activity selection: given  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> activities  <img class="inlinemath" src="eqn756.png" WIDTH=111 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=\{a_1,...,a_n\}" /> having start and finish times  <img class="inlinemath" src="eqn757.png" WIDTH=46 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(s_i,e_i)" /> select a maximum-size set  <img class="inlinemath" src="eqn758.png" WIDTH=47 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="T \subseteq S" /> of non-overlapping activities to be executed</li><li>Fractional knapsack: given objects  <img class="inlinemath" src="eqn759.png" WIDTH=69 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="O_1,...,O_n" /> where  <img class="inlinemath" src="eqn760.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="O_i" /> has value  <img class="inlinemath" src="eqn423.png" WIDTH=14 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="v_i" /> and weight  <img class="inlinemath" src="eqn761.png" WIDTH=18 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="w_i" />, and a knapsack of capacity  <img class="inlinemath" src="eqn450.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W" />, select an amount  <img class="inlinemath" src="eqn762.png" WIDTH=68 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="x_i \in [0,1]" /> for each object  <img class="inlinemath" src="eqn760.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="O_i" /> such that  <img class="inlinemath" src="eqn763.png" WIDTH=115 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sum_{i=1}^n w_ix_i \leq W" /> and the total value  <img class="inlinemath" src="eqn764.png" WIDTH=71 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sum_{i=1}^n v_ix_i" /> is maximal<ul>
<li>It is a generalization of the 0-1 knapsack problem in which  <img class="inlinemath" src="eqn765.png" WIDTH=59 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="x_i \in {0,1}" /></li></ul></li>
</ul>
<h3 id="non-optimal-greedy-algorithms">Non-optimal greedy algorithms</h3>
<ul>
<li>For several problems greedy algorithms exist but they do not find a globally optimal solution</li>
<li>Change-making: given  <img class="inlinemath" src="eqn766.png" WIDTH=42 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="n &gt; 0" />, return the smallest number of coins whose total value adds up to  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> <ul>
<li>The greedy approach involves sorting the coins in decreasing value order and, at each step, using the largest number of coins from the current value</li>
<li>It is a particular case of the  <img class="inlinemath" src="eqn767.png" WIDTH=30 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="O,1" /> knapsack problem where each object has the same value (I want to minimize the number of objects)</li></ul></li>
<li>Set-cover: given an universe  <img class="inlinemath" src="eqn768.png" WIDTH=99 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="U = \{1,...,n\}" /> and a set of sets  <img class="inlinemath" src="eqn769.png" WIDTH=117 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S = \{S_1,...,S_m\}" /> such that  <img class="inlinemath" src="eqn770.png" WIDTH=90 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\cup_{i=1}^m S_i = U" /> identify the smallest set  <img class="inlinemath" src="eqn771.png" WIDTH=48 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="C \subseteq S" /> such that  <img class="inlinemath" src="eqn772.png" WIDTH=99 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\cup_{S_i \in C} S_i = U" /> <ul>
<li>The greeady approach is to always choose the set  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> that contains the biggest number of elements not yet in a set  <img class="inlinemath" src="eqn773.png" WIDTH=19 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_k" /> already in  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /></li><li>The greedy strategy is not optimal but guarantees that the solution found  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> will be at most  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> bigger than the optimal solution  <img class="inlinemath" src="eqn774.png" WIDTH=21 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C^*" /></li></ul></li>
</ul>
<h2 id="local-search">Local search</h2>
<ul>
<li>Local search is yet another approach to tackle optimization problems</li>
<li>It starts from a feasible solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> and searches for a better solution  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" /> in the neighborod  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" /> of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> <ul>
<li>This approach is then iterated on  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" /> to obtain  <img class="inlinemath" src="eqn777.png" WIDTH=20 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S''" />, and so on</li></ul></li>
<li>Local search converges on a local optimum, that may or may not correspond to a global optimum
<ul>
<li>Because of this we say that local search is not complete</li>
</ul></li>
<li>Formally we can define local serach in the following way
<ul>
<li>Let  <img class="inlinemath" src="eqn778.png" WIDTH=10 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\zeta" /> be the set of solutions for a given problem</li><li>I define a neighborhood function  <img class="inlinemath" src="eqn779.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -4px; margin: 0;" alt="N : \zeta \to 2^\zeta" /> such that  <img class="inlinemath" src="eqn780.png" WIDTH=157 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)=\{S,S_1,...,S_k\}" /> is the neighborhood of the solution  <img class="inlinemath" src="eqn781.png" WIDTH=42 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="S \in \zeta" /> <ul>
<li>The codomain of  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" /> is  <img class="inlinemath" src="eqn782.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^\zeta" /> since it produces 1 of the  <img class="inlinemath" src="eqn782.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^\zeta" /> possible subsets of solutions from the set of all possible solutions  <img class="inlinemath" src="eqn778.png" WIDTH=10 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\zeta" /></li></ul></li>
<li>I define a transition function  <img class="inlinemath" src="eqn783.png" WIDTH=20 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\delta_N" /> for each neighborhood  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" /> such that  <img class="inlinemath" src="eqn784.png" WIDTH=102 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\delta_N(S) \in N(S)" /> is the next solution to explore after  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> <ul>
<li> <img class="inlinemath" src="eqn785.png" WIDTH=43 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\delta_N(S)" /> is 1 of the solutions in  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" /></li><li>When there are no more solutions to explore in  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" />, then  <img class="inlinemath" src="eqn786.png" WIDTH=77 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\delta_N(S)=S" /></li><li>If  <img class="inlinemath" src="eqn787.png" WIDTH=80 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|N(S)|" />, there are  <img class="inlinemath" src="eqn234.png" WIDTH=15 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="n!" /> possible transition functions for  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" /></li></ul></li>
<li>I define a cost function  <img class="inlinemath" src="eqn788.png" WIDTH=72 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\phi : \zeta \to \mathbb{R}" /> to rank the solutions  <img class="inlinemath" src="eqn781.png" WIDTH=42 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="S \in \zeta" />  <img class="displaymath" src="eqn789.png" WIDTH=277 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \phi(S) &lt; \phi(S') \iff S \mbox{ is better than } S'" /></li><li>The solution  <img class="inlinemath" src="eqn597.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S^*" /> is a local optimum for  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" /> iff its cost is minimal among all the solutions in  <img class="inlinemath" src="eqn776.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(S)" />  <img class="displaymath" src="eqn790.png" WIDTH=256 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" S^* : \phi(S^*) = min\{\phi(S')|S' \in N(S)\}" /></li></ul></li>
<li>The local optimum on which a local search converges depends on the starting solution  <img class="inlinemath" src="eqn791.png" WIDTH=18 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_0" /></li><li>A general local search algorithm looks like this</li>
</ul>
<ul>
<li>Many local search approaches have been developped: hill climbing, simulated annealing, tabu search, …</li>
<li>Local search has been effectively applied to a number of famous problems: minimum vertex cover, travelling saleseman problem, boolean satisfiability problem* Local search can be applied to sorting problems: insertion-sort, shell-sort, and bubble-sort can be seen as local search approaches that try to minimize conflicts (misplaced elements)</li>
</ul>
<h3 id="minimum-spanning-tree-with-local-search">Minimum spanning tree with local search</h3>
<ul>
<li>It is possible to use local search to solve the MST problem</li>
<li>Let  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> be any spanning tree for the graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> with cost function  <img class="inlinemath" src="eqn734.png" WIDTH=14 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="w" /></li><li>I define  <img class="inlinemath" src="eqn792.png" WIDTH=40 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(T)" /> as the set of trees obtained from  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> by adding an edge from the set of edges  <img class="inlinemath" src="eqn793.png" WIDTH=48 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="E-T" /> and removing an edge from the resulting circuit<ul>
<li>Since  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is a spanning tree, adding an edge to it necessarily results in forming a circuit</li><li>In practice I am exchanging an edge in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> for an edge which is not in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /></li></ul></li>
<li>I define the cost function  <img class="inlinemath" src="eqn794.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\phi(T)" /> so to be equal to the weight of the tree  <img class="inlinemath" src="eqn795.png" WIDTH=38 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(T)" />  <img class="displaymath" src="eqn796.png" WIDTH=94 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \phi(T)=w(T)" /></li><li>I can then use local search to possibly replace an edge from a spanning tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> at each iteration until  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> becomes a MST</li><li>In any case, I replace the edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> with the edge  <img class="inlinemath" src="eqn797.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u',v')" /> only if this reduces the weight of the tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /></li><li>For the MST problem, local search is guaranteed to find the global optimum, but the Kruskal algorithm is faster</li>
</ul>
<h3 id="sorting-with-local-search">Sorting with local search</h3>
<ul>
<li>Local search can be used to sort a collection of elements by reframing the sorting problem as an optimization problem</li>
<li>Given the sequence  <img class="inlinemath" src="eqn798.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A = \langle a_1,...,a_n \rangle" /> I say that  <img class="inlinemath" src="eqn407.png" WIDTH=34 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(i,j)" /> is a conflict for  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> if  <img class="inlinemath" src="eqn799.png" WIDTH=51 HEIGHT=17 STYLE="vertical-align: -5px; margin: 0;" alt="a_i &gt; a_j" /> while  <img class="inlinemath" src="eqn800.png" WIDTH=37 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i&lt;j" />  <img class="displaymath" src="eqn801.png" WIDTH=389 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" (i,j) \mbox{ is a conflict for } A \iff 1\leq i &lt; j \leq n \ \land \ a_i &gt; a_j" />  <img class="displaymath" src="eqn802.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A = \langle a_1,...,a_n \rangle" /></li><li>If  <img class="inlinemath" src="eqn407.png" WIDTH=34 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(i,j)" /> is a conflict for  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />, then  <img class="inlinemath" src="eqn142.png" WIDTH=15 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="a_i" /> and  <img class="inlinemath" src="eqn803.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -5px; margin: 0;" alt="a_j" /> are conflicting elements with distance  <img class="inlinemath" src="eqn804.png" WIDTH=35 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j-i" /></li><li>The problem of sorting the sequence  <img class="inlinemath" src="eqn805.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A = \langle a_1,...,a_n \rangle" /> can rephrased as the problem of finding a permutation  <img class="inlinemath" src="eqn806.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="A'" /> of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> having minimal number of conflicts</li><li>The sequence  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is sorted when it has 0 conflicts</li><li>The neighborhood of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is defined as the set of all the permutations of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> that can be obtained by swapping 2 conflicting elements</li><li>If  <img class="inlinemath" src="eqn805.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A = \langle a_1,...,a_n \rangle" /> and  <img class="inlinemath" src="eqn807.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\pi_{i,j}(A)" /> is the sequence obtained by swapping  <img class="inlinemath" src="eqn142.png" WIDTH=15 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="a_i" /> and  <img class="inlinemath" src="eqn803.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -5px; margin: 0;" alt="a_j" />, then I can defined the neighborhood of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />,  <img class="inlinemath" src="eqn808.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N(A)" /> as  <img class="displaymath" src="eqn809.png" WIDTH=235 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt="N(A)=\{\pi_{i,j}(A)|i&lt;j \land a_i&gt;a_j\}" /></li><li>The cost function  <img class="inlinemath" src="eqn810.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\phi(A)" /> can be then defined as the number of conflicts in  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> (the numerosity of the set of all the conflicts in  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />)  <img class="displaymath" src="eqn811.png" WIDTH=224 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt="\phi(A)=|\{(i,j)|i&lt;j \land a_i &gt; a_j\}|" /></li><li>In this case, the transition function  <img class="inlinemath" src="eqn812.png" WIDTH=44 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\delta_N(A)" /> defines how the array is sorted at each step</li></ul>
<h4 id="insertion-sort-1">Insertion sort</h4>
<ul>
<li>Insertion sort is not explicitly local search-based, but it follows a similar logic  <img class="displaymath" src="eqn813.png" WIDTH=375 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" \delta_N(A)=\pi_{i,i+1}(A) \qquad \mbox{where } i = min(\{k|a_k &gt; a_{k+1}\})" /> <ul>
<li>It recognizes the first conflict  <img class="inlinemath" src="eqn814.png" WIDTH=142 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="min(\{k|a_k &gt; a_{k+1}\})" /> among consecutive elements  <img class="inlinemath" src="eqn815.png" WIDTH=55 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="a_k,a_{k+1}" /> and swaps the offending elements</li></ul></li>
<li>Insertion sort is simple and efficient when the sequence to be sorted  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is small</li></ul>
<ul>
<li>The loop invariant in this pseudocode is that  <img class="inlinemath" src="eqn816.png" WIDTH=98 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\langle A[1],...,A[i] \rangle" /> is always sorted after the  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" />-th iteration of the for loop</li><li>The cost of insertion-sort depends on the number of conflicts in  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> <ul>
<li>In the best case, when  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is already sorted, the cost is  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /></li><li>In the worst case, when  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is in reversed sorted order, there are  <img class="inlinemath" src="eqn817.png" WIDTH=34 HEIGHT=26 STYLE="vertical-align: -7px; margin: 0;" alt="\frac{n^2-n}{2}" /> conflicts and the running time becomes  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /></li></ul></li>
</ul>
<h4 id="shell-sort">Shell sort</h4>
<ul>
<li>We can see that insertion-sort works like a local search by gradually reducing the muber of conflicts but
<ul>
<li>Only pairs contiguous elements are considered</li>
<li>Only 1 conflict is resolved at each step</li>
</ul></li>
<li>Shell-sort was proposed by Donald L. Shell in 1959 to overcome these limitations of insertion-sort</li>
<li>Shell-sort is a generalization of insertion-sort by considering the elements  <img class="inlinemath" src="eqn818.png" WIDTH=84 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="a[i],a[i+h]" /> at distance  <img class="inlinemath" src="eqn819.png" WIDTH=41 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="h \geq 1" /> from each other on the sequence<ul>
<li> <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> is decreased at each iteration until eventually shell-sort becomes equivalent to insertion-sort when  <img class="inlinemath" src="eqn820.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h=1" /></li><li>Shell-sort is correct only if, eventually,  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> becomes 1</li></ul></li>
<li>We can see shell-sort as a local search approach where  <img class="displaymath" src="eqn821.png" WIDTH=377 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" \delta_N(A)=\pi_{i,i+h}(A) \qquad \mbox{where } i = min(\{k|a_k &gt; a_{k+h}\})" /></li><li>In practice shell-sort at each iteration sorts distinct subsequences where the elements are  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> apart from each other  <img class="displaymath" src="eqn822.png" WIDTH=292 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\langle a_1,a_{h+1},a_{2h+1},... \rangle,\langle a_2,a_{h+2},a_{2h+2},... \rangle,..." /></li><li>Then, after having sorted all such subsequences it decreases  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> and repeats, until eventually  <img class="inlinemath" src="eqn820.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h=1" /> and it becomes equal to insertion-sort and  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is thus sorted</li><li>The variable  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> can be reduced in different steps</li><li>A commonly used approach is to reduce  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> by dividing it by 3 and taking the floor of the result  <img class="displaymath" src="eqn823.png" WIDTH=101 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="h_{k+1} = \lfloor h_k/3 \rfloor" /></li><li>In this case the sequence of  <img class="inlinemath" src="eqn152.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h" /> values will be  <img class="displaymath" src="eqn824.png" WIDTH=228 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="h = ...,1093,264,121,40,13,4,1" /></li></ul>
<ul>
<li>The complexity of shell-sort depends on the gap sequence adopted</li>
<li>Using the sequence  <img class="inlinemath" src="eqn825.png" WIDTH=101 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="h_{k+1} = \lfloor h_k/3 \rfloor" /> the complexity is usually  <img class="inlinemath" src="eqn826.png" WIDTH=52 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^{1.5})" /></li><li>Using other sequences, it can be from  <img class="inlinemath" src="eqn827.png" WIDTH=58 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^{1.25})" /> to  <img class="inlinemath" src="eqn828.png" WIDTH=79 HEIGHT=23 STYLE="vertical-align: -5px; margin: 0;" alt="O(n \log^2 n)" /></li><li>Shell-sort is the most efficient sorting algorithm for short ( <img class="inlinemath" src="eqn829.png" WIDTH=66 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="n &lt; 5000" />) sequences</li><li>For long sequences ( <img class="inlinemath" src="eqn830.png" WIDTH=66 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="n &gt; 5000" />) quick-sort is better, provided that some optimizations are implemented (iterative algorithm with random pivot, Bertossi et al.)</li></ul>
<h2 id="backtracking">Backtracking</h2>
<ul>
<li>The general idea of backtracking is to try a solution, check if it is feasible and if not go back and try a new solution</li>
<li>The term backtracking was coined by D.H. Lehmer in the 1950s</li>
<li>Backtrack explores exhaustively the search space and halts either at a feasible solution or after having explored all the solutions to the problem</li>
<li>It can be used for decision or optimization problems
<ul>
<li>In a decision problem all the solutions are equivalent</li>
<li>In an optimization problem solutiuons are ranked</li>
</ul></li>
<li>The time complexity of backtracking is typically high (exponential) since it is linear to the magnitude of the search space for the problem
<ul>
<li>A selected number of simple problems can be solved by a polynomial complexity backtracking approach</li>
</ul></li>
<li>Recursive backtracking works by generating and recursively visiting a search tree
<ul>
<li>When a leaf is reached if the solution is feasible the algorithm halts, if it is note it backtracks to the first node with yet unexplored branches</li>
<li>Its approach is similar to a tree visit or a DFS graph search</li>
</ul></li>
<li>Iterative backtracking uses a greedy strategy, but it possibly undoes some decisions
<ul>
<li>An example is the Knuth-Morris-Pratt algorithm for exact string matching</li>
</ul></li>
<li>Backtracking can be used for
<ul>
<li>Finding one feasible solution to a problem (e.g. for the  <img class="inlinemath" src="eqn831.png" WIDTH=42 HEIGHT=14 STYLE="vertical-align: -3px; margin: 0;" alt="n\times n" /> magic square problem)</li><li>Finding one optimal solution to a problem (e.g. for the 0-1 knapsack problem)</li>
<li>Counting all the feasible solutions to a problem (e.g. counting all the solutions to the  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />-queens problem)<ul>
<li>Here I am ony interested in how many solutions there are</li>
</ul></li>
<li>Enumerate all the feasible solutions to a problem (e.g generate all the subsets of size  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> for a set of  <img class="inlinemath" src="eqn832.png" WIDTH=43 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="n \geq k" /> elements)<ul>
<li>Here I am interested in the solutions themselves</li>
</ul></li>
</ul></li>
<li>I can use bactracking to enumerate all the feasible solutions to a problem in the following way
<ul>
<li>I represent a solution with an array of decisions  <img class="inlinemath" src="eqn833.png" WIDTH=52 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...n]" />, where  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> is a decision take from a set  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> of possible choices</li><li>The choices depend on the problem, and not all the choice lead to a feasible solution for the problem (i.e. a choice may lead to a dead end)</li>
<li>At each step  <img class="inlinemath" src="eqn835.png" WIDTH=40 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="i \leq n" /> I consider a partial solution  <img class="inlinemath" src="eqn836.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i]" /></li><li>If  <img class="inlinemath" src="eqn837.png" WIDTH=39 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i=n" /> and  <img class="inlinemath" src="eqn836.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i]" /> is feasible, then I process the solution (print it or whatever)</li><li>If  <img class="inlinemath" src="eqn838.png" WIDTH=39 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i &lt; n" /> and  <img class="inlinemath" src="eqn836.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i]" /> is feasible, I extend it to  <img class="inlinemath" src="eqn839.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i+1]" /> with a new choice, and I recursively check  <img class="inlinemath" src="eqn839.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i+1]" /></li><li>If  <img class="inlinemath" src="eqn836.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i]" /> is NOT feasible I backtrack to the solution  <img class="inlinemath" src="eqn840.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i-1]" /> and I explore a different solution (if any), otherwise I backtrack again from there</li></ul></li>
<li>A generic backtacking enumeration algorithm can look like this
<ul>
<li>The function CHOICES( <img class="inlinemath" src="eqn841.png" WIDTH=62 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S,i,n,..." />) returns a set of possible choices for the decision  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" />, and it must return  <img class="inlinemath" src="eqn842.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\emptyset" /> if  <img class="inlinemath" src="eqn843.png" WIDTH=39 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i &gt; n" /></li></ul></li>
</ul>
<ul>
<li>The following pseudocode enumerates all the  <img class="inlinemath" src="eqn844.png" WIDTH=18 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2^n" /> subset of the set  <img class="inlinemath" src="eqn845.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=\{1,...,n\}" /> <ul>
<li>In this case there is no need to check for the feasibility of a solution, since all the solutions are feasible</li>
<li>The initial call is ALL-SUBSETS( <img class="inlinemath" src="eqn846.png" WIDTH=45 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S,1,n" />)</li><li>I am describing a solution as a boolean vector for which an element is TRUE if the corresponding index is part of the current subset  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" />  <img class="displaymath" src="eqn847.png" WIDTH=320 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" S[i]=TRUE \iff i \in S' \qquad \mbox{for } i = 1,...,n" /></li><li>The worst case time complexity is  <img class="inlinemath" src="eqn848.png" WIDTH=43 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(2^n)" /></li></ul></li>
</ul>
<ul>
<li>The following pseudocode enumerates all the  <img class="inlinemath" src="eqn849.png" WIDTH=17 HEIGHT=23 STYLE="vertical-align: -10px; margin: 0;" alt="n \choose k" /> subsets of  <img class="inlinemath" src="eqn845.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=\{1,...,n\}" /> composed of  <img class="inlinemath" src="eqn576.png" WIDTH=43 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="k \leq n" /> elements<ul>
<li>The variable  <img class="inlinemath" src="eqn094.png" WIDTH=9 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j" /> is used for counting the current number of elements for each subset</li><li> <img class="inlinemath" src="eqn850.png" WIDTH=39 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="k-j" /> is the number of elements that must be added to reach a solution of the desired lenght  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li><li> <img class="inlinemath" src="eqn850.png" WIDTH=39 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="k-j" /> cannot exceed the total number of elements remainin  <img class="inlinemath" src="eqn851.png" WIDTH=197 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n-i+1 = |\{i,i+1,...,n\}|" /> <ul>
<li>This reduces the number of choices by pruning some dead branches</li>
<li>I cannot refuse more elements if then there are not enough elements remaining for completing a set of  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> elements!</li></ul></li>
<li>The worst case time complexity is  <img class="inlinemath" src="eqn848.png" WIDTH=43 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(2^n)" /></li></ul></li>
</ul>
<ul>
<li>The following pseudocode enumerates all the  <img class="inlinemath" src="eqn234.png" WIDTH=15 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="n!" /> permutations of a set  <img class="inlinemath" src="eqn852.png" WIDTH=110 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A=\{a_i,...,a_n\}" /> <ul>
<li>In this case there is no need to define explicitly a set of choices  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /></li><li>The time complexity is  <img class="inlinemath" src="eqn853.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n!)" /></li></ul></li>
</ul>
<h2 id="hard-problems">Hard problems</h2>
<ul>
<li><p>A problem  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is defined as a binary relation on a set  <img class="inlinemath" src="eqn854.png" WIDTH=11 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="I" /> of problem instances and a set  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> of problem solutions</p></li><li><p>A decision problem is a problem in which the set of solutions is  <img class="inlinemath" src="eqn855.png" WIDTH=75 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=\{0,1\}" /></p></li><li><p>A problem is hard or untractable if it cannot be solved in polynomial time, while it is considered easy or tractable if a polynomial time algorithm able to solve it exists</p>
<ul>
<li>History shows that if a polynomial time algorithm is discovered for a problem, it is usually of reasonable degree ( <img class="inlinemath" src="eqn856.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^3)" /> at most)</li><li>Even if only an high degree polynomial algorithm is discovered, then usually other more effcient polynomial algorithms of much lower degree are discovered</li>
</ul></li>
<li><p>A problem is said to be concrete if its input is a set of binary strings</p></li>
<li><p>The input size of a concrete problem is the lenght of its binary input strings</p></li>
<li><p>An abstract problem can be mapped to a concrete problem unsing an encoding</p>
<ul>
<li>The choice of which encoding to use influences the running time, but if I rule out expensive encodings, then the running time is quite independent on the encoding used</li>
</ul></li>
<li><p>A verfier (also called certifier or checker) is an algorithm  <img class="inlinemath" src="eqn857.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="A_{ver}" /> such that, given a problem instance  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> and a candidate solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> for  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" />, returns TRUE if  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is a valid solution for  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" />, FALSE otherwise  <img class="displaymath" src="eqn858.png" WIDTH=325 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt=" A_{ver} = \begin{cases}TRUE &amp; \mbox{if $S$ is feasible for $P$}\\ FALSE &amp; \mbox{otherwise}\end{cases}" /></p><ul>
<li>A candidate solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> for a problem instance  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> is called a certificate or witness for  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /></li><li>A verifier does not solve the problem  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" />, but only chekcs if a given solution is valid</li></ul></li>
<li><p>Let  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> be a decision problem (its answer is either yer or no) such that</p><ul>
<li>An polynomial algorithm  <img class="inlinemath" src="eqn857.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="A_{ver}" /> exists to verify if a candidate solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is feasible for  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> <ul>
<li>The running time of  <img class="inlinemath" src="eqn857.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="A_{ver}" /> is  <img class="inlinemath" src="eqn859.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^k)" /> for some constant  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li></ul></li>
<li>An exponential algorithm  <img class="inlinemath" src="eqn860.png" WIDTH=33 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="A_{exp}" /> exists to find a feasible solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> for  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /> via exhaustive search<ul>
<li>The running time of  <img class="inlinemath" src="eqn860.png" WIDTH=33 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="A_{exp}" /> is  <img class="inlinemath" src="eqn861.png" WIDTH=43 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(k^n)" /> for some constant  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /></li></ul></li>
<li>There is no known polynomial algorithm  <img class="inlinemath" src="eqn862.png" WIDTH=36 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="A_{poly}" /> that can find a feasible solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> for  <img class="inlinemath" src="eqn600.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="P" /></li></ul></li>
<li><p>The open question is: does such an algorith  <img class="inlinemath" src="eqn862.png" WIDTH=36 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="A_{poly}" /> exist, given that a polynomial verification algorithm  <img class="inlinemath" src="eqn857.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="A_{ver}" /> exists?</p><ul>
<li>If the answer is YES, then all the problem for which a polynomial verification algorithm  <img class="inlinemath" src="eqn857.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="A_{ver}" /> is available can be solved in polynomial time</li><li>If the answer is NO, then these problems are intrinsically exponential and hard to solve</li>
</ul></li>
<li><p>The class <strong>P</strong> contains all the problems solvable in polynomial time</p></li>
<li><p>The class <strong>NP</strong> contains all the problems verifiable in polynomial time</p></li>
<li><p>It is obvious that <strong>P</strong> is contained in <strong>NP</strong>, since if I can find a solution to a problem in polynomial time, I don’t need to verify that solution: I can just compute it ex-novo  <img class="displaymath" src="eqn863.png" WIDTH=58 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="\mbox{P} \subseteq \mbox{NP}" /></p></li><li><p>So far, it has not been proven if <strong>P</strong> and <strong>NP</strong> coincide: if all the problems verifiable in polynomial time are also solvable in polynomial time</p></li>
<li><p>There is a million US dollar prize for showing that either  <img class="inlinemath" src="eqn864.png" WIDTH=58 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\mbox{P}=\mbox{NP}" /> or  <img class="inlinemath" src="eqn865.png" WIDTH=58 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\mbox{P} \not= \mbox{NP}" /></p></li><li><p>The most difficult problems in <strong>NP</strong> are called NP-hard problems: they are at least as hard as the hardest problem in NP</p>
<ul>
<li><strong>NP-hard</strong> intersecates with <strong>NP</strong> but it is not a subset of it</li>
<li>Some NP-hard problems are also NP problems, while some NP-hard problems are not NP problems (i.e. they cannot be verified in polynomial time)</li>
</ul></li>
<li><p>A problem which is NP-hard and also belongs to <strong>NP</strong> is called NP-complete</p>
<ul>
<li><strong>NP-complete</strong> is the intersection of <strong>NP</strong> and <strong>NP-hard</strong>  <img class="displaymath" src="eqn866.png" WIDTH=219 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\mbox{NP-complete} = \mbox{NP} \cap \mbox{NP-hard}" /></li></ul></li>
<li><p>If I can find a polynomial-time algorithm for a single NP-hard problem, then since all the NP problems are easier than it (by definition), a polynomial algorithm must exist for all the problems in <strong>NP</strong></p>
<ul>
<li>This would mean that  <img class="inlinemath" src="eqn864.png" WIDTH=58 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\mbox{P}=\mbox{NP}" /></li></ul></li>
<li><p>If no polynomial time algorithm exist for a single NP-hard problem, then no polynomial time algorithm exists for all the NP-hard problems</p>
<ul>
<li>This would mean that  <img class="inlinemath" src="eqn867.png" WIDTH=58 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\mbox{P}\not=\mbox{NP}" /></li><li>This is considered the most likely, albeit sad, scenario</li>
</ul></li>
<li><p>Even though these classes refer to decision problems and not to optimization problems, I can easily reframe an optimization problem into a related decision problem by imposing a threshold on the score of an acceptable solution</p></li>
<li><p>If I want to show that an optimization problem is NP-complete, I can show that the related decision problem is NP-complete</p>
<ul>
<li>The optimization problem can be as hard or harder than its corresponding decision problem</li>
<li>If the decision problem is NP-complete the optimization problem must be hard</li>
</ul></li>
<li><p>I can show that a decision problem  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is not harder than another decision problem  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> by finding an algorith that reduces any instance (i.e. all the inputs) of problem  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> to a corresponding instance of problem  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> such that</p><ul>
<li>The transformation takes polynomial time</li>
<li>The answer to the transformed problem is the same that would have been obtained for the original problem</li>
<li>Such a procedure is called a polynomial time reduction algorithm</li>
</ul></li>
<li><p>Conversely, I can show that a problem  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is not easier than a problem  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> for which its hardness has been proven</p><ul>
<li>If I can reduce  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> to  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />, and  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> has been proven to be hard, then also  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is hard</li><li>This can be proven by contradiction: If  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> was easy, then I can reduce  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> to an easy problem, but  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> has been proven to be hard adn so this is absurd</li></ul></li>
<li><p>A problem  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is NP-complete if it can be show that a polynomial reduction algorithm exists that can reduce  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> to a problem  <img class="inlinemath" src="eqn868.png" WIDTH=127 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="B \in \mbox{NP-complete}" /></p><ul>
<li>We do not know hard NP-complete problems are, but we know that they are all equal since they can be reduced into one another</li>
</ul></li>
<li><p>In order to show that a given problem is NP-complete, we must define a prototype NP-complete problem to which other problems must me reducable in order to show their NP-completeness</p>
<ul>
<li>We will use the circuit satisfiability problem as a prototype NP-complete problem</li>
</ul></li>
<li><p>Any NP problem can be reduced in polynomial time to the boolean circuit satisfiability problem</p>
<ul>
<li>As a consequence, the boolean circuit satisfiability problem is no easier than any problem in NP (and so it is NP-hard!)</li>
<li>Internally in a computer any problem goes trhough a set of logic gates, and so it can be represented by a boolean circuit</li>
</ul></li>
<li><p>The boolean circuit satisfiability problem is verfiable in polynomial time: it is an NP problem</p></li>
<li><p>Since the boolean satisfiability problem is both an NP and an NP-hard problem, it is an NP-complete problem</p></li>
<li><p>I can thus show that a problem is NP-complete by reducing it to the boolean circuit satisfiability problem</p></li>
</ul>
<h3 id="graph-coloring-problem">Graph coloring problem</h3>
<ul>
<li>The graph coloring problem: given an undirected graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> and  <img class="inlinemath" src="eqn869.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k \in \mathbb{N}" />, can I color its nodes with  <img class="inlinemath" src="eqn870.png" WIDTH=47 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="m \leq k" /> colors such that adjacent nodes have different colors?</li><li>This problem can be reframed as the clique problem: given a graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> and  <img class="inlinemath" src="eqn869.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k \in \mathbb{N}" />, is there a subset of nodes  <img class="inlinemath" src="eqn871.png" WIDTH=48 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="S \subseteq V" /> with  <img class="inlinemath" src="eqn872.png" WIDTH=89 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|S| = m \geq k" /> such that there is an edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> among all the possible pairs of nodes  <img class="inlinemath" src="eqn873.png" WIDTH=59 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="u,v \in S" />?<ul>
<li>In other words, is there a clique  <img class="inlinemath" src="eqn874.png" WIDTH=47 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S \in V" /> such that  <img class="inlinemath" src="eqn875.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|S| \geq k" />?</li></ul></li>
<li>If the answer to the clique problem is YES, then the answer to the graph coloring problem is NO, and vice versa
<ul>
<li>If there is a clique of  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> elements in a graph, I need at least  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> colors for coloring it</li><li>If in a graph the maximal clique has  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> elements, then it is possible to color the nodes in the graph with  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> colors</li></ul></li>
</ul>
<h3 id="traveling-salesperson-problem">Traveling salesperson problem</h3>
<ul>
<li>The travelling salesperson problem (TSP): given  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> cities at a certain distance from each other and given  <img class="inlinemath" src="eqn869.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k \in \mathbb{N}" />, is there a tour of lenght  <img class="inlinemath" src="eqn876.png" WIDTH=38 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="l \leq k" /> that visits each city exactly once and returns back to the original city?</li><li>This is equivalent to the hamiltonian cycle problem: given a weighted completely connected graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> is there a circuit  <img class="inlinemath" src="eqn877.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\pi" /> such that each node of the graph is visited exactly once and the last node is connected to the starting node?</li><li>The travelling saleseman problem can be formulated with symmetric or asymmetric distances: either  <img class="inlinemath" src="eqn878.png" WIDTH=123 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(u,v)=w(v,u)" /> or  <img class="inlinemath" src="eqn879.png" WIDTH=123 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(u,v) \not= w(v,u)" /></li></ul>
<h3 id="linear-programming-problem">0-1 linear programming problem</h3>
<ul>
<li>The 0-1 linear programming problem: given an integer matrix  <img class="inlinemath" src="eqn880.png" WIDTH=72 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="A \in \mathbb{Z}^{m \times n}" /> and an integer vector  <img class="inlinemath" src="eqn881.png" WIDTH=51 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="b \in \mathbb{Z}^m" />, is there a binary vector  <img class="inlinemath" src="eqn882.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="x \in \{0,1\}^n" /> such that  <img class="inlinemath" src="eqn883.png" WIDTH=53 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="Ax \leq b" />?</li></ul>
<h3 id="boolean-satisfiability-problem">Boolean satisfiability problem</h3>
<ul>
<li>The boolean satisfiability problem: given a boolean formula  <img class="inlinemath" src="eqn884.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\phi" /> in conjunctive normal form (CNF), is there an assignment of truth values such that  <img class="inlinemath" src="eqn884.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\phi" /> is true?</li><li>A boolean formula is a conjuntive normal form if it is a conjunction of disjunctions of literals, where a literal is a boolean variable or a negated boolean variable  <img class="displaymath" src="eqn885.png" WIDTH=315 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \phi = (\lnot a \lor \lnot b \lor \lnot c) \land (v \lor \lnot c) \land (a \lor \lnot b \lor c)" />  <img class="displaymath" src="eqn886.png" WIDTH=480 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt=" a=b=TRUE, c = FALSE \implies \phi = TRUE \implies \phi \mbox{ is satisfiable}" /></li></ul>
<h3 id="some-search-and-verification-algorithms">Some search and verification algorithms</h3>
<ul>
<li>The following algorithm is a verifier for the clique problem: it takes in input an instace of the clique problem ( <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" />,  <img class="inlinemath" src="eqn869.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k \in \mathbb{N}" />) and a certificate  <img class="inlinemath" src="eqn871.png" WIDTH=48 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="S \subseteq V" /> for it, and checks if  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is indeed a clique of at least  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> nodes for  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /> <ul>
<li>It is a polynomial-time verifier for the clique problem with worst case complexity  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /> with  <img class="inlinemath" src="eqn887.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n = |V|" /></li></ul></li>
</ul>
<ul>
<li>An exhaustive search algorithm for the clique problem explores all the  <img class="inlinemath" src="eqn844.png" WIDTH=18 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2^n" /> possible subsets of nodes in  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /></li><li>A backtracking algorithm can solve it in  <img class="inlinemath" src="eqn848.png" WIDTH=43 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(2^n)" /> by enumerating the  <img class="inlinemath" src="eqn849.png" WIDTH=17 HEIGHT=23 STYLE="vertical-align: -10px; margin: 0;" alt="n \choose k" /> subsets of  <img class="inlinemath" src="eqn394.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="V" /> that have  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> nodes and checking each subset with VERIFY-CLIQUE</li></ul>
<ul>
<li>The following is a polynomial verifier for the travelling salesman problem that runs in  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> time<ul>
<li> <img class="inlinemath" src="eqn694.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="D" /> is the distance matrix and  <img class="inlinemath" src="eqn833.png" WIDTH=52 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...n]" /> is the certificate of the tour  <img class="inlinemath" src="eqn888.png" WIDTH=232 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1] \leadsto S[2] \leadsto ... \leadsto S[n] \leadsto S[1]" /></li></ul></li>
</ul>
<ul>
<li>If  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> is the set of possible cities the possible tours for the TSP are  <img class="inlinemath" src="eqn853.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n!)" /> where  <img class="inlinemath" src="eqn889.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n = |C|" /> , since I need to consider all the possible permutations of the set of cities</li><li>I can use backtracking to solve the TSP problem in  <img class="inlinemath" src="eqn853.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n!)" /> time by enumerating all the possible permutations of  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> and using VERIFY-TSP for each of them</li></ul>
<h3 id="working-with-hard-problems">Working with hard problems</h3>
<ul>
<li>It is not possible to solve exactly an hard problem in polynomial time</li>
<li>To handle NP-hard problems, I need to renounce to something</li>
<li>Generality: I may be able to solve an hard problem in polynomial time for special cases of the problem
<ul>
<li>The graph coloring problem can be solved in polynomial time for  <img class="inlinemath" src="eqn890.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k=2" />, but it is NP-hard for  <img class="inlinemath" src="eqn891.png" WIDTH=41 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="k\geq 3" /></li><li>The linear programming problem can be solved in polynomial time if  <img class="inlinemath" src="eqn892.png" WIDTH=51 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="x \in \mathbb{R}^n" /> is a vector of real numbers instead of an integer vector</li><li>The boolean satisfiability problem can be solved in polynomial time if  <img class="inlinemath" src="eqn884.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\phi" /> is a 2-CNF, but it is NP-hard if it is a 3-CNF<ul>
<li>A 2-CNF has at most 2 literals per clause, a 3-CNF has at most 3 literals per clause</li>
</ul></li>
</ul></li>
<li>Optimality: I may be able to compute a sub-optimal solution in polynomial time
<ul>
<li>In an optimization problem, I can decide to halt when I reach a treshold score  <img class="inlinemath" src="eqn615.png" WIDTH=9 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\epsilon" />, instead of halting at an extremum</li></ul></li>
<li>Efficiency: I can accept to use a super-polynomial algorithm if I am able to prune the search space to a reasonable leavel (e.g. with branch-and-bound algorithms)</li>
<li>Formality: I can design a polynomial time algorithm that I am not able to proove correct, but seems to halt with the right solution (an heuristic algorithm)</li>
</ul>
<h3 id="approximation-algorithms">Approximation algorithms</h3>
<ul>
<li>An approximation algorithm returns a sub-optimal solution  <img class="inlinemath" src="eqn437.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C" /> within a factor  <img class="inlinemath" src="eqn893.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\rho(n)" /> from an optimal solution  <img class="inlinemath" src="eqn774.png" WIDTH=21 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="C^*" />, for an input of size  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />  <img class="displaymath" src="eqn894.png" WIDTH=166 HEIGHT=42 STYLE="vertical-align: -16px; margin: 0;" alt="max\left(\frac{C}{C^*},\frac{C^*}{C}\right) \leq \rho(n)" /> <ul>
<li>Note that this definition applyies to both maximization and minimization problems</li>
</ul></li>
<li>An algorithm that achieves an approzimation ration  <img class="inlinemath" src="eqn893.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\rho(n)" /> is said to be a  <img class="inlinemath" src="eqn893.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\rho(n)" />-approximation algorithm<ul>
<li>An optimal algorithm produces an 1-approximated solution</li>
</ul></li>
<li>The  <img class="inlinemath" src="eqn895.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Delta" />-TSP problem is a variant of the travelling saleseperson problem enforcing triangle inequalities</li><li>Given  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> cities and their distances in a matrix  <img class="inlinemath" src="eqn694.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="D" />, where  <img class="inlinemath" src="eqn896.png" WIDTH=189 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="D(i,j) \leq D(i,k)+D(k,j)" /> for all  <img class="inlinemath" src="eqn897.png" WIDTH=120 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="i,j,k \in \{1,...,n\}" />, find a minimum-lenght tour  <img class="inlinemath" src="eqn898.png" WIDTH=7 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="l" /> that visits each city exactly once and ends in the first city</li><li>The optimization version of  <img class="inlinemath" src="eqn899.png" WIDTH=72 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\Delta-TSP" /> is NP-hard, and also the decision version of this problem (find a  <img class="inlinemath" src="eqn900.png" WIDTH=66 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="l : |l| \leq k" /> for some bound  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> on the tour lenght) is NP-hard</li><li>However, the  <img class="inlinemath" src="eqn895.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Delta" />-TSP admits approximation algorithms (not all the NP-hard problems do)</li><li>An optimal  <img class="inlinemath" src="eqn899.png" WIDTH=72 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\Delta-TSP" /> tour is a Hamiltonian circuit with minimum weight</li><li>I can get an approximate Hamiltonian circuit for  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /> by finding a minimum spanning tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> for  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /> and returning a list  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> of the nodes corresponding to a pre-order traversal of  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> <ul>
<li>By removing any single edge from a Hamiltonian circuit  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> for a graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" />, I get a spanning tree  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" /> for  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /> <ul>
<li>This spanning tree is not necessarily a minimum spanning tree</li>
</ul></li>
<li>The cost of the spanning tree  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" /> obtained from  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> is necessarily lower than the cost of  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> itself, since it is obtained by removing a non-negative edgefrom it  <img class="displaymath" src="eqn902.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" c(T') \leq c(H)" /></li><li>A minimum spanning tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> for  <img class="inlinemath" src="eqn402.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G" /> cannot cost more than any other spanning tree  <img class="inlinemath" src="eqn354.png" WIDTH=18 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="T'" />, included the one obtained from an optimal Hamiltonian circuit  <img class="inlinemath" src="eqn903.png" WIDTH=23 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H^*" />  <img class="displaymath" src="eqn904.png" WIDTH=90 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" c(T) \leq c(T')" /></li><li>Thus, by combining the 2 inequalities I get that the cost of a MST  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is necessarily lower than the cost of an optimal Hamiltonian circuit  <img class="inlinemath" src="eqn903.png" WIDTH=23 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H^*" />  <img class="displaymath" src="eqn905.png" WIDTH=96 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" c(T) \leq c(H^*)" /></li><li>When I perform a full tree walk  <img class="inlinemath" src="eqn450.png" WIDTH=20 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="W" /> on  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" />, the same nodes are returned multiple times with a path that crosses all the edges in  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> exactly twice</li><li>Thus, the cost of the walk is exactly twice the cost of the MST  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" />  <img class="displaymath" src="eqn906.png" WIDTH=100 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="c(W)=2c(T)" />  <img class="displaymath" src="eqn907.png" WIDTH=110 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="c(W)\leq 2c(H^*)" /></li><li>Thanks to the triangle inequality, I can remove any repeated node by knowing that I am not increasing the lenght of the tour</li>
<li>The maximal length of a tour  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> returned by the approximated algorithm is thus at most twice the lenght of an optimal tour  <img class="displaymath" src="eqn908.png" WIDTH=111 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" c(H)= \leq c(H^*)" /></li><li>This is thus a 2-approximated algorithm</li>
</ul></li>
<li>The total time cost of the approximate Hamiltonian circuit is  <img class="inlinemath" src="eqn909.png" WIDTH=79 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2 \log n)" /> <ul>
<li>The cost of finding an MST using Kruskal’s algorithm is  <img class="inlinemath" src="eqn584.png" WIDTH=77 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \log n)" /></li><li>The cost of visiting  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> in pre-order is  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" />  <img class="displaymath" src="eqn910.png" WIDTH=458 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt=" O(m \log n)+O(n)=O(n + m \log n)=O(m \log n) = O(n^2 \log n)" /></li></ul></li>
<li>There are also much better practical approximations for the  <img class="inlinemath" src="eqn895.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Delta" />-TSP problem</li><li>If  <img class="inlinemath" src="eqn865.png" WIDTH=58 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\mbox{P} \not= \mbox{NP}" /> there is NO constant-approximation algorithm for the general TSP problem without triangle inequalities</li><li>For many other problems finding an approximate solution within a constant factor from the optimal solution is itself an NP-hard problem!</li>
</ul>
<h3 id="branch-and-bound">Branch and bound</h3>
<ul>
<li>Branch-and-bound is a more efficient enumeration approach based on avoiding decisions that cannot lead to an optimal solution</li>
<li>It was developped by Alisa Land and Alison Dong in 1960</li>
<li>Let’s assume a minimizazion problem with cost function  <img class="inlinemath" src="eqn911.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\phi(x)" /> <ul>
<li>This is not a restrictive condition since I can apply the same reasoning for maximization problems  <img class="displaymath" src="eqn912.png" WIDTH=185 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" min(\phi(x)) = max(-\phi(x))" /></li></ul></li>
<li>I define a function  <img class="inlinemath" src="eqn913.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="lb(S,i)" /> that gives a lower bound on the cost of every possible solution in  <img class="inlinemath" src="eqn914.png" WIDTH=54 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S'[1...j]" /> with  <img class="inlinemath" src="eqn915.png" WIDTH=37 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="j \geq i" /> obtainable by extending the solutionm  <img class="inlinemath" src="eqn836.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i]" /> with new decisions  <img class="displaymath" src="eqn916.png" WIDTH=257 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" lb(S,i) \leq \phi(S') \qquad \forall \ S'[1...j] \ , j \geq i" /></li><li>I denote with  <img class="inlinemath" src="eqn597.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S^*" /> the best known solution at any given node of the search tree, and with  <img class="inlinemath" src="eqn917.png" WIDTH=78 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="z^*=\phi(S^*)" /> its cost</li><li>If at any given node the lower bound is higher than  <img class="inlinemath" src="eqn918.png" WIDTH=16 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="z^*" />, I avoid exploring the subtree rooted in that node<ul>
<li>This action is called pruning the search tree</li>
</ul></li>
<li>I assume that the number of choices at step  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" />  <img class="inlinemath" src="eqn919.png" WIDTH=18 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="C_i" /> is bounded by some constant  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> such that  <img class="inlinemath" src="eqn920.png" WIDTH=64 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|C_i| \leq m" /> for  <img class="inlinemath" src="eqn921.png" WIDTH=76 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i=1,...,n" /></li><li>I assume that computing  <img class="inlinemath" src="eqn913.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="lb(S,i)" /> costs  <img class="inlinemath" src="eqn922.png" WIDTH=59 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(f(n))" /> where  <img class="inlinemath" src="eqn103.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n)" /> is some function  <img class="inlinemath" src="eqn923.png" WIDTH=52 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\mathbb{N} \to \mathbb{N}" /></li><li>With these assumptions, the worst-case time complexity of branch-and-bound is still exponential
<ul>
<li>At each step  <img class="inlinemath" src="eqn924.png" WIDTH=90 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="i \in \{1,...,n\}" /> I can take  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> choices, each costing  <img class="inlinemath" src="eqn103.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n)" /></li><li>The total cost is thus  <img class="inlinemath" src="eqn925.png" WIDTH=81 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m^n f(n))" /></li></ul></li>
<li>The actual running time of branch-and-bound depends on a set of conditions
<ul>
<li>The initial solution adopted, that can be random or come from an heuristic algorithm</li>
<li>The branching factor of the search tree (this is  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" />)</li><li>How costly it is to compute  <img class="inlinemath" src="eqn913.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="lb(S,i)" /> and how tight its bound is (this is  <img class="inlinemath" src="eqn103.png" WIDTH=33 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="f(n)" /> and the tightness of the bound influences how much of the tree I can avoid exploring)</li><li>The order in which the search tree is visited (pre-order, by levels, by some priority key,…)</li>
</ul></li>
</ul>
<ul>
<li>I can use the branch-and-bound approach for the TSP</li>
<li>I have  <img class="inlinemath" src="eqn926.png" WIDTH=96 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n = \{1,...,n\}" /> cities and their distance matrix  <img class="inlinemath" src="eqn927.png" WIDTH=72 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="D \in \mathbb{R}^{n \times n}" /></li><li>At step  <img class="inlinemath" src="eqn928.png" WIDTH=76 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i = 1,...,n" /> I have visited  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> cities  <img class="inlinemath" src="eqn929.png" WIDTH=63 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1,...,i]" /> and I need to decide which one to visit next,  <img class="inlinemath" src="eqn930.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i+1]" /></li><li>In order to compute a lower bound  <img class="inlinemath" src="eqn913.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="lb(S,i)" /> for the TSP I need to consider some parameters<ul>
<li>The cost  <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" /> for reaching  <img class="inlinemath" src="eqn931.png" WIDTH=29 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1]" /> for any city not yet visited  <img class="inlinemath" src="eqn932.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="j \not\in S" /></li><li>The cost  <img class="inlinemath" src="eqn933.png" WIDTH=12 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="\beta" /> for leaving  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> for reaching any city  <img class="inlinemath" src="eqn934.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="j \not \in S" /></li><li>The cost  <img class="inlinemath" src="eqn935.png" WIDTH=11 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="\gamma" /> of the travel  <img class="inlinemath" src="eqn836.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i]" /> up to the current state</li><li>The cost  <img class="inlinemath" src="eqn936.png" WIDTH=14 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\delta_j" /> for visiting each city  <img class="inlinemath" src="eqn934.png" WIDTH=41 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="j \not \in S" /></li></ul></li>
<li>The above parameters can be computed for  <img class="inlinemath" src="eqn836.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i]" /> as follows  <img class="displaymath" src="eqn937.png" WIDTH=192 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\alpha = min\{D(j,S[1])|j \not\in S\}" />  <img class="displaymath" src="eqn938.png" WIDTH=190 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\beta = min\{D(S[i],j)|j \not\in S\}" />  <img class="displaymath" src="eqn939.png" WIDTH=331 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="\gamma = \begin{cases} 0 &amp; \mbox{if }i=1\\ \sum_{j=1}^{i-1} D(S[j],S[j+1]]) &amp; \mbox{otherwise}\end{cases}" />  <img class="displaymath" src="eqn940.png" WIDTH=348 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt="\delta_j = min_{p,q}\{D(p,j)+D(j,q)|j\not=p\not=q\} \ \forall \ j \not\in S" /></li><li>Now I can compute the lower bound  <img class="inlinemath" src="eqn913.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="lb(S,i)" /> as  <img class="displaymath" src="eqn941.png" WIDTH=317 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt="lb(S,i)=\begin{cases}\gamma+D(S[n],S[1]) &amp; \mbox{if } i=n \\ \gamma+\lceil \frac{\alpha+\beta+\sum_{j\not\in S}d_j}{2} \rceil &amp; \mbox{if } i &lt; n\end{cases}" /></li><li>The worst-case time complexity of  <img class="inlinemath" src="eqn913.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="lb(S,i)" /> is  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" />, since for calculating  <img class="inlinemath" src="eqn936.png" WIDTH=14 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\delta_j" /> I need to evaluate all the possible pairs of node with one of them not in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li></ul>
<h3 id="heuristic-algorithms">Heuristic algorithms</h3>
<ul>
<li>For some hard problems, it is too expensive to find an optimal solution, and an approximation algorithm does not exist</li>
<li>In these cases, it is possible to develop a heuristic procedure to search for feasible solutions</li>
<li>An heuristic algorithm cannot guarantee that an optimal solution, or even sub-optimal solution under a certain bound, will be found
<ul>
<li>Nonetheless, the solutions obtained may be useful in practice</li>
</ul></li>
<li>Heuristic algorithms follow 2 main approaches
<ul>
<li>Greedy approaches applied when the greedy choice property is NOT repsected</li>
<li>Local search approaches that restrict the search space to a neighbotrhood of a given solution</li>
</ul></li>
<li>It is possible to devise a greedy heuristic for the TSP
<ul>
<li>Let  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> be a complete graph of cities,  <img class="inlinemath" src="eqn942.png" WIDTH=43 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=\emptyset" /></li><li>Sort  <img class="inlinemath" src="eqn943.png" WIDTH=33 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="G.E" /> according to their weight</li><li>For each sorted edge  <img class="inlinemath" src="eqn944.png" WIDTH=91 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v) \in G.E" />, starting from the one with lowest weight, if both  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and  <img class="inlinemath" src="eqn317.png" WIDTH=10 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="v" /> are not saturated in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> (they have a degree  <img class="inlinemath" src="eqn945.png" WIDTH=32 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="&lt; 2" />), add the edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> to the solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li><li>Finally, add to the solution  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> the edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> that closes the tour</li><li>An implementation of this heursitic using disjoint-sets with path compression and union-by-rank costs  <img class="inlinemath" src="eqn909.png" WIDTH=79 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2 \log n)" /> with  <img class="inlinemath" src="eqn751.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|V|" /></li></ul></li>
</ul>
<ul>
<li>The following is instead a local search procedure for the TSP
<ul>
<li>Let  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> be a Hamiltonian circuit for the graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /></li><li>I define its neighborhood  <img class="inlinemath" src="eqn946.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N_2(H)" /> as the circuit  <img class="inlinemath" src="eqn947.png" WIDTH=21 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="H'" /> obtained from  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> by replacing 2 non-consecutive edges  <img class="inlinemath" src="eqn948.png" WIDTH=73 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="e_1, e_2 \in H" /> with the edges  <img class="inlinemath" src="eqn949.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="e_1', e_2' \not\in H" /> such that  <img class="inlinemath" src="eqn950.png" WIDTH=96 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\{e_1,e_2,e_1',e_2'\}" /> is an Hamiltonian circuit</li><li>We see that  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> has  <img class="inlinemath" src="eqn751.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|V|" /> edges and  <img class="inlinemath" src="eqn951.png" WIDTH=152 HEIGHT=26 STYLE="vertical-align: -7px; margin: 0;" alt="|N_2(H)|=\frac{n(n-1)}{2}-n" /> neighbors<ul>
<li>Since we are in a circuit,  <img class="inlinemath" src="eqn952.png" WIDTH=99 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|V|=|E|" /></li><li>The number of neighbors is the number of possible pairs of edges in  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /> ( <img class="inlinemath" src="eqn953.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n(n-1)/2" />) minus the number of consecutive pairs of edges  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /></li></ul></li>
<li>Computing  <img class="inlinemath" src="eqn946.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N_2(H)" /> costs  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /> for a given  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /></li><li>I can have an exponential number of local search iterations  <img class="inlinemath" src="eqn946.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N_2(H)" />,  <img class="inlinemath" src="eqn954.png" WIDTH=52 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N_2(H')" />,…</li><li>I can generalize  <img class="inlinemath" src="eqn946.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N_2(H)" /> to  <img class="inlinemath" src="eqn955.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N_k(H)" />, where I replace an arbitrary number  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> of edges to form the neighborhood of  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" /></li><li>I am sure to reach a global optimum only when I analyse all the possible neighborhoods of  <img class="inlinemath" src="eqn901.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="H" />  <img class="inlinemath" src="eqn956.png" WIDTH=89 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\cup_{k=2}^n N_k(H)" /> <ul>
<li>In this way I am effectively performing an exhaustive search!</li>
</ul></li>
<li>Experimentally, it can be observed that  <img class="inlinemath" src="eqn957.png" WIDTH=108 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="N_2(h) \cup N_3(H)" /> gives good results, and it has a search space of magnitude  <img class="inlinemath" src="eqn856.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^3)" /></li></ul></li>
</ul>
<h2 id="sequence-comparison-and-assembly">Sequence comparison and assembly</h2>
<h3 id="global-alignment">Global alignment</h3>
<ul>
<li>The global alignment problem: given the sequences  <img class="inlinemath" src="eqn958.png" WIDTH=123 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X = \langle X_1, ..., X_m \rangle" /> and  <img class="inlinemath" src="eqn959.png" WIDTH=110 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Y = \langle Y_1,...,Y_n \rangle" /> over the alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" />, return the alignment between  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> with maximum score</li><li>Typically,  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> have similar lenght ( <img class="inlinemath" src="eqn960.png" WIDTH=48 HEIGHT=12 STYLE="vertical-align: -1px; margin: 0;" alt="m \approx n" />) and they consist of thousand of elements</li><li>An alignment  <img class="inlinemath" src="eqn961.png" WIDTH=45 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="X',Y'" /> is an insertion of spaces _ in arbitrary positions of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> so that the resulting sequences  <img class="inlinemath" src="eqn962.png" WIDTH=21 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="X'" /> and  <img class="inlinemath" src="eqn963.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="Y'" /> <ul>
<li>Have the same lenght  <img class="displaymath" src="eqn964.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" k = |X'| = |Y'|" /></li><li>Don’t have matching spaces  <img class="displaymath" src="eqn965.png" WIDTH=324 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" X'[i] = Y'[i] \implies X'[i] \not=\_ \qquad \mbox{for } i = 1,...,k" /></li></ul></li>
<li>The pair score  <img class="inlinemath" src="eqn966.png" WIDTH=49 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\sigma(x,y)" /> for the characters  <img class="inlinemath" src="eqn967.png" WIDTH=59 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="x,y \in \Sigma" /> is defined as  <img class="displaymath" src="eqn968.png" WIDTH=338 HEIGHT=73 STYLE="vertical-align: -32px; margin: 0;" alt=" \sigma(x,y) = \begin{cases}+1 &amp; \mbox{if }x=y\not=\_ \\              -1 &amp; \mbox{if }x\not=y \land x \not= \_ \land y \not= \_ \\
              -2 &amp; \mbox{if } x \not=y \land (x=\_ \lor y=\_)
\end{cases}" /></li><li>The overall alignment score is  <img class="displaymath" src="eqn969.png" WIDTH=125 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" \sum_{i=1}^k \sigma(X'[i],Y'[i])" /></li><li>The global alignment problem has optimal substructure</li>
<li>I can use a dynamic programming matrix  <img class="inlinemath" src="eqn970.png" WIDTH=120 HEIGHT=19 STYLE="vertical-align: -1px; margin: 0;" alt="A \in \mathbb{Z}^{(m+1) \times (n+1)}" /> such that  <img class="inlinemath" src="eqn971.png" WIDTH=46 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,j)" /> is the score of the best alignment for the prefixes  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" /> and  <img class="inlinemath" src="eqn973.png" WIDTH=21 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="X_j" /> <ul>
<li>This score is also called similarity of  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" /> and  <img class="inlinemath" src="eqn973.png" WIDTH=21 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="X_j" /></li></ul></li>
<li>The matrix  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is initialized with initial gaps  <img class="displaymath" src="eqn974.png" WIDTH=205 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,0)= -2i \ \mbox{for } i= 1,...,m" />  <img class="displaymath" src="eqn975.png" WIDTH=206 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(0,j)= -2j \ \mbox{for } j= 1,...,n" /> <ul>
<li>I am aligning  <img class="inlinemath" src="eqn976.png" WIDTH=51 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_0=\epsilon" /> to  <img class="inlinemath" src="eqn977.png" WIDTH=17 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="Y_j" /> and vice-versa  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" /> to  <img class="inlinemath" src="eqn978.png" WIDTH=47 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Y_0=\epsilon" /></li></ul></li>
<li>I define the match score  <img class="inlinemath" src="eqn979.png" WIDTH=23 HEIGHT=14 STYLE="vertical-align: -5px; margin: 0;" alt="p_{i,j}" /> as  <img class="displaymath" src="eqn980.png" WIDTH=198 HEIGHT=53 STYLE="vertical-align: -22px; margin: 0;" alt=" p_{i,j} = \begin{cases}+1 &amp; \mbox{if } x_i=y_j\\ -1 &amp; \mbox{if } x_i \not= y_j \end{cases}" /></li><li>The dynamic programming recurrence relation for the position  <img class="inlinemath" src="eqn971.png" WIDTH=46 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,j)" /> is  <img class="displaymath" src="eqn981.png" WIDTH=480 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,j) = max\{A(i,j-1)-2,A(i-1,j)-2,A(i-1,j-1)+p_{i,j}\}" /></li><li>After filling table  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />, the best score for the alignment of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> can be retrieved from the last cell in the matrix  <img class="displaymath" src="eqn982.png" WIDTH=128 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BEST=A(m,n)" /></li><li>I can also build a bactrack matrix  <img class="inlinemath" src="eqn983.png" WIDTH=234 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B \in \{MATCH,UP,LEFT\}^{m\times n}" /> to obtain the alignments themselves</li></ul>
<h3 id="local-alignment">Local alignment</h3>
<ul>
<li>The local alignment problem: given the sequences  <img class="inlinemath" src="eqn958.png" WIDTH=123 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X = \langle X_1, ..., X_m \rangle" /> and  <img class="inlinemath" src="eqn959.png" WIDTH=110 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Y = \langle Y_1,...,Y_n \rangle" /> over the alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" />, return the alignment between a substring  <img class="inlinemath" src="eqn984.png" WIDTH=17 HEIGHT=19 STYLE="vertical-align: -1px; margin: 0;" alt="\tilde{X}" /> of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and a substring  <img class="inlinemath" src="eqn985.png" WIDTH=15 HEIGHT=19 STYLE="vertical-align: -1px; margin: 0;" alt="\tilde{Y}" /> of  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> with maximum score</li><li>As for the global alignment problem, I create a dynamic programming matrix  <img class="inlinemath" src="eqn970.png" WIDTH=120 HEIGHT=19 STYLE="vertical-align: -1px; margin: 0;" alt="A \in \mathbb{Z}^{(m+1) \times (n+1)}" /> such that  <img class="inlinemath" src="eqn971.png" WIDTH=46 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,j)" /> is the score of the best alignment for suffixes of prefixes  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" /> and  <img class="inlinemath" src="eqn973.png" WIDTH=21 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="X_j" /></li><li>The matrix  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is initialized with initial gaps  <img class="displaymath" src="eqn986.png" WIDTH=186 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,0)= 0 \ \mbox{for } i= 1,...,m" />  <img class="displaymath" src="eqn987.png" WIDTH=186 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(0,j)= 0 \ \mbox{for } j= 1,...,n" /></li><li>The dynamic programming recurrence relation for the position  <img class="inlinemath" src="eqn971.png" WIDTH=46 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,j)" /> is  <img class="displaymath" src="eqn988.png" WIDTH=495 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,j) = max\{A(i,j-1)-2,A(i-1,j)-2,A(i-1,j-1)+p_{i,j},0\}" /></li><li>After filling table  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />, the best score for the alignment of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> can be retrieved from the highest cell in the whole matrix  <img class="displaymath" src="eqn989.png" WIDTH=175 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt="BEST=max_{i,j}(A(i,j))" /></li><li>I can build a bactrack matrix  <img class="inlinemath" src="eqn990.png" WIDTH=282 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="B \in \{MATCH,UP,LEFT,END\}^{m\times n}" /> to obtain the alignments themselves</li></ul>
<h3 id="semiglobal-alignment">Semiglobal alignment</h3>
<ul>
<li>The semiglobal alignment problem is similar to the global alignment problem, but it ingnores the spaces at the beginning and end of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /></li><li>The inizialization of  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" /> is done as follows  <img class="displaymath" src="eqn986.png" WIDTH=186 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,0)= 0 \ \mbox{for } i= 1,...,m" />  <img class="displaymath" src="eqn987.png" WIDTH=186 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(0,j)= 0 \ \mbox{for } j= 1,...,n" /></li><li>Its recurrence equation is identical to that of the global alignment  <img class="displaymath" src="eqn981.png" WIDTH=480 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="A(i,j) = max\{A(i,j-1)-2,A(i-1,j)-2,A(i-1,j-1)+p_{i,j}\}" /></li><li>After filling table  <img class="inlinemath" src="eqn021.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="A" />, the best score for the alignment of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> can be retrieved from the highest value of the last row and column  <img class="displaymath" src="eqn991.png" WIDTH=432 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BEST = max(\{A(i,n)|i=1,...,m\}\cup\{A(m,j)|j=1,...,n\})" /></li></ul>
<h3 id="multiple-alignment">Multiple alignment</h3>
<ul>
<li>The multiple sequence alignment problem: given  <img class="inlinemath" src="eqn992.png" WIDTH=46 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="m &gt;1" /> sequences  <img class="inlinemath" src="eqn993.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_1,...,X_m" /> having about the same length, return the best alignment among all of them</li><li>Spaces are inserted at arbitrary locations of the sequences so to make all the sequences of the same length  <img class="inlinemath" src="eqn994.png" WIDTH=192 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n \geq max\{|X_i||i=1,...,m\}" /></li><li>Multiple sequence alignment is a generalization of the global alignment problem (where  <img class="inlinemath" src="eqn995.png" WIDTH=46 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="m=2" />)</li><li>A multiple sequence alignment is evaluated with a multiple scoring function that must be
<ul>
<li>Independent to the order of the arguments (it should be commutative)</li>
<li>It should reward strongly related fragments</li>
<li>It should penalize spaces and unrelated sequences</li>
</ul></li>
<li>The sum-of-pairs ( <img class="inlinemath" src="eqn996.png" WIDTH=26 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="SP" />) scoring function is a possible solution consisting in summing the pair scores of all the pairs of symbols in a column of the multiple sequence alignment  <img class="displaymath" src="eqn997.png" WIDTH=583 HEIGHT=44 STYLE="vertical-align: -24px; margin: 0;" alt="SP(S) = \sum_{(x,y) \in S \times S} \sigma(x,y)/2 \qquad S=\{S_1,...,S_m\} \mbox{ is the set of symbols in a column} " /> <ul>
<li>I am dividing by 2 since for each pair  <img class="inlinemath" src="eqn998.png" WIDTH=90 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="x,y \in S \times S" /> there is also an equal pair  <img class="inlinemath" src="eqn999.png" WIDTH=27 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="y,x" />, and I want to consider its score only once!</li></ul></li>
<li>Finding the best multiple sequence alignment score using the SP score is an NP-hard problem!
<ul>
<li>I need to score  <img class="inlinemath" src="eqo000.png" WIDTH=47 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(m^2)" /> pairs of symbols for each of the  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> positions in the alignment</li><li>Just scoring a given alignment with the SP score has a  <img class="inlinemath" src="eqo001.png" WIDTH=57 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(m^2n)" /> running time</li><li>If I use dynamic programming I need to calculate  <img class="inlinemath" src="eqo002.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^m)" /> cells in the matrix to find the optimal alignment</li><li>Each cell requires calculating an SP score for a position plus a constant amount of work for determining which direction to adopt</li>
<li>Calculating the SP score for the position is an  <img class="inlinemath" src="eqo000.png" WIDTH=47 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(m^2)" /> problem</li><li>Finding an optimal alignment is a superexponential  <img class="inlinemath" src="eqo003.png" WIDTH=136 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^mm^2)=O(n^m)" /> problem</li></ul></li>
</ul>
<h3 id="star-alignment-heuristic">Star alignment heuristic</h3>
<ul>
<li>I can use the start alignment heuristic for calclulationg multiple sequence alignments</li>
<li>Given the sequences  <img class="inlinemath" src="eqn993.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_1,...,X_m" />, I first select a sequence  <img class="inlinemath" src="eqo004.png" WIDTH=21 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_c" /> with  <img class="inlinemath" src="eqo005.png" WIDTH=96 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="c \in \{1,...,m\}" />, which represents the center of the star</li><li>I find then the  <img class="inlinemath" src="eqo006.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="m-1" /> optimal global alignments between  <img class="inlinemath" src="eqo004.png" WIDTH=21 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_c" /> and  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" /> with  <img class="inlinemath" src="eqo007.png" WIDTH=138 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="i \in \{1,...,m\}-\{c\}" /></li><li>To select the star center  <img class="inlinemath" src="eqo004.png" WIDTH=21 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_c" /> I can compute the  <img class="inlinemath" src="eqo000.png" WIDTH=47 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(m^2)" /> possible pairwise alignments and choose as  <img class="inlinemath" src="eqo004.png" WIDTH=21 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_c" /> the sequence that maximizes the sum of scores between itself and any of the other sequences  <img class="displaymath" src="eqo008.png" WIDTH=383 HEIGHT=44 STYLE="vertical-align: -24px; margin: 0;" alt=" X_c = argmax_{X_c} \{\sum_{i \in \{1,...,m\}-\{c\}} \sigma(X_c,X_i) | c \in  \{1,...,m\} \}" /> <ul>
<li>The time complexity of this approach is  <img class="inlinemath" src="eqo009.png" WIDTH=64 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(m^2n^2)" /> where  <img class="inlinemath" src="eqo010.png" WIDTH=192 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n = max\{|X_i| | i = 1,...,m\}" /></li><li>I am computinf  <img class="inlinemath" src="eqo000.png" WIDTH=47 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(m^2)" /> global alignments which cost  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /> each</li></ul></li>
<li>After I have selected a star center  <img class="inlinemath" src="eqo004.png" WIDTH=21 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_c" />, I align all the  <img class="inlinemath" src="eqo011.png" WIDTH=61 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="X_i \not=X_c" /> to it with a global alignment<ul>
<li>Once gaps are introduced in  <img class="inlinemath" src="eqo004.png" WIDTH=21 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_c" />, they are never removed for avoiding altering other alignments</li></ul></li>
<li>After having performed all the alignments, I add padding gaps to the aligned sequences to bring all of them to the same length</li>
<li>There is no guarantee of optimality for the star alignment heuristic, but in practice I tend to get good sub-optimal results</li>
</ul>
<h3 id="similarity">Similarity</h3>
<ul>
<li>Similarity is a metric based on sequence alignments</li>
<li>An alignment  <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" /> between 2 sequences  <img class="inlinemath" src="eqn664.png" WIDTH=36 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X,Y" /> over some alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /> is a pair  <img class="inlinemath" src="eqo012.png" WIDTH=57 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(X',Y')" /> such that  <img class="inlinemath" src="eqo013.png" WIDTH=77 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|X'|=|Y'|" />,  <img class="inlinemath" src="eqn962.png" WIDTH=21 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="X'" /> and  <img class="inlinemath" src="eqn963.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="Y'" /> are obtained by optionally adding  <img class="inlinemath" src="eqo014.png" WIDTH=9 HEIGHT=5 STYLE="vertical-align: -1px; margin: 0;" alt="\_" /> in  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and/or  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />, and if  <img class="inlinemath" src="eqo015.png" WIDTH=298 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X'[i]=Y'[i] \implies X'[i] \not= \_ \ \mbox{for } i=1,...,k" /> <ul>
<li>We say that the symbols  <img class="inlinemath" src="eqo016.png" WIDTH=34 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X'[i]" /> and  <img class="inlinemath" src="eqo017.png" WIDTH=32 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Y'[i]" /> are aligned under  <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" /></li></ul></li>
<li>A scoring system is a pair  <img class="inlinemath" src="eqo018.png" WIDTH=38 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(p,g)" /> such that<ul>
<li> <img class="inlinemath" src="eqo019.png" WIDTH=106 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="p: \Sigma \times \Sigma \to \mathbb{R}" /> is a function from all the pairs of symbols in an alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /> to the real numbers such that for each pair of aligned symbols it returns a score</li><li> <img class="inlinemath" src="eqo020.png" WIDTH=43 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="g \in \mathbb{R}" /> is a (usually negative) constant used for penalizing a gap</li></ul></li>
<li>The total score of an alignment  <img class="inlinemath" src="eqn297.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="\alpha" />, denoted  <img class="inlinemath" src="eqo021.png" WIDTH=62 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="score(\alpha)" />, os the sum of all the scores for each pair of aligned residues  <img class="displaymath" src="eqo022.png" WIDTH=203 HEIGHT=48 STYLE="vertical-align: -20px; margin: 0;" alt=" score(\alpha) = \sum_{i=1}^n p(X'[i],Y'[i])" /></li><li>The similarity  <img class="inlinemath" src="eqo023.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="sum(X,Y)" /> among 2 sequences  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> is the maximum score achievable among all the possible alignments of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />  <img class="displaymath" src="eqo024.png" WIDTH=717 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="sim(X,Y) = max\{score(\alpha)|\alpha \in \mathbb{A}_{X,Y}\} \qquad \mathbb{A}_{X,Y} \mbox{ is the set of all the possible alignments of $X$ and $Y$}" /></li><li> <img class="inlinemath" src="eqo025.png" WIDTH=37 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\mathbb{A}_{X,Y}" /> has finite dimentions but it is far too big to be enumerated in practice</li></ul>
<h3 id="distance">Distance</h3>
<ul>
<li>A distance  <img class="inlinemath" src="eqn247.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="d" /> over a set  <img class="inlinemath" src="eqn024.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="E" /> is a function  <img class="inlinemath" src="eqo026.png" WIDTH=109 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="d: E \times E \to \mathbb{R}" /> such that  <img class="displaymath" src="eqo027.png" WIDTH=142 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d(x,x) = 0 \ \forall \ x \in E" />  <img class="displaymath" src="eqo028.png" WIDTH=138 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d(x,y) &gt; 0 \ \forall \ x\not=y" />  <img class="displaymath" src="eqo029.png" WIDTH=195 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d(x,y) = d(y,x) \ \forall \ x,y \in E" />  <img class="displaymath" src="eqo030.png" WIDTH=276 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="d(x,y) \leq d(x,z)+d(z,y) \ \forall \ x,y,z \in E" /></li><li>The Manhattan distance over  <img class="inlinemath" src="eqo031.png" WIDTH=81 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="E = \mathbb{R} \times \mathbb{R}" /> is defined as  <img class="displaymath" src="eqo032.png" WIDTH=256 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" d((x,y),(x',y')) = |x-x'|+|y-y'|" /></li><li>The Euclidean distance over  <img class="inlinemath" src="eqo031.png" WIDTH=81 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="E = \mathbb{R} \times \mathbb{R}" /> is defined as  <img class="displaymath" src="eqo033.png" WIDTH=295 HEIGHT=23 STYLE="vertical-align: -5px; margin: 0;" alt=" d((x,y),(x',y')) = \sqrt{(x-x')^2+(y-y')^2}" /></li><li>It is possible to define also a distance over strings, where  <img class="inlinemath" src="eqo034.png" WIDTH=54 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="E = \Sigma^*" /></li><li>The edit distance  <img class="inlinemath" src="eqo035.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="dist(X,Y)" /> is the minimum number of edit operations needed to transfrom a string  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> into a string  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> <ul>
<li>Edit operations are substitutions, insertions and deletions of symbols</li>
</ul></li>
<li>I can assign a cost to each edit operation: a cost measure is a pair  <img class="inlinemath" src="eqo036.png" WIDTH=37 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(c,h)" /> where  <img class="inlinemath" src="eqo037.png" WIDTH=105 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="c : \Sigma \times \Sigma \to \mathbb{R}" /> is a distance over each possible pair of symbols in the alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /> and  <img class="inlinemath" src="eqo038.png" WIDTH=42 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="h &gt; 0" /> is the cost of inserting or deleting a symbol</li><li>If I have  <img class="inlinemath" src="eqo039.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k &gt; 0" /> edit operations  <img class="inlinemath" src="eqo040.png" WIDTH=106 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O = \langle o_1,...,o_k \rangle" /> the total cost  <img class="inlinemath" src="eqo041.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="cost(O)" /> is the sum of all the individual costs  <img class="inlinemath" src="eqo042.png" WIDTH=52 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="o_1,...o_k" />  <img class="displaymath" src="eqo043.png" WIDTH=116 HEIGHT=51 STYLE="vertical-align: -20px; margin: 0;" alt=" cost(O) = \sum_{i=1}^k o_i" /></li><li>The edit distance  <img class="inlinemath" src="eqo035.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="dist(X,Y)" /> is formally defined as  <img class="displaymath" src="eqo044.png" WIDTH=268 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" dist(X,Y) = min\{cost(O)|O \in \mathbb{S}_{X,Y}\}" /> <ul>
<li> <img class="inlinemath" src="eqo045.png" WIDTH=31 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\mathbb{S_{X,Y}}" /> is the set of all the possible series of operations that can transform the sequence  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> into the sequence  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /></li><li> <img class="inlinemath" src="eqo045.png" WIDTH=31 HEIGHT=19 STYLE="vertical-align: -5px; margin: 0;" alt="\mathbb{S_{X,Y}}" /> is infinite since I can do any number of insertions and deletions on the same character so that the initial and final state of the character are the same  <img class="displaymath" src="eqo046.png" WIDTH=483 HEIGHT=32 STYLE="vertical-align: -23px; margin: 0;" alt=" x \to xa \to xaa \to x\underbrace{a\cdot \cdot \cdot a}_n \to ... \to x\underbrace{a\cdot \cdot \cdot a}_{n-1} \to ... \to xaa \to xa \to x" /> <ul>
<li>For each  <img class="inlinemath" src="eqo047.png" WIDTH=44 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="n \in \mathbb{N}" />, I can transform  <img class="inlinemath" src="eqo048.png" WIDTH=46 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x \to x" /> with cost  <img class="inlinemath" src="eqo049.png" WIDTH=61 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="2*h*n" /> by performing  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> insertions followed by  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> deletions of a character  <img class="inlinemath" src="eqo050.png" WIDTH=42 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="a \in \Sigma" /></li></ul></li>
</ul></li>
<li>The most commonly used edit distance is the Levensthein distance where  <img class="displaymath" src="eqo051.png" WIDTH=195 HEIGHT=91 STYLE="vertical-align: -42px; margin: 0;" alt="\begin{matrix} h=1 \\ \\ c(a,b) =  \begin{cases}0 &amp; \mbox{if } a=b \\ 1 &amp; \mbox{if } a\not=b\end{cases}\end{matrix}" /> <ul>
<li>Because of its mainstream use, Levensthein distance is sometimes used as a synonim of edit distance</li>
<li>It was first described by the Russian scientist Vladimir I. Levensthein in 1965</li>
</ul></li>
<li>Given a cost measure  <img class="inlinemath" src="eqo036.png" WIDTH=37 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(c,h)" /> and a constant  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" />, it is possible to devise a scoring system  <img class="inlinemath" src="eqo018.png" WIDTH=38 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(p,g)" /> for a global alignment as  <img class="displaymath" src="eqo052.png" WIDTH=147 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="p(a,b) = M - c(a,b)" />  <img class="displaymath" src="eqo053.png" WIDTH=107 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="g = -h+M/2" /></li><li>With such a scoring system and cost measure, I observe that for any pair of sequences  <img class="inlinemath" src="eqn664.png" WIDTH=36 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X,Y" />  <img class="displaymath" src="eqo054.png" WIDTH=292 HEIGHT=38 STYLE="vertical-align: -12px; margin: 0;" alt="sim(X,Y)+dist(X,Y)=\frac{M(|X|+|Y|)}{2}" /></li><li>This means that similarity and distance are interchangable: I can compute the distance from the similarity and vice-versa</li>
<li>For the Levensthein distance, if I choose  <img class="inlinemath" src="eqo055.png" WIDTH=50 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M=0" /> such that a match has score 0, a mismatch has score -1, and a gap has score -1, or I can choose  <img class="inlinemath" src="eqo056.png" WIDTH=49 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M=2" /> such that a match has score 2, a mismatch has score 1, and a gap has score 0</li><li>The choice of a constant  <img class="inlinemath" src="eqo057.png" WIDTH=63 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="M'\not=M" /> does not affect which alignment has an optimal score among 2 sequences, but it affects its score, such that  <img class="inlinemath" src="eqo058.png" WIDTH=50 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="S'\not=S" /> but  <img class="inlinemath" src="eqo059.png" WIDTH=50 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S' \propto S" />  <img class="displaymath" src="eqo060.png" WIDTH=211 HEIGHT=38 STYLE="vertical-align: -12px; margin: 0;" alt="S=\frac{|X|+|Y|}{2}(M-M')+S'" /> <ul>
<li>Note that this holds only for global alignments!</li>
</ul></li>
</ul>
<h3 id="sequence-assembly-and-shortest-common-superstring">Sequence assembly and shortest common superstring</h3>
<ul>
<li>Sequence assembly is the act of assebling fragments of DNA obtained from a sequencer in order to reconstruct a genome</li>
<li>A multiple sequence alignment can be used to assemble sequences</li>
<li>The shortest common superstring (SCS) problem is a simplified version of the sequence assembly problem that does not take into accounts errors into the sequenced fragments</li>
<li>The SCS problem takes in input  <img class="inlinemath" src="eqo061.png" WIDTH=46 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="m &gt; 1" /> sequences  <img class="inlinemath" src="eqn993.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_1,...,X_m" /> and returns the shortest string  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> which is a superstring of each  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" /> for  <img class="inlinemath" src="eqo062.png" WIDTH=76 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i=1,..,m" /> <ul>
<li>For  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> to be superstring of  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" />,  <img class="inlinemath" src="eqn972.png" WIDTH=20 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_i" /> must be a substring of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /></li></ul></li>
<li>If  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> is bounded by a constant, then the time complexity of the SCS problem is  <img class="inlinemath" src="eqo002.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^m)" /> using a dynamic programming approach where  <img class="inlinemath" src="eqo063.png" WIDTH=192 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=max\{|X_i||i=1,...,m\}" /> <ul>
<li>For an arbitrary number  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> of sequences, the SCS problem is NP-hard</li></ul></li>
<li>SCS can be reduced to the TSP by creating an overlap graph
<ul>
<li>Let  <img class="inlinemath" src="eqo064.png" WIDTH=103 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X = x_1, \cdot \cdot \cdot x_m" /> and  <img class="inlinemath" src="eqo065.png" WIDTH=95 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Y = y_1, \cdot \cdot \cdot y_n" /> be 2 sequences</li><li>I define their overlap  <img class="inlinemath" src="eqo066.png" WIDTH=56 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\theta(X,Y)" /> as the maximum number of characters  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> such that the k-suffix of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> is equal to the k-prefix of  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" />  <img class="displaymath" src="eqo067.png" WIDTH=386 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" \theta(X,Y)=max\{k|x_{m-k+1}x_{m-k+2}\cdot \cdot \cdot x_m = y_1y_2 \cdot \cdot \cdot y_k\}" /></li><li>An overlap graph for the strings  <img class="inlinemath" src="eqn993.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_1,...,X_m" /> is a weighted, directed and complete graph  <img class="inlinemath" src="eqn419.png" WIDTH=79 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="G=(V,E)" /> with weight function  <img class="inlinemath" src="eqn734.png" WIDTH=14 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="w" /> such that each string is a vertex and the weight of each edge is the difference among the length of the first sequence it connects and the overlap of the connected sequences  <img class="displaymath" src="eqo068.png" WIDTH=126 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" V =\{X_1,...,X_m\}" />  <img class="displaymath" src="eqo069.png" WIDTH=313 HEIGHT=21 STYLE="vertical-align: -6px; margin: 0;" alt=" w(X_i,X_j)=|X_i|-\theta(X_i,X_j) \ \forall (X_i,X_j) \in E" /></li></ul></li>
<li>Let  <img class="inlinemath" src="eqn993.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_1,...,X_m" /> be  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> input sequences where no sequence is a substring of another (otherwise we just ignore it)<ul>
<li>I can find the SCS for  <img class="inlinemath" src="eqn993.png" WIDTH=75 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_1,...,X_m" /> by solving the TSP for the corresponding overlap graph</li><li>Once I find an Hamiltonian path on the overlap graph, I can reconstruct the alignment by aligning without gaps the suffix of any sequence in the path with the prefix of the next sequence</li>
</ul></li>
<li>The transformation of the SCS problem into the TSP is a polynomial-time reduction
<ul>
<li>This proves that the TSP is at least has hard as the SCS probelm, not the opposite</li>
</ul></li>
<li>Since besides being NP-hard the SCS problem is also NP (it can be verified in polynomial time), the SCS problem is NP-complete</li>
<li>If I decide to admit errors in the strings to assemble, things become more complicated
<ul>
<li>An error is any substitution, insertion or deletion in the string as compared to the original sequenced genome</li>
<li>Typically we observe a 1-5% error rate next to the end of a fragment</li>
<li>It may still be possible to reconstruct the right consensus by using gaps and majority voting, if the coverage is high enough</li>
<li>Base call errors are not the only possible sequencing error</li>
<li>A chimera is a fragment made up of sequences that are not contiguous in the original genome
<ul>
<li>Chimeras should be recognized and removed from the input pool before the assebmly step</li>
</ul></li>
<li>The orientation of each fragment (the strand to which it belongs) is unknown
<ul>
<li>A fragment  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> is a substring of the string  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /> iff the reverse complement of  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> is a substring of the reverse complement of  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /></li><li>In general, given  <img class="inlinemath" src="eqn296.png" WIDTH=16 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="m" /> fragments, I should try all the  <img class="inlinemath" src="eqn628.png" WIDTH=21 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2^m" /> possible combinations of fragment orientations</li><li>In practice, I consider all the fragments and their reverse complement as separate nodes in the overlap graph where  <img class="inlinemath" src="eqo070.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="w(X,Y)" /> is the score of the semiglobal alignment between  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /> and  <img class="inlinemath" src="eqn606.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="Y" /></li></ul></li>
<li>Repetitive sequences and missing regions leads to further assembly problems
<ul>
<li>A repetitive region can be identified in the overlap graph as a cycle</li>
<li>A missing region can be identified from the fact that the overlap graph is disconnected</li>
</ul></li>
</ul></li>
</ul>
<h2 id="suffix-tries-trees-and-arrays">Suffix tries, trees, and arrays</h2>
<ul>
<li>In many applications we need to store efficiently a long, known, and fixed string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> over an alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /> <ul>
<li>For example, a genome to which I want to align some reads</li>
</ul></li>
<li>I can preprocess  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> in such a way to facilitate future queries over  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li><li>Given a string  <img class="inlinemath" src="eqo071.png" WIDTH=143 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q \in \Sigma^* : |Q| &lt;&lt; |S|" /> common queries that I may want to answer are<ul>
<li>Is  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> a substring of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />?</li><li>Is  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> a subsequence of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />?</li><li>How many times deos  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> occurr in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />?</li><li>What is the longest common substring of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> and  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />?</li><li>What is the longest common subsequence of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> and  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />?</li><li>What is the best approximation of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />?</li></ul></li>
<li>Other queries are possible that do not depend on any query  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> <ul>
<li>What is the longest repeat in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />?</li></ul></li>
</ul>
<h3 id="suffix-trie">Suffix trie</h3>
<ul>
<li>A suffix trie is a space-efficient tree used for storing strings in such a way to facilitate the processing of common query types</li>
<li>Given a string  <img class="inlinemath" src="eqo072.png" WIDTH=51 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S \in \Sigma^*" /> ending with a special final symbol  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" />, a suffix trie for it is a tree  <img class="inlinemath" src="eqo074.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S)" /> such that<ul>
<li>Each edge corresponds to a character in  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" />, the same character can correspond to many edges</li><li>Any edge from a node to a leaf is labelled with the special character  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" /></li><li>Every path from the root to a leaf represents a suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li><li>Every suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is represented by some path from the root to a leaf</li><li>Suffixes with the same prefix share a common path corresponding to that prefix</li>
</ul></li>
<li>The utility of a suffix trie is based on the fact that any substring of any string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is a prefix of some suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> itself</li><li>To find if  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is a substring of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> using a suffix trie I follow the path in  <img class="inlinemath" src="eqo074.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S)" /> given by  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> <ul>
<li>I am looking for a suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> starting with  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /></li><li>If I am able to match all the characters of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> in a path down the tree,  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is a substring of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, otherwise it is not</li><li>The worst-case time complexity is  <img class="inlinemath" src="eqn415.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m)" />, where  <img class="inlinemath" src="eqo075.png" WIDTH=59 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m=|Q|" />, and it does not depend on the size of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li></ul></li>
<li>To understand if  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is a suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> I can follow the  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />-path in  <img class="inlinemath" src="eqo074.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S)" /> and, if the path ends in a leaf the answer is yes, otherwise no</li><li>To count the occurrences of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> I can follow the  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />-path in  <img class="inlinemath" src="eqo074.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S)" /> and count the number of leaves in the subtree rooted in the node where the  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />-path terminates<ul>
<li>I am counting how many suffixes of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> start with  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /></li></ul></li>
<li>To find the longest repeat in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> I can find the deepest node having at least 2 leaves in its subtree</li><li>To find the lexicographically smallest suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> I can start from the root and follow always the character with smallest alphabetical order until the special character  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" /> is found</li><li>Suffix links connect a node representing the string  <img class="inlinemath" src="eqo076.png" WIDTH=34 HEIGHT=12 STYLE="vertical-align: -1px; margin: 0;" alt="a \cdot w" /> where  <img class="inlinemath" src="eqo050.png" WIDTH=42 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="a \in \Sigma" /> and  <img class="inlinemath" src="eqo077.png" WIDTH=52 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="w \in \Sigma^*" /> with the only node representing the string  <img class="inlinemath" src="eqn734.png" WIDTH=14 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="w" /> <ul>
<li>Every node represents the prefix of some suffix, and it has a suffix link that points to another node representing a string of one character less</li>
<li>A suffix link for a leaf (for a suffix!) always points to another leaf, apart for the suffix link of  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" />, which points to the root</li></ul></li>
<li>To find the longest common substring between  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> and  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />, I can walk down the  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />-path and<ul>
<li>If there is no edge  <img class="inlinemath" src="eqn515.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(u,v)" /> matching the character  <img class="inlinemath" src="eqo078.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[i]" />, I save the node  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> and I try to match the character  <img class="inlinemath" src="eqo078.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[i]" /> starting from the suffix link of  <img class="inlinemath" src="eqn323.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="u" /> <ul>
<li>I am searching for another substring of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> containing the same characters of the common substring found up to now, except for the first character</li><li>I then try to extend it, and if not possible I remove another starting character and try again</li>
<li>If it is not possible to match the character  <img class="inlinemath" src="eqo078.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[i]" />, I eventually backtrack until the root (I start again from scratch)</li><li>If the root does not have any edge matching  <img class="inlinemath" src="eqo078.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[i]" />, it means that character  <img class="inlinemath" src="eqo078.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[i]" /> is absent from  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> <ul>
<li>If  <img class="inlinemath" src="eqo079.png" WIDTH=70 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S,Q \in \Sigma^*" />, this is not possible</li></ul></li>
</ul></li>
<li>When  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is exhausted, the longest common substring among  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> and  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is the deepest of the saved nodes</li><li>The cost of finding the longest common substring among  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> and  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is  <img class="inlinemath" src="eqn415.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m)" /> when  <img class="inlinemath" src="eqo074.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S)" /> is already available, while it is  <img class="inlinemath" src="eqo080.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(nm)" /> with dynamic programming, with  <img class="inlinemath" src="eqo081.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|S|" /> and  <img class="inlinemath" src="eqo075.png" WIDTH=59 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m=|Q|" /></li></ul></li>
<li>In order to build  <img class="inlinemath" src="eqo074.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S)" />, I scan  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> from left to right and I build  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> tries  <img class="inlinemath" src="eqo082.png" WIDTH=101 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S_i)" /> for each prefix  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" /> of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li><li>To get  <img class="inlinemath" src="eqo082.png" WIDTH=101 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S_i)" /> from  <img class="inlinemath" src="eqo083.png" WIDTH=116 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S_{i-1})" /> I add  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> to ALL of the suffixes of  <img class="inlinemath" src="eqo084.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_{i-1}" /> <ul>
<li>Let  <img class="inlinemath" src="eqo085.png" WIDTH=118 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="CurrentSuffix" /> be the longest suffix in  <img class="inlinemath" src="eqo083.png" WIDTH=116 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S_{i-1})" /></li><li>Until you reach the root or the current node has already an outgoing edge labeled  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> <ul>
<li>Add a child labeled  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> to  <img class="inlinemath" src="eqo085.png" WIDTH=118 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="CurrentSuffix" /></li><li>Save the new node in a list</li>
<li>Follow the suffix link of  <img class="inlinemath" src="eqo085.png" WIDTH=118 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="CurrentSuffix" /> and set  <img class="inlinemath" src="eqo085.png" WIDTH=118 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="CurrentSuffix" /> to it<ul>
<li>The suffix link of the longest suffix in  <img class="inlinemath" src="eqo083.png" WIDTH=116 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SuffTrie(S_{i-1})" /> is the second longest suffix in it, and so on</li></ul></li>
<li>Set the suffix link of the previous new node to the node you will create at the next iteration</li>
</ul></li>
<li>Make the sSet tuffix link of the last new node added to point to
<ul>
<li>The root if I terminated because I reached the root</li>
<li>The already existing node if I terminated because the current node has already an outgoing edge labeled  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /></li></ul></li>
</ul></li>
<li>The number of nodes in a suffix trie is not necessarily linear: it is  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /> with  <img class="inlinemath" src="eqo081.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|S|" /> <ul>
<li>Let  <img class="inlinemath" src="eqo086.png" WIDTH=152 HEIGHT=39 STYLE="vertical-align: -25px; margin: 0;" alt="S = \underbrace{a \cdot ... \cdot a}_{n/2}\cdot \underbrace{b \cdot ... \cdot b}_{n/2}" /></li><li>Its suffix trie is composed of the root and
<ul>
<li>A path of  <img class="inlinemath" src="eqn195.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2" /> nodes all labeled with  <img class="inlinemath" src="eqn080.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="a" /> <ul>
<li>This path does not lead to a leaf since  <img class="inlinemath" src="eqn080.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="a" /> is not a suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li></ul></li>
<li> <img class="inlinemath" src="eqo087.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2+1" /> paths which are labeled with only  <img class="inlinemath" src="eqn081.png" WIDTH=9 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="b" />, each containing  <img class="inlinemath" src="eqn195.png" WIDTH=28 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n/2" /> nodes<ul>
<li>All of these paths end in a leaf, since  <img class="inlinemath" src="eqn081.png" WIDTH=9 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="b" /> is a suffix for  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li><li>There is 1 such path starting from the root, and 1 for each of the nodes in the path containing all  <img class="inlinemath" src="eqn080.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="a" /></li></ul></li>
</ul></li>
<li>Therefore, the total number of nodes in the suffix trie is  <img class="displaymath" src="eqo088.png" WIDTH=529 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="1+n/2+(n/2+1)(n/2) = 1+n+n^2/4 = O(1)+O(n)+O(n^2)=O(n^2)" /></li></ul></li>
</ul>
<h3 id="suffix-tree">Suffix tree</h3>
<ul>
<li>Suffix trees improve the space efficiency of suffix tries by compressing the paths without choices and representing suffixes with a range  <img class="inlinemath" src="eqo089.png" WIDTH=29 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i:j" /> corresponding to the substring  <img class="inlinemath" src="eqo090.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i...j]" /> <ul>
<li>If a path does not involve any real choice, there is no need to keep additional nodes, but I can represent that path with a single edge</li>
<li>This edge will correspond not to a symbol  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> but to a range of forced choices  <img class="inlinemath" src="eqo090.png" WIDTH=47 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i...j]" /></li></ul></li>
<li>A compressed representation of a string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> in a suffix tree takes  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> space with  <img class="inlinemath" src="eqo081.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|S|" />, compared to the  <img class="inlinemath" src="eqn231.png" WIDTH=43 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2)" /> space taken by the uncompressed suffix trie<ul>
<li>There are  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> leaves, corresponding to each starting position of a suffix in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li><li>Each internal node has  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> children, with  <img class="inlinemath" src="eqo091.png" WIDTH=73 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="2 \leq k \leq n" /> <ul>
<li> <img class="inlinemath" src="eqo092.png" WIDTH=41 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="k \geq 2" /> since If there is just 1 in choice in a position I remove the node</li></ul></li>
<li>The number of internal nodes (and thus of edges) is  <img class="inlinemath" src="eqo093.png" WIDTH=93 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(k) = O(n)" /> <ul>
<li>The number of internal nodes if  <img class="inlinemath" src="eqn890.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k=2" /> is at most  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" />, with  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> being the number of leaves</li><li>Base case: for 2 leaves I have 1 internal node, and  <img class="inlinemath" src="eqo094.png" WIDTH=98 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="2-1=1 \geq 1" /></li><li>Inductive step: I want to prove that a binary tree with  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> leaves has exactly  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> internal nodes<ul>
<li>A binary tree of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> leaves is made up of a root and</li><li>A left binary subtree of the root with  <img class="inlinemath" src="eqn126.png" WIDTH=11 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k" /> leaves</li><li>A right binary subtree of the root with  <img class="inlinemath" src="eqo095.png" WIDTH=41 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="n-k" /> leaves</li><li>By induction, the left binary subtree has  <img class="inlinemath" src="eqo096.png" WIDTH=39 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="k-1" /> internal nodes, and the right binary subtree has  <img class="inlinemath" src="eqo097.png" WIDTH=69 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="n-k-1" /> internal nodes</li></ul></li>
<li>Thus, a binary tree of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> leaves has  <img class="inlinemath" src="eqn185.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n-1" /> internal nodes  <img class="displaymath" src="eqo098.png" WIDTH=472 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="(k-1)+(n-k-1)+1 = n-k+k-1-1+1 = n-1 = O(n)" /></li><li>If  <img class="inlinemath" src="eqo099.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k &gt; 2" />, the number of internal nodes is smaller than if  <img class="inlinemath" src="eqn890.png" WIDTH=41 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k=2" />, so the number of internal nodes is  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> in any case</li></ul></li>
<li>The total number of nodes (leaves and internal nodes) in a suffix tree  <img class="inlinemath" src="eqn280.png" WIDTH=14 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="T" /> is thus  <img class="displaymath" src="eqo100.png" WIDTH=238 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" |T| \leq n+n-1 = 2n-1 = O(n)" /></li><li>Each edge in the tree takes constant space, if I assume that each range is encoded by  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" /> bits</li></ul></li>
<li>A suffix tree can be built in  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> time using the algorithm of the Finnish scientist Esko J. Ukkonen (1995)<ul>
<li>It works similarly to the algorithm for building a suffix trie, but with some additional tricks</li>
<li>The hidden constant for this algorithm is big: I need about 20 bytes per character of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> <ul>
<li>For a 10 Gbp genome I need around 200 Gb of storage space!</li>
</ul></li>
</ul></li>
</ul>
<h3 id="suffix-array">Suffix array</h3>
<ul>
<li>A suffix array is a more efficient way to store the suffixes of a string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> in  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> space</li><li>A suffix array has the same capabilities of a suffix tree, but operations on it are a bit slower</li>
<li>The main idea is to sort lexicographically all the suffixes and store their starting indexes into an array</li>
<li>I first define a total order  <img class="inlinemath" src="eqo101.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\preceq" /> on the characters in the alphabet  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /> <ul>
<li> <img class="inlinemath" src="eqo101.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\preceq" /> is a total order because  <img class="inlinemath" src="eqo102.png" WIDTH=181 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="a \preceq b \lor b \preceq a \quad \forall \ a,b \in \Sigma" /></li></ul></li>
<li>I then extend the total order  <img class="inlinemath" src="eqo101.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\preceq" /> from single characters to strings: for each  <img class="inlinemath" src="eqo103.png" WIDTH=74 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X,Y \in \Sigma^*" />, with  <img class="inlinemath" src="eqo104.png" WIDTH=61 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m=|X|" /> and  <img class="inlinemath" src="eqo105.png" WIDTH=55 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|Y|" />,  <img class="inlinemath" src="eqo106.png" WIDTH=52 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="X \preceq Y" /> iff there is a  <img class="inlinemath" src="eqo107.png" WIDTH=157 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="k \in \{0,...,min(m,n)\}" /> such that  <img class="inlinemath" src="eqo108.png" WIDTH=61 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="X_k = Y_k" /> and  <img class="inlinemath" src="eqo109.png" WIDTH=143 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X[k+1] \prec Y[k+1]" /> or  <img class="inlinemath" src="eqo110.png" WIDTH=47 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k=m" />  <img class="displaymath" src="eqo111.png" WIDTH=545 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="X \preceq Y \iff \exists k \in \{0,...,min(m,n)\} : X_k=Y_k \land (X[k+1] \prec Y[k+1] \lor k=m)" /></li><li>The space complexity for suffix arrays is  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> like for suffix trees, but the hidden constant is much smaller<ul>
<li>I just need to store the string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> itself and an array of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> indexes</li></ul></li>
<li>To search for a query string  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, I perform a binary search on the index array to find a suffix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> starting with  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> <ul>
<li>It is equivalent to a binary search among numbers (I am just using a  <img class="inlinemath" src="eqo101.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\preceq" /> order instead of an  <img class="inlinemath" src="eqn072.png" WIDTH=19 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="\leq" /> order)</li><li>The cost of checking  <img class="inlinemath" src="eqo112.png" WIDTH=42 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="x \leq y" /> is  <img class="inlinemath" src="eqn172.png" WIDTH=35 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(1)" />, but the worst case complexity for checking whether  <img class="inlinemath" src="eqo106.png" WIDTH=52 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="X \preceq Y" /> is  <img class="inlinemath" src="eqo113.png" WIDTH=51 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(|X|)" /> since I may need to check all the characters in  <img class="inlinemath" src="eqn605.png" WIDTH=17 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="X" /></li><li>Since I need to perform  <img class="inlinemath" src="eqn310.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(\log n)" /> comparisons in the worst case for a binary search with  <img class="inlinemath" src="eqo081.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|S|" />, the total worst case time complexity for searching  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is  <img class="inlinemath" src="eqn584.png" WIDTH=77 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m \log n)" /> with  <img class="inlinemath" src="eqo075.png" WIDTH=59 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m=|Q|" /> <ul>
<li>This compares to a  <img class="inlinemath" src="eqn415.png" WIDTH=41 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(m)" /> time complexity using suffix tries or trees</li></ul></li>
</ul></li>
<li>I can build a suffix array in  <img class="inlinemath" src="eqn909.png" WIDTH=79 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2 \log n)" /> time by sorting the  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> suffixes with  <img class="inlinemath" src="eqn579.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n \log n)" /> comparisons (the bound for comparison-based sorting), each costing  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /></li><li>I can actually do better and build a suffix array in  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> by exploiting the relationship of suffix arrays with suffix trees<ul>
<li>I build a suffix tree in  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> using the Ukkonnen algorithm such that<ul>
<li>The edges leaving a node in a suffix tree are sorted lexicographically by their labels</li>
<li>Each leaf in a suffix tree is labelled with the start position of the corresponding suffix</li>
</ul></li>
<li>I can perform a in-order visit of this suffix tree and just output the labels of the leaves that I encounter, putting them in the suffix array</li>
</ul></li>
<li>I can also obtain a suffix array in  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /> without building a suffix tree, using the Skew algorithm designed in 2003 by Karkainnen and Sanders<ul>
<li>This algorithm is based on a skewed (2/3 to 1/3) divide-et-impera approach and on radix-sort</li>
<li>I assume that the string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> starts from position 0 instead of from position 1</li><li>I use the special symbol  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" /> to pad  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, if needed, so that  <img class="inlinemath" src="eqo114.png" WIDTH=108 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|S| \mod 3 = 0" /></li><li>I divide the suffixes of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> into 3 groups: the ones starting in position  <img class="inlinemath" src="eqo115.png" WIDTH=82 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="i=0,3k,..." /> with  <img class="inlinemath" src="eqn869.png" WIDTH=44 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="k \in \mathbb{N}" />, the ones starting in position  <img class="inlinemath" src="eqo116.png" WIDTH=110 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="i=1,3k+1,..." />, and the ones starting in position  <img class="inlinemath" src="eqo117.png" WIDTH=110 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="i=2,3k+2,..." /></li><li>I build the suffix array  <img class="inlinemath" src="eqo118.png" WIDTH=40 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="SA^{1,2}" /> for suffixes starting at position  <img class="inlinemath" src="eqo119.png" WIDTH=113 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="i : i \mod 3 \not = 0" /> (all the suffixes NOT belonging to the first group)</li><li>I build the suffix array  <img class="inlinemath" src="eqo120.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="SA^0" /> for suffixes starting at position  <img class="inlinemath" src="eqo121.png" WIDTH=113 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="i : i \mod 3 = 0" /> (all the suffixes belonging to the first group)</li><li>I use radix-sort to sort in linear time the sub-arrays</li>
<li>I build the suffix array  <img class="inlinemath" src="eqo122.png" WIDTH=25 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="SA" /> for  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> by merging  <img class="inlinemath" src="eqo118.png" WIDTH=40 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="SA^{1,2}" /> and  <img class="inlinemath" src="eqo120.png" WIDTH=31 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="SA^0" /></li></ul></li>
</ul>
<h3 id="burrows-wheeler-transform">Burrows-Wheeler transform</h3>
<ul>
<li>In some situations transforming the input string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> can be convenient<ul>
<li> <img class="inlinemath" src="eqo081.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|S|" /> could be huge (millions of characters)</li><li>Storing a string  <img class="inlinemath" src="eqo072.png" WIDTH=51 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S \in \Sigma^*" /> with length  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> requires  <img class="inlinemath" src="eqo123.png" WIDTH=58 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n \log |\Sigma|" /> bits</li><li>A suffix array requires thus  <img class="inlinemath" src="eqo124.png" WIDTH=150 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n \log n)+n \log |\Sigma|" /> bits<ul>
<li>The index array is composed of  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> symbols  <img class="inlinemath" src="eqo125.png" WIDTH=15 HEIGHT=13 STYLE="vertical-align: -4px; margin: 0;" alt="x_i" /> with  <img class="inlinemath" src="eqo126.png" WIDTH=113 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="x:i \in \{1,...,n\}" />, so it requires  <img class="inlinemath" src="eqo127.png" WIDTH=48 HEIGHT=19 STYLE="vertical-align: -4px; margin: 0;" alt="n \log n" /> bits for its representation</li><li>Note that typically  <img class="inlinemath" src="eqo128.png" WIDTH=66 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n &gt;&gt; |\Sigma|" />,  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> can be in the order of  <img class="inlinemath" src="eqo129.png" WIDTH=22 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^{32}" /> while  <img class="inlinemath" src="eqo130.png" WIDTH=22 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|\Sigma|" /> can be on the order of  <img class="inlinemath" src="eqo131.png" WIDTH=63 HEIGHT=17 STYLE="vertical-align: -1px; margin: 0;" alt="2^8=256" /></li></ul></li>
<li>I can use data compression algorithms to save space</li>
</ul></li>
<li>The Burrows-Wheeler Transform (BWT) is NOT a compression algorithm, but it prepares the compression of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> by transforming it in the string  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> <ul>
<li>It was developped by M. Burrows and D. Wheeler in 1994</li>
<li>The goal of BWT is to find a string  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> that maximizes the number of repeated characters in it, so to facilitate its subsequent compression</li><li>The BWT performs a reversible permutation of a string</li>
</ul></li>
<li>I first produce a string  <img class="inlinemath" src="eqo133.png" WIDTH=70 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S' = S \cdot \$" />, with  <img class="inlinemath" src="eqo134.png" WIDTH=101 HEIGHT=17 STYLE="vertical-align: -3px; margin: 0;" alt="\$ \preceq a \ \forall \ a \in \Sigma" /></li><li>I then generate all the cyclic shifts of  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" /> and sort them lexicographically forming a matrix  <img class="inlinemath" src="eqo135.png" WIDTH=123 HEIGHT=19 STYLE="vertical-align: -1px; margin: 0;" alt="M \in \Sigma^{(n+1)\times (n+1)}" /> <ul>
<li>The matrix  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> for  <img class="inlinemath" src="eqo136.png" WIDTH=87 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=banana" /> is then  <img class="displaymath" src="eqo137.png" WIDTH=142 HEIGHT=144 STYLE="vertical-align: -67px; margin: 0;" alt="M(S)=\begin{bmatrix}\$banana \\ a\$banan \\ ana\$ban \\ anana\$b \\ banana\$ \\ na\$bana \\ nana\$ba \end{bmatrix}" /></li></ul></li>
<li>I select as  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> the last column of the matrix  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> <ul>
<li>Each position in  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" /> is appearing in the last column of  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> once and only once</li><li>Since the  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> matrix is sorted, the characters in the BWT are choosen according to the similar character envronment in which they are found</li><li>If there are repetitive patterns in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, the BWT of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> tends to contain stretches of similar characters, brought together by the similar context in which they are found</li><li>The rows of the sorted  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> matrix up to the special character  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" /> are equivalent to a suffix array of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> <ul>
<li>This is because, since  <img class="inlinemath" src="eqo138.png" WIDTH=103 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$ \prec x \ \forall \ x \in \Sigma" />, a string is sorted before any other where the special character is present</li></ul></li>
<li> <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> for  <img class="inlinemath" src="eqo136.png" WIDTH=87 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=banana" /> is thus  <img class="displaymath" src="eqo139.png" WIDTH=150 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" BWT(S) = annb\$aa " /></li><li>Compare each row of the matrix  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> up to the special character  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" /> with the suffix array  <img class="inlinemath" src="eqo140.png" WIDTH=48 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="SA(S)" />  <img class="displaymath" src="eqo141.png" WIDTH=303 HEIGHT=144 STYLE="vertical-align: -67px; margin: 0;" alt="SA(S) = [7,6,4,2,1,5,3] \implies\begin{bmatrix}\$ \\ a\$ \\ ana\$ \\ anana\$ \\ banana\$ \\ na\$ \\ nana\$ \end{bmatrix} " /></li></ul></li>
<li>The BWT transformation costs  <img class="inlinemath" src="eqn909.png" WIDTH=79 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="O(n^2 \log n)" /> since I need to perform  <img class="inlinemath" src="eqo142.png" WIDTH=73 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n\log n)" /> lexicographic comparisons, each costing  <img class="inlinemath" src="eqn157.png" WIDTH=36 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O(n)" /></li><li>The BWT transformation is reversible: I can get back  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> from  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> <ul>
<li>I can compute  <img class="inlinemath" src="eqo143.png" WIDTH=172 HEIGHT=21 STYLE="vertical-align: -5px; margin: 0;" alt="BWT^{-1}(BWT(S))=S" /> by creating a matrix  <img class="inlinemath" src="eqo144.png" WIDTH=118 HEIGHT=19 STYLE="vertical-align: -1px; margin: 0;" alt="B \in \Sigma^{(n+1)\times (n+1)}" /></li><li>I start from  <img class="inlinemath" src="eqo145.png" WIDTH=45 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="B = \emptyset" /> and I proceed one column at time</li><li>I put the string  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> as the first column of  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> and I sort it lexicographically</li><li>I repeat  <img class="inlinemath" src="eqo146.png" WIDTH=39 HEIGHT=16 STYLE="vertical-align: -3px; margin: 0;" alt="n+1" /> times by prepending  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> to the partial  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> matrix and sorting the result lexicographically</li><li>For  <img class="inlinemath" src="eqo136.png" WIDTH=87 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=banana" /> and $BWT(S)=annb$aa $ the  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> matrix is thus built as follows  <img class="displaymath" src="eqo147.png" WIDTH=753 HEIGHT=142 STYLE="vertical-align: -66px; margin: 0;" alt="\begin{bmatrix} a \\ n \\ n \\ b \\ \$ \\ a \\ a \end{bmatrix}
\xrightarrow{\text{sort}}
\begin{bmatrix} \$ \\ a \\ a \\ a \\ b \\ n \\ n \end{bmatrix}
\xrightarrow{\text{prepend}}
\begin{bmatrix} a\$ \\ na \\ na \\ ba \\ \$b \\ an \\ an \end{bmatrix}
\xrightarrow{\text{sort}}
\begin{bmatrix} \$b \\ a\$ \\ an \\ an \\ ba \\ na \\ na \end{bmatrix}
\xrightarrow{\text{prepend}}
\begin{bmatrix} a\$b \\ na\$ \\ nan \\ ban \\ \$ba \\ ana \\ ana \end{bmatrix}
\xrightarrow{\text{sort}}
\begin{bmatrix} \$ba \\ a\$b \\ ana \\ ana \\ ban \\ na\$ \\ nan \end{bmatrix}
\xrightarrow{\text{prepend}}
\begin{bmatrix} a\$ba \\ na\$b \\ nana \\ bana \\ \$ban \\ ana\$ \\ anan \end{bmatrix}
\xrightarrow{\text{sort}}
\begin{bmatrix} \$ban \\ a\$ba \\ ana\$ \\ anan \\ bana \\ na\$b \\ nana \end{bmatrix}
\xrightarrow{\text{prepend}}
" />  <img class="displaymath" src="eqo148.png" WIDTH=683 HEIGHT=142 STYLE="vertical-align: -66px; margin: 0;" alt="\begin{bmatrix} a\$ban \\ na\$ba \\ nana\$ \\ banan \\ \$bana \\ ana\$b \\ anana \end{bmatrix}
\xrightarrow{\text{sort}}
\begin{bmatrix} \$bana \\ a\$ban \\ ana\$b \\ anana \\ banan \\ na\$ba \\ nana\$ \end{bmatrix}
\xrightarrow{\text{prepend}}
\begin{bmatrix} a\$bana \\ na\$ban \\ nana\$b \\ banana \\ \$banan \\ ana\$ba \\ anana\$ \end{bmatrix}
\xrightarrow{\text{sort}}
\begin{bmatrix} \$banan \\ a\$bana \\ ana\$ba \\ anana\$ \\ banana \\ na\$ban \\ nana\$b \end{bmatrix}
\xrightarrow{\text{prepend}}
\begin{bmatrix} a\$banan \\ na\$bana \\ nana\$ba \\ banana\$ \\ \$banana \\ ana\$ban \\ anana\$b \end{bmatrix}
\xrightarrow{\text{sort}}
\begin{bmatrix} \$banana \\ a\$banan \\ ana\$ban \\ anana\$b \\ banana\$ \\ na\$bana \\ nana\$ba \end{bmatrix}
" /></li><li>Finally, I return  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" /> as the row of  <img class="inlinemath" src="eqn022.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="B" /> ending with the special symbol  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" />  <img class="displaymath" src="eqo149.png" WIDTH=228 HEIGHT=17 STYLE="vertical-align: -2px; margin: 0;" alt="S'=banana\$ \implies S=banana" /></li></ul></li>
</ul>
<h3 id="lf-mapping">LF mapping</h3>
<ul>
<li>Let  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> be the BWT matrix for a string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, let  <img class="inlinemath" src="eqo081.png" WIDTH=53 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="n=|S|" />, and let  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> and  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> be the first and last column of  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" />, repsectively<ul>
<li>The last column of  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> is the BWT of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> by definition  <img class="displaymath" src="eqo150.png" WIDTH=100 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" L = BWT(S)" /></li><li>Since  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> is sorted, the first column  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> is also sorted  <img class="displaymath" src="eqo151.png" WIDTH=226 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" F[i] \preceq F[i+1] \ \forall \ i \in {1,...,n+1}" /></li></ul></li>
<li>The first column  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> and the last columns  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> of the  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> matrix exhibit the LF mapping property</li><li>An LF mapping for  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> is defined as an array  <img class="inlinemath" src="eqo152.png" WIDTH=26 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="LF" /> such that the number stored in  <img class="inlinemath" src="eqo153.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="LF[i]" /> is the index of charachter  <img class="inlinemath" src="eqo154.png" WIDTH=129 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L[i]=BWT(S)[i]" /> in the array  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> for  <img class="inlinemath" src="eqo155.png" WIDTH=103 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i=1,...,n+1" /> <ul>
<li> <img class="inlinemath" src="eqo152.png" WIDTH=26 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="LF" /> is thus a permutation of  <img class="inlinemath" src="eqo156.png" WIDTH=92 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="\{1,...,n+1\}" /></li><li>For  <img class="inlinemath" src="eqo157.png" WIDTH=248 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=banana,\ BWA(S)=annb\$aa" /> I have that  <img class="displaymath" src="eqo158.png" WIDTH=536 HEIGHT=142 STYLE="vertical-align: -66px; margin: 0;" alt="M(S)=\begin{bmatrix}\$banana \\ a\$banan \\ ana\$ban \\ anana\$b \\ banana\$ \\ na\$bana \\ nana\$ba \end{bmatrix}
\implies
L=\begin{bmatrix} a \\ n \\ n \\ b \\ \$ \\ a \\ a \end{bmatrix}, \ 
F=\begin{bmatrix}\$ \\ a \\ a \\ a \\ b \\ n \\ n \end{bmatrix}
\implies
LF=[2,6,7,5,1,3,4]" /></li></ul></li>
<li>Let  <img class="inlinemath" src="eqo159.png" WIDTH=23 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="R_S" /> be a function  <img class="inlinemath" src="eqo160.png" WIDTH=58 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma^* \to \mathbb{N}" /> such that  <img class="inlinemath" src="eqo161.png" WIDTH=40 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_S(i)" /> is the number of occurrences of the character  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> in  <img class="inlinemath" src="eqn549.png" WIDTH=16 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="S_i" />, the  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" />-th prefix of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> (consisting of  <img class="inlinemath" src="eqn840.png" WIDTH=76 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1...i-1]" />)<ul>
<li> <img class="inlinemath" src="eqo161.png" WIDTH=40 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_S(i)" /> is called as the rank of character  <img class="inlinemath" src="eqn834.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[i]" /> in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li><li>I can write an array  <img class="inlinemath" src="eqo159.png" WIDTH=23 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="R_S" /> such that  <img class="inlinemath" src="eqo162.png" WIDTH=97 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_S[i]=R_S(i)" /></li><li>For a string  <img class="inlinemath" src="eqo163.png" WIDTH=119 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=aaaabbbbbba" />, thus the array  <img class="inlinemath" src="eqo159.png" WIDTH=23 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="R_S" /> is  <img class="displaymath" src="eqo164.png" WIDTH=216 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_S=[0,1,2,3,0,1,2,3,4,5,4]" /></li></ul></li>
<li>An LF mapping respsects the LF property: the rank of every position  <img class="inlinemath" src="eqo155.png" WIDTH=103 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="i=1,...,n+1" /> is preserved between the arrays  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> and  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" />  <img class="displaymath" src="eqo165.png" WIDTH=257 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_L(i)=R_F(LF[i]) \ \forall \ i=1,...,n+1" /> <ul>
<li>Here  <img class="inlinemath" src="eqo166.png" WIDTH=40 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_L(i)" /> is the ranking of character  <img class="inlinemath" src="eqn095.png" WIDTH=7 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="i" /> in the array  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" />, and  <img class="inlinemath" src="eqo167.png" WIDTH=74 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_F(LF[i])" /> is the ranking of character  <img class="inlinemath" src="eqo153.png" WIDTH=39 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="LF[i]" /> (the position of chartachter  <img class="inlinemath" src="eqo168.png" WIDTH=26 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L[i]" /> in the array  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" />) in the array  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /></li><li>This means that the order of equal symbols is preserved between  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> and  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /></li><li>For  <img class="inlinemath" src="eqo136.png" WIDTH=87 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=banana" /> we observe that  <img class="displaymath" src="eqo169.png" WIDTH=300 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=banana,\ L=annb\$aa,\ F=\$aaabnn" />  <img class="displaymath" src="eqo170.png" WIDTH=488 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_L=[0,0,1,0,0,1,2],\ R_F=[0,0,1,2,0,0,1],\ LF=[2,6,7,5,1,3,4]" />  <img class="displaymath" src="eqo171.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(1) = 0 \implies R_F(LF[1])=R_F(2)=0" />  <img class="displaymath" src="eqo172.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(2) = 0 \implies R_F(LF[2])=R_F(6)=0" />  <img class="displaymath" src="eqo173.png" WIDTH=289 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(3) = 1 \implies R_F(LF[3])=R_F(7)=1" />  <img class="displaymath" src="eqo174.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(4) = 0 \implies R_F(LF[4])=R_F(5)=0" />  <img class="displaymath" src="eqo175.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(5) = 0 \implies R_F(LF[5])=R_F(1)=0" />  <img class="displaymath" src="eqo176.png" WIDTH=289 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(6) = 1 \implies R_F(LF[6])=R_F(3)=1" />  <img class="displaymath" src="eqo177.png" WIDTH=289 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(7) = 2 \implies R_F(LF[7])=R_F(4)=2" /></li><li>The preservation of ranks is also true for the rank of the symbols in the original string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />: their original rank is preserved between  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> and  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /></li><li>For  <img class="inlinemath" src="eqo136.png" WIDTH=87 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=banana" /> thus we have<ul>
<li>Showing the ranks of symbols in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> (they are not really stored, but showing them now is useful for keeping track of them)  <img class="displaymath" src="eqo178.png" WIDTH=447 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S'=banana\$,\ R_S' = [0,0,0,1,1,2,0] \implies S=b_0a_0n_0a_1n_1a_2\$_0" /></li><li>The original ranks in the  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> matrix and in the  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> and  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> arrays  <img class="displaymath" src="eqo179.png" WIDTH=582 HEIGHT=142 STYLE="vertical-align: -66px; margin: 0;" alt="M(S)=\begin{bmatrix}
\$_0b_0a_0n_0a_1n_1a_2 \\
a_2\$_0b_0a_0n_0a_1n_1 \\
a_1n_1a_2\$_0b_0a_0n_0 \\
a_0n_0a_1n_1a_2\$_0b_0 \\
b_0a_0n_0a_1n_1a_2\$_0 \\
n_1a_2\$_0b_0a_0n_0a_1 \\
n_0a_1n_1a_2\$_0b_0a_0
\end{bmatrix}
\implies
L=[a_2n_1n_0b_0\$_0a_1a_0], \ F=[\$_0a_2,a_1,a_0,b_0,n_1,n_0]" />  <img class="displaymath" src="eqo180.png" WIDTH=488 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="R_L = [2,1,0,0,0,1,0], \ R_F=[0,2,1,0,0,1,0],\ LF=[2,6,7,5,1,3,4]" />  <img class="displaymath" src="eqo181.png" WIDTH=289 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(1) = 2 \implies R_F(LF[1])=R_F(2)=2" />  <img class="displaymath" src="eqo182.png" WIDTH=289 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(2) = 1 \implies R_F(LF[2])=R_F(6)=1" />  <img class="displaymath" src="eqo183.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(3) = 0 \implies R_F(LF[3])=R_F(7)=0" />  <img class="displaymath" src="eqo174.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(4) = 0 \implies R_F(LF[4])=R_F(5)=0" />  <img class="displaymath" src="eqo175.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(5) = 0 \implies R_F(LF[5])=R_F(1)=0" />  <img class="displaymath" src="eqo176.png" WIDTH=289 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(6) = 1 \implies R_F(LF[6])=R_F(3)=1" />  <img class="displaymath" src="eqo184.png" WIDTH=290 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" R_L(7) = 0 \implies R_F(LF[7])=R_F(4)=0" /></li></ul></li>
<li>It is easy to see why the LF property holds
<ul>
<li>Equal characters in the  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> column of  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> are sorted according to the characters at their right (called their right context)</li><li>Equal characters in the  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> column of  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> are sorted according to the charachters at their left (their left context)</li><li>Since the  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> matrix is obtained with rotations of the string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />, the left context of the characters in  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> is the right context of the same charachters when they are in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /></li><li>Thus, the order of equal characters is preserved between  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> and  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /></li></ul></li>
</ul></li>
<li>Ranking the characters not according to their occurrence in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> but to their occurrence in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> is useful<ul>
<li>I get a predictable structure of  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> where characters are sorted (because it is the first column!) and equal characters have ascending rank</li><li>Since every character appears in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> once, I have a rank for all the characters in the matrix thanks to this property</li><li>Thanks to the LF property, also the ranks in  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> (and so on  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" />!) will be ascending for equal characters</li><li>If I want to know the index in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> of a character  <img class="inlinemath" src="eqo185.png" WIDTH=74 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="x_n : x \in \Sigma" /> with rank  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" />, I just need to add  <img class="inlinemath" src="eqn060.png" WIDTH=12 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="n" /> to the sum of the number of occurreces in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> of other characters with lexicographic order smaller than  <img class="inlinemath" src="eqn015.png" WIDTH=11 HEIGHT=10 STYLE="vertical-align: -1px; margin: 0;" alt="x" /> in  <img class="inlinemath" src="eqn610.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="\Sigma" /> (I also add 1 since I am starting the indeces from 1)  <img class="displaymath" src="eqo186.png" WIDTH=187 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="F=[\$_0a_0,a_1,a_2,b_0,n_0,n_1]" />  <img class="displaymath" src="eqo187.png" WIDTH=537 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="index_F(n_1) = num(\$)+num(a)+num(b)+rank(n_1)+1=1+3+1+1+1=7" />  <img class="displaymath" src="eqo188.png" WIDTH=69 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="F[7]=n_1" /></li></ul></li>
<li>I can use the LF mapping to retrieve  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> from  <img class="inlinemath" src="eqo132.png" WIDTH=67 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWT(S)" /> <ul>
<li>The first character in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> is necessarily  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" /></li><li>The character that came before  <img class="inlinemath" src="eqo073.png" WIDTH=10 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="\$" /> in  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" /> (the last character of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />) is the character in  <img class="inlinemath" src="eqo189.png" WIDTH=29 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L[1]" /> <ul>
<li>This is because each row of the  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> matrix is a rotation of  <img class="inlinemath" src="eqn775.png" WIDTH=17 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S'" />: the character before  <img class="inlinemath" src="eqo190.png" WIDTH=31 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="F[1]" /> in the rotation is  <img class="inlinemath" src="eqo189.png" WIDTH=29 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L[1]" /></li></ul></li>
<li>In the same way I can then take the character in  <img class="inlinemath" src="eqo189.png" WIDTH=29 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L[1]" /> and find it in  <img class="inlinemath" src="eqo191.png" WIDTH=62 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="F[LS[1]]" />: the second last character of  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> will be then  <img class="inlinemath" src="eqo192.png" WIDTH=60 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L[LS[1]]" /></li><li>I can proceed like this until I obtain  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> from  <img class="inlinemath" src="eqo193.png" WIDTH=101 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L=BWA(S)" /> and  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /></li><li>Note that if I use rankings based on the order on  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> I actually never need  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> to reconstruct  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> from  <img class="inlinemath" src="eqo194.png" WIDTH=68 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="BWA(S)" /> in this way: I only need  <img class="inlinemath" src="eqo193.png" WIDTH=101 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L=BWA(S)" />!<ul>
<li>The position of each character on  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> can be reconstructed since  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> is always lexicographically sorted!</li><li>Here I omit the ranks, since I am always proceeding backwards from the lowest rank to the higest in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" />  <img class="displaymath" src="eqo195.png" WIDTH=248 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=banana, \ BWA(S)=annb\$aa" />  <img class="displaymath" src="eqo196.png" WIDTH=321 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[6]=L[1]=a \implies next=num(\$)+1=2" />  <img class="displaymath" src="eqo197.png" WIDTH=470 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[5]=L[2]=n \implies next=num(\$)+num(a)+num(b)+1=6" />  <img class="displaymath" src="eqo198.png" WIDTH=396 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[4]=L[6]=a \implies next=num(\$)+1+used(a)=3" />  <img class="displaymath" src="eqo199.png" WIDTH=537 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[3]=L[3]=n \implies next=num(\$)+num(a)+num(b)+1+used(n)=7" />  <img class="displaymath" src="eqo200.png" WIDTH=396 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[2]=L[7]=a \implies next=num(\$)+1+used(a)=4" />  <img class="displaymath" src="eqo201.png" WIDTH=110 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S[1]=L[4]=b" />  <img class="displaymath" src="eqo202.png" WIDTH=378 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="S=L[4]+L[7]+L[3]+L[6]+L[2]+L[1]=banana" /></li></ul></li>
</ul></li>
<li>An LF mapping can be used for counting the occurrences of a query string  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> into the string  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> <ul>
<li>Here we will see an example with  <img class="inlinemath" src="eqo136.png" WIDTH=87 HEIGHT=16 STYLE="vertical-align: -1px; margin: 0;" alt="S=banana" /> and  <img class="inlinemath" src="eqo203.png" WIDTH=64 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q=ana" /></li><li>I scan  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> right-to-left (from the end) to find the range of rows prefixed by successively longer suffixes of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /></li><li>I start thus from the last character of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> and I see to which positions does it match in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" />, selecting a range of matches  <img class="displaymath" src="eqo204.png" WIDTH=302 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[3]=a, L=annb\$aa \implies F[2..4]=aaa" /> <ul>
<li>This means that the rows  <img class="inlinemath" src="eqo205.png" WIDTH=32 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2...4" /> in the  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> matrix are prefixed by  <img class="inlinemath" src="eqo206.png" WIDTH=31 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[3]" />, a suffix of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /></li></ul></li>
<li>I procede with the second last character of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" />, and I search for occurrences of it in the selected range in  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" />  <img class="displaymath" src="eqo207.png" WIDTH=540 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt=" Q[2]=n,\ L[2...4]=nnb \implies L[2...3]=nn \implies L[LF[2]...LF[3]]=L[6...7]" /> <ul>
<li>By following the range from  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /> to  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" />, I am searching among the characters preceeding  <img class="inlinemath" src="eqo208.png" WIDTH=52 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="F[2...4]" /></li><li>I restrict the range to  <img class="inlinemath" src="eqo209.png" WIDTH=32 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="2...3" />, corresponding to the rows ending with  <img class="inlinemath" src="eqo210.png" WIDTH=64 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[2]=n" /> and starting with  <img class="inlinemath" src="eqo211.png" WIDTH=63 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[3]=a" /></li><li>By following the LF mapping of the range I get to range  <img class="inlinemath" src="eqo212.png" WIDTH=32 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="6...7" />, where the characters in  <img class="inlinemath" src="eqn203.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="L" /> become in  <img class="inlinemath" src="eqn444.png" WIDTH=15 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="F" /></li><li>This means that the rows  <img class="inlinemath" src="eqo212.png" WIDTH=32 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="6...7" /> of the matrix  <img class="inlinemath" src="eqn405.png" WIDTH=19 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="M" /> are prefixed by the suffix  <img class="inlinemath" src="eqo213.png" WIDTH=94 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[2...3]=na" />, since I selected this match only among the matches selected at the previous step</li></ul></li>
<li>I procede matching  <img class="inlinemath" src="eqo214.png" WIDTH=63 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[1]=a" /> in  <img class="inlinemath" src="eqo215.png" WIDTH=91 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="L[6...7]=aa" />  <img class="displaymath" src="eqo216.png" WIDTH=567 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="Q[1]=a,\ L[6...7]=aa \implies L[6...7]=aa \implies L[LF[6]...LF[7]]=L[3...4]=nb" /></li><li>The size of the final range that I have when  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> is consumed completely denotes the number of occurrences of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" />  <img class="displaymath" src="eqo217.png" WIDTH=304 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="|L[3...4]|=2 \implies 2 \mbox{ occurrences of $Q$ in $S$}" /></li><li>If at any point the range has size 0, it means that there are no occurrences of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /></li></ul></li>
<li>It is possible to find occurrences of  <img class="inlinemath" src="eqn413.png" WIDTH=15 HEIGHT=17 STYLE="vertical-align: -4px; margin: 0;" alt="Q" /> in  <img class="inlinemath" src="eqn016.png" WIDTH=13 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="S" /> in  <img class="inlinemath" src="eqo218.png" WIDTH=63 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="=O(m)" /> with  <img class="inlinemath" src="eqo075.png" WIDTH=59 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="m=|Q|" /> by calculating the  <img class="inlinemath" src="eqo152.png" WIDTH=26 HEIGHT=14 STYLE="vertical-align: -1px; margin: 0;" alt="LF" /> array on the fly in  <img class="inlinemath" src="eqo219.png" WIDTH=57 HEIGHT=20 STYLE="vertical-align: -5px; margin: 0;" alt="O=(1)" /> <ul>
<li>This approach was developped by Ferragina, Manzini and it uses the FM-index data structure</li>
<li>FM-index is a BWT-based data structure that allows to compress the input while permitting fast substring queries</li>
<li>The FM-index was successfully applied to approximate string matching and sequence alignment problems (bowtie)</li>
</ul></li>
</ul>
<hr />
<h1 id="exam-info">Exam info</h1>
<ul>
<li>Exam will be written, but you can do also an oral part if you want</li>
</ul>
