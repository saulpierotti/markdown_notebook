<h1 id="intro">Intro</h1>
<ul>
<li>Pseudocode is a script in natural language</li>
<li>Homology is boolean: 2 sequences are either homolgs or not</li>
<li>I can do homology building only if I have homologs (!)</li>
<li>Python is read line by line, so I cannot define a function after calling it (!)</li>
<li>Code of conduct were born in programming communities</li>
</ul>
<h1 id="structural-alignment">Structural alignment</h1>
<ul>
<li>The superimposition problem can be formalized as, given 2 sets of points A and B, finding the optimal subsets of A and B for which the norm of the 2 subsets is equal and the optimal rigid body trasformation such that minimizes a distance metric</li>
<li>The RMSD is the average distance among alpha carbons
<ul>
<li>It is calculated as the sum of squares of the coordinates, under square root, divided by the number of points
<ul>
<li>The square of the coordinates under square root is the pitagorean theorem in 3 dimensions (!)</li>
</ul></li>
</ul></li>
<li>Over 60% identity I have more than 90% of residues with RMSD less than 1  <img class="inlinemath" src="eqn000.png" WIDTH=14 HEIGHT=19 STYLE="vertical-align: -1px; margin: 0;" alt="\AA" /></li></ul>
<h1 id="sequence-alignment">Sequence alignment</h1>
<ul>
<li>The score of a position can be considered independent from any other position</li>
<li>It is not always possible to distinguish spurious alignments from true ones</li>
<li>If we assume independence, the probability of having a string of nucleotides is the product of the probability for each nucleotide in the string</li>
<li>If we want to be able to sum scores, we need to take the log of the probabilities (!)</li>
<li>In RNA indipendence is not verified: a position influences the likelyhood of the one next to it
<ul>
<li>High significant scores may be spurious (!)</li>
</ul></li>
<li>The raw score of an alignment is the sum of the score of each match plus the sum of the score of the gaps</li>
<li>For gaps I usually have an open gap penalty and an extension penalty
<ul>
<li>If I work on the core, I normally use the same open and extend penalties</li>
</ul></li>
<li>Similarity takes into account the physicochemical properties of residues</li>
<li>Mutations (expecially indels) in the core are rare because the protein could completely lose structure</li>
<li>Loops tend to mutete frequently</li>
<li>A scoring scheme defines a distance between sequences</li>
<li>Alignment algorithms can be exhaustive (slow) or euristic (fast)</li>
<li>2 every 3 SNPs are transitions</li>
<li>When computing a log-odds, it can happen that the observed frequency of a substitution is 0
<ul>
<li>In this case, we want to add 1 to any count, so to be able to take the logarithm</li>
<li>We add 1 to ALL the scores so that we do not introduce a bias</li>
<li>This is called pseudocount</li>
</ul></li>
<li>Homology is boolean: 2 sequences are either homolgs or not</li>
<li>Scoring matrices can be based on observed substitution, on physicochemical properties, or other data</li>
<li>The McLachlan matrix is based on residue similarity, Grantham on chemical distance</li>
</ul>
<h1 id="pam-matrices">PAM matrices</h1>
<ul>
<li>PAM matrices are based on an evolutionary model, while BLOSUM are based on real alignments</li>
<li>PAM were created by M. Dayhoff in 1972 and their name is an acronim for “point accepted mutation”</li>
<li>A point accepted mutation is the replacement of a residue by another, which is accepted by natural selection</li>
<li>The matrix PAMx is a matrix referring to sequences undergoing x PAM every 100 residues
<ul>
<li>Note that this includes multiple mutations at the same site (!)</li>
</ul></li>
<li>The protein set chosen for building PAM matrices had a minumum identity of 85%</li>
<li>From the set of proteins, they inferred a phylogenetic tree
<ul>
<li>The tree is used to follow all the chain of mutations, also the ones that happened in the same positions</li>
</ul></li>
<li>Higher PAM matrices are computed as powers of PAM1
<ul>
<li>This means that we are using a model, it is not based on observation (!)</li>
</ul></li>
<li>PAM1 is a really stringent matrix: all the values outside the diagonal are really low</li>
<li>The scores of PAM1 are computed as log_odds of the substitutions</li>
</ul>
<h1 id="blosum">BLOSUM</h1>
<ul>
<li>Blosum means block substitution matrix</li>
<li>They were built by Henikoff and Henikoff in 1992</li>
<li>They started from 500 multiple local alignments or related protein sequences</li>
<li>From these they retrieved more than 2000 ungapped multiple sequence alignments (conserved blocks), that formed the BLOCKS database</li>
<li>In each multiple alignment, they clustered all the sequences that showed a % identity and average their log-odds</li>
<li>They were made by alignments of protein sets with different degrees of conservation
<ul>
<li>We do not assume any model, all the substitutions are based on observed frequencies</li>
</ul></li>
<li>High BLOSUM matrices are used for closely related sequences</li>
<li>We can build our own BLOSUMs based on a specific subset of proteins</li>
<li>BLOSUM62 is the best performing matrix for comparing weak homologies</li>
</ul>
<h1 id="needelman-wunsch-algorithm">Needelman Wunsch algorithm</h1>
<ul>
<li>Create the matrix</li>
</ul>
<pre><code>def score_m(s1,s2,S,d):
    init F to 0 matrix
    init F(i,0)
    init F(0,j)
    iteration
    return F</code></pre>
